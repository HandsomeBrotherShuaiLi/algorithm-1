<!-- TOC -->

- [1. 九章算法](#1-%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95)
    - [1.1. Introduction](#11-introduction)
    - [1.2. Binary Tree & Divide Conquer 二叉树与分治法](#12-binary-tree--divide-conquer-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95)
    - [1.3. Breadth First Search 宽度优先搜索](#13-breadth-first-search-%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)
    - [1.4. Depth First Search 深度优先搜索](#14-depth-first-search-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)
    - [1.5. Linked List & Array 链表与数组](#15-linked-list--array-%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84)
    - [1.6. Two Pointers 两根指针](#16-two-pointers-%E4%B8%A4%E6%A0%B9%E6%8C%87%E9%92%88)
    - [1.7. Hash & Heap 哈希表与堆](#17-hash--heap-%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%8E%E5%A0%86)
- [2. 递归 Recursion](#2-%E9%80%92%E5%BD%92-recursion)
    - [2.1. 递归的概念](#21-%E9%80%92%E5%BD%92%E7%9A%84%E6%A6%82%E5%BF%B5)
        - [2.1.1. 递归的三要素](#211-%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0)
        - [2.1.2. 递归与非递归方法的比较](#212-%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83)
    - [2.2. 递归调用栈](#22-%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%A0%88)
        - [2.2.1. 回溯法Backtracking](#221-%E5%9B%9E%E6%BA%AF%E6%B3%95backtracking)
        - [2.2.2. 二分查找/搜索 Binary Search 的递归写法   (二分)](#222-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%90%9C%E7%B4%A2-binary-search-%E7%9A%84%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95---%E4%BA%8C%E5%88%86)
    - [2.3. 值传递和引⽤传递](#23-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E2%BD%A4%E4%BC%A0%E9%80%92)
        - [2.3.1. 值传递](#231-%E5%80%BC%E4%BC%A0%E9%80%92)
        - [2.3.2. 引⽤传递](#232-%E5%BC%95%E2%BD%A4%E4%BC%A0%E9%80%92)
    - [2.4. 递归综合训练](#24-%E9%80%92%E5%BD%92%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83)

<!-- /TOC -->

# 1. 九章算法

## 1.1. Introduction
* Question 7-Subset
* Question 13-Implement strStr()

## 1.2. Binary Tree & Divide Conquer 二叉树与分治法

* Question 66-Binary Tree Preorder Traversal 前序遍历
* Question 67-Binary Tree Inorder Traversal 中序遍历
* Question 68-Binary Tree Postorder Traversal 后序遍历
* Question 97-Maximum Depth of Binary Tree

* Question 480-Binary Tree Paths
* Question 596-Minimum Subtree

* Question 93-Balanced Binary Tree
* Question 597-Subtree with Maximum Average
* Question 88-Lowest Common Ancestor(最近公共祖先) of a Binary Tree

* Question 95-Validate Binary Search Tree

* Question 1534-Convert Binary Search Tree to Doubly Linked List
* Question 453-Flatten Binary Tree to Linked List 

* Question 86-Binary Search Tree Iterator   

* Question 448-Inorder Successor in BST
* Question 11-Search Range in Binary Search Tree
* Question 85-Insert Node in a Binary Search Tree  (不用recursion怎么写???)
* Question 87-Remove Node in Binary Search Tree


* Question not answered or marked: 88,


## 1.3. Breadth First Search 宽度优先搜索 
* Question 69-Binary Tree Level Order Traversal

* Question 7-Serialize and Deserialize Binary Tree  (不太会..)

* Question 70-Binary Tree Level Order Traversal II
* Question 71-Binary Tree Zigzag Level Order Traversal
* Question 242-Convert Binary Tree to Linked Lists by Depth


* Question not answered or marked: 7,


## 1.4. Depth First Search 深度优先搜索

## 1.5. Linked List & Array 链表与数组

## 1.6. Two Pointers 两根指针

## 1.7. Hash & Heap 哈希表与堆




# 2. 递归 Recursion
递归是一种程序设计方式
①递归的概念 	前置知识—函数 (定义&调用函数)     递归的三要素 (定义, 拆解, 出口)
②递归调用栈 内存的堆栈 (内存空间=堆 or 栈)  回溯
③值传递和引⽤传递 (参数传递方式) 
④递归综合训练   e.g. 汉诺塔, 排列组合

## 2.1. 递归的概念
我们生活过程中处理事情主要运用的是什么思想? 我们生活中主要运用迭代思想, 从已知推向未知

### 2.1.1. 递归的三要素 
(递归, 函数的一种调用形式; 与普通函数类似)
* ①递归的定义: 接受什么参数(参数列表), 返回什么值, 代表什么意思 
    - 当函数直接或者间接调用⾃己时, 则发⽣了递归(函数内部出现对自己的调用)
    - 递归的定义: 参见"递归的定义"
    - 递归缩写: Bing - Bing Is Not Google; GNU - GNU's Not Unix; PHP - PHP: Hypertext Preprocessor
* ②递归的拆解: 每次递归都是为了让问题**规模变小**
* ③递归的出口: 必须有⼀个明确的结束条件(递归不会无限进行下去; 类似循环结构)
→ 得到⼀个可供其他函数调用的递归函数

```java
int func(int n){    // 1.递归函数的定义
// 3.递归的出口 (一般递归出口在函数体一开始)
    if (n == 1){ return 1; }
// 2.递归的拆解
    return func(n - 1) * 2 + 1; // (n - 1) 使得问题规模变小
}
```

LintCode 1807.[Fibonacci easy]() 斐波那契数列, 计算斐波那契数列的第n项
- 定义: 斐波那契数列指的是这样⼀个数列0,1,1,2,3,5,8,13,21,34.. 这个数列从第3项开始, 每⼀项都等于前两项之和 (第一项有时为0, 有时为1)
- 关系式: F[i]=F[i−1]+F[i−2]
- 递归函数:
    ```java
    int fib(int n){  // 函数的定义
        if (n <= 2) {  // n=1 or n=2 (第1, 2项)
            return n == 1 ? 0 : 1; // 函数的终止条件
        }
        return fib(n - 1) + fib(n - 2); // 拆解
    }
    ```
* 递归算法, 使用 functools.lru_cache 缓存结果

递归的执⾏过程/递归调用树
(图)
→ DFS顺序

LintCode 366.[Fibonacci]()
* Soln 1: 递归, 复杂度O(2^n), 空间复杂度为O(1), 会超时;
    - fibonacci[i] = fibonacci [i - 1] + fibonacci[i - 2], 故递归式为 thisFibonbacci = dfs(i) + dfs(i - 1)
    - 这么做的有很多被重复计算的数字, 时间复杂度难以接受
    - e.g 求解fib(10), 会找到fib(9)和fib(8)共两个, 然后下一层是fib(8)和fib(7), fib(7)和fib(6)共四个。这是一个呈指数增长的曲线, 其底数为2, 是稳定超时的代码

* Soln 2: 记忆化递归, 时间复杂度O(n), 空间复杂度为O(n)
    - 以空间换时间的优化算法
    - 将计算出的结果存储下来, 在计算到指定值的时候, 先判断这个值是否已经计算过, 若没有, 才进行计算, 否则读取已经存储下来的值。这样就把一个指数级复杂度变成了线性复杂度, 代价是空间复杂度从常数级上升至线性级

* Soln 3: 递推法/循环, 时间复杂度O(n)
    - 动态规划的滚动数组思想, 节省空间: 并不需要存储那么多的fibonacci数, 因为是返回第n项, 并且第n项只和前面的两个数字有关, 所以利用一个长度为2的空间记录前两个数字即可; 时间复杂度不变, 空间复杂度降为O(1)
    
* follow-up: 不超出Integer的斐波那契数很少, 仅有50个左右。 求下标很大的fibonacci数, 并取模数
* Soln 4: 矩阵快速幂 (Fibonacci II)

LintCode 949.[Fibonacci II]()
alternative formula for the Fibonacci sequence:
matrix [[F[n+1], F[n]], [F[n], F[n-1]]] = [[1, 1], [1, 0]] ^ n  = n times of matrix [[1, 1], [1, 0]]
* 矩阵快速幂 
    - LintCode 140.[Fast Power]()   
        Calculate the a^n % b where a, b and n are all 32bit non-negative integers.
    - 矩阵的乘法运算原理: 
    ```
    假设有一个2×2的矩阵 [[1,1],[1,0]] 和 一个2×1的矩阵[[2],[1]], 两个矩阵相乘会变成[[3],[2]], 
    再用[[1,1],[1,0]]和新的矩阵[[3],[2]]继续相乘又会变成[[5],[3]], 继续运算就是[[8],[5]], [[13],[8]]...
    神奇的事情出现了, 当不断地用[[1,1],[1,0]]乘上初始矩阵, 得到的新矩阵的上面一个元素就会变成的fibonacci数列中的一个数字, 
    下面的元素则是上面元素的前一项, 而且每多乘一次, 这个数字的下标就增加一。
    那么这个矩阵是怎么来的呢?

    推理中发现：某个矩阵A乘上[[fib(n+1)], [fib(n)]]会变成[[fib(n+2)], [fib(n+1)]]。
    现在设矩阵为[[a,b], [c,d]], 则可以列出下面的等式：
    a fib(n + 1) + b fib(n) = fib(n + 2)
    c fib(n + 1) + d fib(n) = fib(n + 1)
    很容易地, 我们得到：
    1 fib(n + 1) + 1 fib(n) = fib(n + 2)
    1 fib(n + 1) + 0 fib(n) = fib(n + 1)
    也就是说矩阵是[[1,1], [1,0]]

    原矩阵M连续多次乘上某个矩阵A会得到新的矩阵M', 并且M'的第一个元素就是我们想要的值。
    根据矩阵的运算法则, 中间的若干次相乘可以先乘起来, 但矩阵乘法的复杂度是O(n^3), 是不是一次一次的乘有点慢呢? 
    我们可以使用快速幂来优化矩阵乘法的速度, 这就是矩阵快速幂算法。

    值得注意的是, 在快速幂中, 我们有一步操作是：int result = 1。那么如何使用矩阵来实现这个单位1呢, 我们要借助单位矩阵。
    所谓的单位矩阵是一个从左上角到右下角对角线上都是1, 其余位置都是0的边长相等的矩阵（方阵）。
    比如[[1,0,0],[0,1,0],[0,0,1]]。单位矩阵E的特性在于满足矩阵乘法的任意矩阵AE一定等于A, EA一定等于A。

    将初始矩阵设置为[[1],[0]], 这样只需要将中间矩阵[[1,1],[1,0]]使用快速幂连乘n-2次, 再和[[1],[0]]相乘, 矩阵就变成了[[fib(n)],[fib(n-1)]]

    矩阵快速幂算法常常被应用在递推式的加速中, 可以很轻松的递推至下标相当大的位置, 而不用担心超时
    但是要注意以下两点：
    - 矩阵快速幂使用的过程中要注意是否应该取模, 因为C++和Java会有数值溢出, 如果题目要求递推式取模, 那么有很大概率是一道矩阵快速幂题目
    - 矩阵乘法是没有交换律的（AB ≠ BA）, 因此我们一定要注意乘法顺序

    矩阵乘法是矩阵大小L的三次方, 需要乘logn次。所占的空间一般只有矩阵的空间, 同样是L的三次方
    因此时间复杂度为O(L^3 * logn), 空间复杂度为O(L^3)
    ```

LintCode 771.[Double Factorial]() ⼆阶阶乘/双阶乘, 计算n!!
- 定义: 用符号!!表示, 正整数的双阶乘表示不超过这个正整数且与它有相同奇偶性的所有正整数乘积, 比如 5!! = 5 * 3 * 1 = 15, 6!! = 6 * 4 * 2 = 48   
- 关系式: F[i] = i * F[i−2]
- 递归函数:
    ```java
    int doubleFactorial(int n) {    //阶乘的增长非常快
        if (n <= 3) { // 1=1, 2=2, 3=3*1=3
            return n;
        }
        return n * doubleFactorial(n - 2);
    }
    ```
- 递归的执⾏过程	5!!  df(5) → df(3)		6!!  df(6) → df(4) → df(2)		7!!  df(7) → df(5) → df(3)

盗梦空间与递归 (略)

LintCode 1333.[Reverse Bits]()给⼀个 32 位⽆符号整数, 颠倒它的二进制位
Reverse bits of a given 32 bits unsigned integer
⽐如给 1, 即 00...01, 颠倒之后得到 100...00, 即 2147483648   (max int = 2147483648﹣1, int需要一位记录正负)
以 long 类型的形式进行输⼊输出

利用位运算可以获取⼀个整型的每一个二进制位, 相当于反转⼀个列表
- 递归的思路: 取出列表的最后一个; 递归调用, 反转列表的前n-1个; 把最后一个放到列表最前⾯
    ```java
    // 调用: 需要反转 [31, 0]
    // 终止条件: if(pos == 31) {return n;}
    // 拆解: 需要反转 [31, pos] 之间的位
    long last = n & 1; // 取最后一位
    long ret reverseBits(n >> 1, pos + 1); // 右移一位
    ret += last << (31 - pos);  // 左移(31-pos)位

    // 111..01  last=1
    // 111..0   ret=0..111
    // return 1(第31-pos位)111..0
    ```

### 2.1.2. 递归与非递归方法的比较
递归能做的很多, 不一定要像前⾯两个问题一样有严格的公式 —> 递归思路: 进行问题的拆解, 将问题的规模变小, 一步步趋近于直接可以得到答案的问题

LintCode 822.[Reverse Order Storage]() 
Give a linked list, and store the values of linked list in reverse order into an array.
反转链表: 给⼀个链表, 将这个链表反转之后的元素依次存⼊一个数组, 返回这个数组
- ⾮递归方法解决: 需要⽤栈或者是数组这样⼀个数据结构来辅助 (Stack先进后出, 元素依次入栈; 数组使用两根指针来翻转数组)
- 递归方法解决: 出口 head == null
递归⽅法的另⼀种写法 (使用一个重载的辅助函数)


## 2.2. 递归调用栈
内存中的堆和栈
* 递归深度太⼤容易 “爆栈” Stack Overflow, Segment Fault (桶满了..)
* 堆空间: heap
    - 存放 new 得到的对象(实例)
    - 无限制 (=剩余内存⼤⼩)
* 栈空间: stack
    - 存放对象的引用, 值类型变量(Java), 数组(C/C++), 以及函数调用信息(函数从谁调用的; 结束之后返回带哪里去执行)
    - 有限制, 一般很小, MB量级
对象在堆空间, 但是对象的引用在栈空间
Java的数组存在堆空间, 访问数组通过数组的引用, 在栈空间; C++把普通数组存在栈空间 int a[100];
   
想象一个 “桶” (栈空间), 调⽤的函数需要放到桶里, 第一个进入“桶”的是main()函数
每发生一次新的函数调用, 就会有一个新函数进入“桶”
正在执行的就是最上面的函数; 一个函数执行完毕, 就会被拿出来(一个函数占用“桶”的空间与参数、局部变量的数量有关)

### 2.2.1. 回溯法Backtracking
暴力搜索法的⼀种
试探着找问题的解, 如果到某一步发现上一次的选择不优或者达不到目标, 则退⼀步重新选择 
回溯是递归函数中经常发生的现象
经典问题: ⼋皇后                                              

LintCode 97.[]() 二叉树最⼤深度
* 二叉树中, 一个节点的深度是该节点到根节点的距离+1
* 给定一棵二叉树, 问其中最大的节点的深度是多少
F[i] = max(F[i].left, F[i].right) + 1    F[null] = 0
递归层数与深度有关  

### 2.2.2. 二分查找/搜索 Binary Search 的递归写法   (二分)
在有序数组(假定升序) 中查找某一特定元素 X. 若有重复, 返回任意⼀个下标
1.若数组为空, 查找失败, 不存在 (边界判断)
2.若中间元素恰好是 X, 查找结束
3.若中间元素⼤大于 X, 则到左边的区间继续搜索, 转 1 
4.若中间元素⼩小于 X, 则到右边的区间继续搜索, 转 1
每次把区间长度减掉⼀半, 时间复杂度 O(logN)

LintCode 457.[]()

LintCode 14.[]() First Position of Target 
LintCode 458.[]() Last Position of Target

## 2.3. 值传递和引⽤传递
函数调用的参数传递 (和返回值返回方式)
- Java 值传递, 引用传递
- C++ 值传递, 引用传递, 地址传递   
- Python 值传递, 引用传递

### 2.3.1. 值传递
"盗梦空间" 中, 下层梦境中的人的生死与上层梦境⽆关. 函数内部创建⼀个新的变量, 把值拷贝, 相当于⼀个副本
- Java基本数据类型 (byte, short, int, long, float, double, char, boolean)
- C++ 默认值传递
- Python 值类型 (类似于 Java)
- Java类成员中, 若有 final 修饰, 可以认为具有值传递的特性

### 2.3.2. 引⽤传递
引用, 可以理解为别名, 代号
⽐如我们可以用称号代指某个人 —— 李白: 诗仙, 青莲居士
传引用相当于起了一个新的称号, 代指原本的内容, 本质上是地址

- Java 类的实例     Java中类的实例本身就是引用  A x = new A();
- C++ 在参数列表中加 & 修饰
- Python 引⽤类型 (类似于 Java, ⽐如列表 (可以认为是list类的实例), 类的实例)   
- Java 类成员中, 若有 final 修饰, 可以认为是值传递

*想要知道 Java 的某个类呈现值传递的特性还是引用传递的特性?   查资料/试验!*

值传递和引⽤传递的主要区别: 内容是否复制; 空间占⽤ / 复制的时间消耗; 修改是否影响上⼀层
递归要在保证正确性的前提下, 尽可能提高效率. 需要考虑不仅参数传递, 还有返回值 (→尽量传引用)
   
LintCode 22.[]() 列表扁平化
给⼀个列表, 每个元素可能是⼀个整数, 也可能是⼀个列表, 将其转化为⼀个只包含整数的简单列表
比如 [1, [2, 3], [4, [5]]] 应该被转化为 [1, 2, 3, 4, 5]
对于 Java / C++ 提供特定的接口: 判断⼀个元素是否整数; 返回这个整数 (仅在是整数的时候可调⽤用) ;  返回这个列表
- 递归的定义: flatten(nestedList) 传⼊列表, 返回扁平化的列表
- 递归的拆解: nestedList 中的每个列表元素都递归地调⽤ flatten() 进⾏扁平化 
- 递归的出⼝: 列表中的元素均为整数

LintCode 66, 67, 68.[]() ⼆叉树的遍历 Binary Tree Preorder/Inorder/Postorder Traversal
使⽤递归可以访问⼀颗⼆叉树的所有节点
定义: traverse(node) 		拆解: traverse(node.left/right) 	  出⼝: node == null
⼆叉树的三种遍历顺序: 前/中/后序遍历   前序列:124356	中序列:421536	后序列:425631
* 前序遍历: 先访问当前节点, 再访问左右子树
* 中序遍历: 先访问左⼦树, 再访问当前节点, 最后访问右子树   
* 后序遍历: 先访问左右子树, 再访问当前节点

LintCode 72.[]() Construct Binary Tree from Inorder and Postorder Traversal 确定⼀棵⼆叉树
三种遍历序列, 其中⼀个相同, ⼆叉树不⼀定相同
* 中序列相同, 前序列相同, ⼆叉树相同
* 中序列相同, 后序列相同, ⼆叉树相同
由⼆叉树的中序列再加上前/后序列之⼀即可确定⼀棵⼆叉树 (必须⽆重复节点)

中序列:425136   后序列:452631

⼦树的序列是连续的
后序列的最后⼀个是当前序列对应的⼆叉树的根节点 
再由中序列可以确定左右子树的序列长度
递归的定义: buildTree(inorder, postorder)
递归的拆解: root.left = buildTree(leftInorder, leftPostorder)    	root.right = buildTree(rightInorder, rightPostorder) 
递归的出口: inorder == postorder == ""


## 2.4. 递归综合训练

LintCode 551.[]() 嵌套列表加权和 Nested List Weight Sum
在 22. Flatten List 中提到了嵌套列表 (平化嵌套列表)
现在我们要求这样⼀一个列列表的元素的加权和, 每个元素的权重就是这个元素的深度  (元素×权重)
比如[1,[2,3]]的加权和就是1×1+2×2+3×2=11    [1,[2,[3]]]的加权和就是1×1+2×2+3×3=14 

相当于 22 的 follow up 
LintCode 22 的解决⽅法
- 递归的定义: flatten(nestedList) 传⼊入列表, 返回扁平化的列表
- 递归的拆解: nestedList 中的每个列表元素都递归地调用 flatten() 进⾏扁平化
- 递归的出口: 列表中的元素均为整数
在 22 的基础上思考
- 递归的定义: 增加⼀个参数, 表示当前的深度 (传入列表和当前列表(中整数的)深度, 返回列表的加权和)
- 递归的拆解: 递归调⽤时注意深度的改变 (调用时深度+1)
- 递归的出口: 不变

LintCode 1359.[]() 根据有序数组构造 BST Convert Sorted Array to Binary Search Tree
Binary Search Tree ⼆叉搜索树, 一种特殊的⼆叉树(对于每个节点, 左子树的节点都⽐它⼩, 右子树的节点都⽐它大)
给⼀个有序的数组, 返回一棵合法的二叉搜索树  (中序遍历BST按顺序得到所有元素)

⽐如[1,2,3,4,5], 合法的构造: 

选定⼀个点作为根节点, 由它左边的元素构造左子树, 右边的元素构造右⼦树 (数组有序) 
递归三要素:
- 递归的定义: buildTree(arr) 返回由有序数组 arr 构造的 BST
- 递归的拆解: root.left = buildTree(subarr) 	root.right = buildTree(subarr)
- 递归的出⼝口: arr == null 

增加要求:
    ⼆叉树的深度最小 (LintCode 177)
    ⼆叉树的每⼀个节点的两个子树的最⼤深度相差不超过 1 (LintCode 1359) 
思考: 递归的哪⼀步影响⼆叉树的深度?

LintCode 1106.[]() 最⼤二叉树 Maximum Binary Tree
给⼀个⽆重复元素的数组, 按照以下规则构造⼀棵二叉树	
根节点是当前数组中最⼤的元素	
使⽤用最⼤元素左侧的子数组构造左子树, 右侧的⼦数组构造右子树 
比如[3,2,1,6,0,5]  --> T(6, T(3, None, T(2, None, T(1)), T(5, T(0), None))

- 递归的定义: buildTree(arr) 返回由数组 arr 构造的⼆叉树 
- 递归的拆解: root.left = buildTree(subarr)	root.right = buildTree(subarr) 
- 递归的出口: arr == null

LintCode 469.[]() 是否相同的二叉树 Same Tree
给两棵⼆叉树, 判断它们的结构是否完全相同 (每一个节点权值相等, 并且左右子树也一样)
两棵⼆叉树相同, 当且仅当: 根节点的权值相同; 左⼦树相同; 右⼦树相同 

- 递归的定义: isIdentical(a, b)
- 递归的拆解: isIdentical(al, bl) && isIdentical(ar, br)
- 递归的出⼝口: a == null || b == null 

也可以用序列化解决 → 序列化相同才相同

LintCode 470.[]() 可扭转左右子树 Tweaked Identical Binary Tree 
Follow up 添加一个条件: ⼆叉树的左右子树可以扭转 
如果原本的 "递归的拆解" 得到了了 false, 那么就扭转⼀下再 "拆解" 一次 
- 递归的拆解: (isIdentical(al, bl) && isIdentical(ar, br)) || (isIdentical(al, br) && isIdentical(ar, bl)) 

LintCode 169.[]() 汉诺塔 Tower of Hanoi
有 A, B, C 三根柱⼦和 N 个⼤小互不相同的圆盘 
一开始所有的圆盘都在A柱上, 并且放在下⾯的圆盘都⽐上面的要大 
每次可以将某个柱子上顶端的圆盘移动到另一个柱子上 
在移动过程中也必须满⾜下⾯的圆盘要比上面的⼤大 
问把所有圆盘从A移动到C柱, 最少需要多少次操作, 操作序列是什么? 

一次尝试 A => C 	A => B 	C => B
如果再 A=>C 就完成了最大的盘的一次移动, 最大的盘移动到了目标柱 C! 接下来可以递归来做! 

将3个盘从A移动到C, 先把前2个盘从A移动到B然后把最大盘从A移动到C最后把2个盘从B移动到C 

即想要移动N个盘:
- 递归处理"移动N-1个盘" 
- 把最⼤盘移动一下
- 递归处理 "移动N-1个盘"

递归的定义: hanoi(n, c1, c2, c3) 	// c1: n, c2: 0, c3: 0, c1 => c3 
递归的拆解: 
hanoi(n - 1, c1, c3, c2) 
// move the biggest one from c1 to c3 
hanoi(n - 1, c2, c1, c3) 
递归的出口: n == 1 

