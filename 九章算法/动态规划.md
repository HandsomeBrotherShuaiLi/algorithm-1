<!-- TOC -->

- [1. 背包 Backpack](#1-%E8%83%8C%E5%8C%85-backpack)
    - [1.1. -1背包 knapsack](#11--1%E8%83%8C%E5%8C%85-knapsack)
    - [1.2. 完全背包](#12-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85)
    - [1.3. 多重背包](#13-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85)
    - [1.4. 优化拓展 (空间优化)](#14-%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96)
- [2. 九章算法班 第9节课: 动态规划 Dynamic Programming](#2-%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E7%8F%AD-%E7%AC%AC9%E8%8A%82%E8%AF%BE-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming)
    - [2.1. 适用动态规划的三个条件 & 不适用动态规划的三个条件](#21-%E9%80%82%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6--%E4%B8%8D%E9%80%82%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6)
    - [2.2. 动态规划与递归的关系](#22-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E9%80%92%E5%BD%92%E7%9A%84%E5%85%B3%E7%B3%BB)
    - [2.3. 面试中常见的动态规划类型 (按照状态定义方式划分)](#23-%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B1%BB%E5%9E%8B-%E6%8C%89%E7%85%A7%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86)
    - [2.4. 坐标型动态规划](#24-%E5%9D%90%E6%A0%87%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
    - [2.5. 接龙型动态规划](#25-%E6%8E%A5%E9%BE%99%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
- [3. 九章算法提高班 5, 6 讲](#3-%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E7%8F%AD-5-6-%E8%AE%B2)
- [4. 第五讲](#4-%E7%AC%AC%E4%BA%94%E8%AE%B2)
- [5. 第六讲](#5-%E7%AC%AC%E5%85%AD%E8%AE%B2)
    - [5.1. 区间类DP](#51-%E5%8C%BA%E9%97%B4%E7%B1%BBdp)
    - [5.2. 背包类Dp](#52-%E8%83%8C%E5%8C%85%E7%B1%BBdp)

<!-- /TOC -->

最优解/方式数 -> DP
所有解 -> Recursion, DFS

1.计数 (有多少种方式、方法) how many ways   (也有可能是贪心, greedy algorithm)
2.求最值 (最大数字和, 最大上升子序列长度)
3.求存在性 (是或否, 博弈游戏, 谁获胜, 能不能? 存不存在策略?) 输出True/False 

Lintcode 669: Coin Change

# 1. 背包 Backpack
重要性: 动态规划中的重难点; 面试中的常考点
什么是背包问题? 背包(容量), 物品(所占空间, 价值) -> 不超过背包容量, 价值最大化
主要分类: 0-1背包(取/不取), 完全/无穷背包(所有物品无穷多个), 多重背包(物品有一定的数量)

基本思路 
* 0-1背包 knapsack
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - A[i]] + V[i])
* 完全背包: 枚举每件物品取0, 1, 2, 3 ... m / A[i] 件     
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 
* 多重背包: 枚举每件物品取0, 1, 2, 3 ... amounts[i]件  
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 

## 1.1. -1背包 knapsack
0-1背包三种方法
1. 0-1背包 爆搜 (物品→取/不取, n个物体 枚举2^n) 爆搜不加优化很可能TLE超时
举例: 背包容量 m = 10 物品大小 A = [2, 3, 5, 7] 物品价值 V = [1, 5, 2, 4]
爆搜解法:分别枚举每一个物体取或者不取,1代表取,0代表不取

爆搜算法的局限	TC=O(2^n)
搜索树 (略)
优化的两种思路: ??? ; 剪枝pruning
结果状态
对于前i个物体, 每个都枚举了取或者不取。在确定容量j下, 可能包含了不同的情况, 但我们只需要知道最好的价值就可以了

2. 0-1背包 贪心
取价值最高 m=2, A=[1,1,2], V=[2,2,3]				    贪心答案:3, 正确答案:4
取重量最轻 m=2, A=[1,1,2], V=[1,1,3]				    贪心答案:2, 正确答案:3
取单位价值最高(性价比最高) m=3, A=[1,1,3], V=[2,2,5]	   贪心答案:4, 正确答案:5
局限: 所有的贪心,都是错误的!!!    因为都是考虑当前最优解≠最终最优解

3. 0-1背包 动态规划实现:
背包容量 m = 10 物品大小 A = [2, 3, 5, 7] 物品价值 V = [1, 5, 2, 4]
使用数组来记录取前i个物品, 在容量j的情况下能取的最大价值
*Note: 加一行一列的0, 这样第一个物品可以当做普通物品考虑, 不需要单独处理了*

dp[i][j]表示前i个物体,在容量j的情况下, 能取到的最大价值  row=i=object, col=j=weight
当前物品(物品i)2个选择:
如果取第i个物体,价值为dp[i - 1][j - A[i]] + V[i]   (j-A[i]>0; 若<0则数组越界) 
如果不取第i个物体,价值为dp[i - 1][j]
状态转移: dp[i][j] = max(dp[i - 1][j - A[i]] + V[i], dp[i - 1][j])

空间优化: 滚动数组, 一维数组

LintCode 125. [Backpack II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/背包问题/Backpack%20II.py)
```python
def backPackII(self, m, A, V): # m:背包容量 A:物品大小 V:物品价值
	dp = [[0] * (m + 1) for _ in range(len(A) + 1)]
    
	for i in range(1, len(A) + 1):         # row = num of objects
		for j in range(1, m + 1):   # col = values
			if j - A[i-1] < 0:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - A[i-1]] + V[i-1])
        
	# [print(line) for line in dp]
	return dp[-1][-1]   # dp[len(A) + 1][m]

# 滚动数组优化空间至O(m)
def backPackII(self, m, A, V): # m:背包容量 A:物品大小 V:物品价值
    f = [0 for i in range(m+1)]
    for i in range(len(A)):
        for j in range(m, A[i]-1, -1):
            f[j] = max(f[j] , f[j-A[i]] + V[i])
    return f[m]
    
def backPackII(self, m, A, V): # m:背包容量 A:物品大小 V:物品价值
    dp = [[0] * (m + 1), [0] * (m + 1)]     # 滚动数组
    
    for i in range(1, len(A) + 1):  # i = index of object
        dp[i % 2][0] = 0            
        for j in range(1, m + 1):   # j = total value of objects (0...m)
            dp[i % 2][j] = dp[(i - 1) % 2][j]
            if A[i - 1] <= j:
                dp[i % 2][j] = max(dp[i % 2][j], dp[(i - 1) % 2][j - A[i - 1]] + V[i - 1])
    return dp[len(A) % 2][m]
```
LintCode 563. [Backpack V]()

LintCode 92 两种做法: 体积当做价值 A[i]=V[i] 转化为0-1背包; 装多满的问题, 给定空间x, 能否装满x
LintCode 562 无穷/完全背包 (状态转移方程..)

## 1.2. 完全背包
完全背包: 给定 n 种物品, 每种物品都有无限个。第 i 个物品的体积为A[i], 价值为V[i]。再给定一个容量为 m 的背包。问可以装入背包的最大价值是多少?

1. 基本思路
转移方程
0-1背包: dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - A[i]] + V[i])   当前物品取 vs 不取           容量j
完全背包:枚举每件物品取0, 1, 2, 3…m/A[i]件   (最多取m/A[i]件)
		dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 	不取 vs 取k个

例子分析
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 

i→k (k为最多可以取几次)

2. 完全背包转化为0-1背包: 将第i件物品最多取k个, 转化为k件 (A[i], V[i]) 的物品  (每件都当做单件物品处理)
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]
A = [2, 3, 4, 5] 最多取 4, 2, 2, 1次

LintCode 440. [..]()

在两重循环的条件下, 0-1背包的倒序枚举能解决完全背包的问题吗? 不能  (why???)

0-1背包 一维优化 (二维数组优化成一维)
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]

0-1背包可以用倒序来做; 若正序呢? (0-1背包若正序处理, 每一种物品可能被添加多次, 正好是完全背包的要求)

3. 完全背包 O(V*m) 优化
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]

三种状态: 1)不装该物品   2)第一次装该物品  3)多次添加该物品		3)一定 > 2)
@dp[1][2]  	1) 从dp[0][2]转移     2)从dp[0][2-2] = dp[0][0]转移    3)从dp[1][2-2] = dp[1][0]转移
@dp[1][2]  	1) 从dp[0][2]转移     2)从dp[0][2-2] = dp[0][0]转移    3)从dp[1][2-2] = dp[1][0]转移

LintCode 801 [...]()
LintCode 562 [...]()

## 1.3. 多重背包
多重背包: 给定 n 种物品, 每种物品都有amounts[i]个 (一定个数)。第 i 个物品的体积为 A[i], 价值为 V[i]。再给定一个容量为 m 的背包。问可以装入背包的最大价值是多少? 

1. 基本思路 
0-1 背包: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - A[i]] + V[i]) 
完全背包: 枚举每件物品取0, 1, 2, 3 ... m / A[i] 件     dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 
多重背包: 枚举每件物品取0, 1, 2, 3 ... amounts[i]件  dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 

例子分析 
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 物品数量 A = [2, 1, 2, 1] 

2.完全背包转化为 0-1 背包 
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 
将第i件物品最多取k 个，转化为k件 (A[i], V[i])的物品 

LintCode 798. [...]()
物品 重量 	价值 	个数
	3	300	1
	2	160	6

LintCode 799. [...]()

## 1.4. 优化拓展 (空间优化)
1. 0-1 背包 滚动数组优化 & 一维数组优化
举例2: 背包容量m = 8 物品大小A = [2, 3, 4, 5] 物品价值V = [3, 4, 5, 6]

dp[i][j] = max(dp[i - 1][j – A[i]] + V[i], dp[i - 1][j]) 

①滚动数组优化 
前i个物品能取到的最优价值, 只和前i-1个物品能取到有关 (只需要前面1维)
dp[1][j] = max(dp[0][j – A[i]] + V[i], dp[0][j]) 

②一维数组优化
当前j只和上一层的j, 以及上一层的j - A[i]有关
新的状态转移方程 dp[j] = max(dp[j – A[i]] + V[i], dp[j]) (一定要倒序!!! 倒序更新, 从后往前, 覆盖不影响) 

2. 完全背包 二进制优化
m=8 A=[2, 3, 4, 5] V=[30, 50, 100, 200] 
第0个物品: A[0] = 2, V[0] = 30, 最多取4个 (0, 1, 2, 4)
第1个物品: 最多取2个 
第i个物品: 最多取x个(2^n <= x) 拆分为1, 2, 4, 8...2^n  (→看做取n个不同的物品)
类似快速幂 x^m  (1)for循环n次  (2)m/2

LintCode 1538. [...]()
LintCode 800. [...]() 物品带来的价值 *, 而不是 +
LintCode 700. [...]()
LintCode 749. [...]()


# 2. 九章算法班 第9节课: 动态规划 Dynamic Programming
  通过一道经典题理解动态规划 
  递归与动规的联系与区别
  记忆化搜索
  什么时候使用动态规划

动态规划是一种思想 (类比 Divide Conquer 也是一种思想..)
OOD考察class..

Lintcode 109.[Triangle](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Triangle.py)
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
h=高度 triangle有1+2+..h=O(h^2)个节点(多项式级别), 每个节点有两个前继节点, 坐标变化规则 (x, y) -> [(x+1, y), (x+1, y+1)]
二叉树有O(2^n)个节点(指数级别), 二叉树上每个节点只有一个前继节点
* Soln 1: DFS-Traverse      TC=O(2^n) 慢!
    递归: 1 -> 2 -> 4 -> 8 .. 所以为2^n
    ``` python
    def minimumTotal1(self, triangle):  # (TLE)
        best = self.traverse(0, 0, 0, triangle, float('inf'))
        return best     # best is the answer
        
    def traverse(self, x, y, pathsum, triangle, best):
        if x == len(triangle): # found a whole path from top to bottom
            if pathsum < best:
                return pathsum
        return min(self.traverse(x + 1, y, pathsum + triangle[x][y], triangle, best), self.traverse(x + 1, y + 1, pathsum + triangle[x][y], triangle, best))
    ```
* Soln 2: DFS-Divide Conquer        TC=O(2^n)
    DFS=枚举, 找出所有路径/所有方案  -> n层=2^n条路径
    ``` python
    def minimumTotal2(self, triangle): # (TLE)
        return self.dc(0, 0, triangle) # 从(0, 0)出发走到最底层
        
    def dc(self, x, y, triangle):
        if x == len(triangle):    # None节点, 0..n-1层才有值
            return 0    # if x == len(triangle) - 1: return triangle[x][y] #也可
        return triangle[x][y] + min(self.dc(x + 1, y, triangle), self.dc(x + 1, y + 1, triangle)) # 左右两个节点中的最小值
    ```
* Soln 3: DFS-Divide Conquer + Memorization 避免重复计算表, 把做过的事情&得到的结果 存起来
    TC=O(n^2) SC=O(n^2)
    = DC中, (x, y)不同的组合有多少个 = 参数的组合形式/状态 = O(n^2)种状态 * O(1)每个状态的tc 
    ```python
    def minimumTotal(self, triangle):
        return self.dc_memo(0, 0, triangle, {})

    def dc_memo(self, x, y, triangle, memo): # return minimum path from (x, y) to bottom
        if x == len(triangle): # row index from 0 to n-1 
            return 0
            
        # if already got the minimum path from (x, y) to bottom; just return
        if (x, y) in memo:
            return memo[(x, y)]
            
        # set before return
        memo[(x, y)] = triangle[x][y] + min(self.dc_memo(x + 1, y, triangle, memo), self.dc_memo(x + 1, y + 1, triangle, memo))
        return memo[(x, y)]
    ```
* **记忆化搜索 = 动态规划的实质** Traditional Dynamic Programming
    动态规划为什么会快? 避免重复的中间结果计算, 2^n -> n^2
    动态规划与分治的区别? 动态规划(左边也可能到右边); 分治(左边就是左边, 右边就是右边)
    - 多重循环(推荐) vs 记忆化搜索
        - 多重循环优点: 正规, 大多数面试官可以接受, 存在空间优化可能性    缺点: 思考有难度  
        - 记忆化搜索优点: 容易从搜索算法直接转化过来。有时候可以节省时间    缺点: 递归
    - 自底向上 vs 自顶向下(推荐)

* Soln 4: Dynamic Programming 多重循环 自底向上 Bottom-Up
    TC=O(n^2)
    ```python
    def minimumTotal(self, triangle): # (Iterative Bottom Up)
        f = {}      # define the state 定义状态数组 f: 从(i, j)开始走到底的最小路径长度
        for i in range(len(triangle)):      # initialization 初始化, 先有值
            f[(len(triangle) - 1, i)] = triangle[len(triangle) - 1][i]
        
        # iteration for solution 循环递推求解
        for i in reversed(range(len(triangle)-1)):
            for j in range(0, i+1):
                f[(i, j)] = triangle[i][j] + min(f[(i + 1, j)], f[(i + 1, j + 1)])
        return f[(0, 0)]  # result 求结果=起点
    ```
* Soln 5: Dynamic Programming 多重循环 自顶向下 Top-Down
    ```python
    def minimumTotal(self, triangle): # Iterative Top Down
        f = {(0, 0): triangle[0][0]}  # 初始化, 起点 f: 从(0,0)开始走到(i,j)最小路径长度
        
        # 初始化三角形的左边和右边 (左边无左上角, 右边无右上角)
        for i in range(1, len(triangle)):
            f[(i, 0)] = f[(i - 1, 0)] + triangle[i][0]
            f[(i, i)] = f[(i - 1, i - 1)] + triangle[i][i]
            
        # top Down (亦可不初始化三角形左右边, 在此加入if语句)
        for i in range(1, len(triangle)):
            for j in range(1, i):
                f[(i, j)] = triangle[i][j] + min(f[(i - 1, j)], f[(i - 1, j - 1)])
                
        return min([f[(len(triangle) - 1, j)] for j in range(len(triangle))]) # 底层最小值
    ```
    SC优化: 滚动数组  [i % 2], 这样只用两个一维数组储存f即可


## 2.1. 适用动态规划的三个条件 & 不适用动态规划的三个条件
什么情况下使用动态规划(动态规划解决的问题)? 满足下面三个条件之一, 则*极有可能*是使用动态规划求解: (最优, 可行, 方案数)
- 求最大值最小值 (但有时是DFS/BFS)
- 判断是否可行   
- 统计方案个数

什么情况下不使用动态规划?  (所有方案而不是方案数, 集合而非序列, 暴力算法已经是多项式级别复杂度)
- 求出所有*具体*的方案而非方案个数 Lintcode 136.[Palindrome Partitioning]()
- 输入数据是一个*集合*而不是*序列* (集合可以换顺序, 序列不可) Lintcode 124.[Longest Consecutive Sequence]()
- 暴力算法的复杂度已经是多项式级别: 动态规划擅长与优化指数级别复杂度(2^n, n!)到多项式级别复杂度(n^2, n^3); 不擅长优化n^3(3个循环)到n^2(2个循环)
则 极不可能 使用动态规划求解

## 2.2. 动态规划与递归的关系
动规四要素 (状态, 方程, 初始化, 答案)
* **状态 State** 灵感, 创造力, 存储小规模问题的结果
* **方程 Function** 状态之间的联系, 怎么通过小的状态, 来算大的状态 (大问题拆解成小问题)
* **初始化 Initialization** 最极限的小状态是什么, 起点
* **答案 Answer** 最大的那个状态是什么, 终点

递归三要素: (以及调用参数时传什么)
* 定义(状态) 接受什么参数; 做了什么事; 返回什么值   
* 拆解(方程) 如何将参数变小   
* 出口(初始化) 什么时候可以直接 return

## 2.3. 面试中常见的动态规划类型 (按照状态定义方式划分)
坐标型(矩阵)动态规划 10%    (f[x][y], 有坐标信息)
接龙型动态规划 20%  
划分型动态规划      匹配型动态规划      背包型动态规划      区间型动态规划      树图型动态规划  
博弈型动态规划 (游戏, 2人博弈 90%都是DP)

## 2.4. 坐标型动态规划
state: f[x]表示从起点走到坐标x...      f[x][y]表示从起点走到坐标x, y...
function: 研究走到x,y这个点之前的一步   
initialize: 起点    answer: 终点

Lintcode 110.[Minimum Path Sum](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Minimum%20Path%20Sum.py)
state: f[x][y]从起点走到x,y的最短路径
function: f[x][y] = min(f[x-1][y], f[x][y-1]) + A[x][y]
intialize: f[i][0] = sum(0,0 ~ i,0), f[0][i] = sum(0,0 ~ 0,i)
answer: f[n-1][m-1]

独孤九剑 —— 破气式 初始化一个二维的动态规划时,就去初始化第0行和第0列 (自顶向下)

Lintcode 114.[Unique Paths](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Unique%20Paths.py)
state: f[x][y]从起点到x,y的路径数
function: (研究倒数第一步) f[x][y] = f[x - 1][y] + f[x][y - 1]
initialize: f[0][i] = 1, f[i][0] = 1
answer: f[n-1][m-1]

Lintcode 115.[Unique Paths II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Unique%20Paths%20II.py)

Lintcode 111.[Climbing Stairs](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Climbing%20Stairs.py)
state: f[i]表示跳到第i个位置的方案总数   
function: f[i] = f[i-1] + f[i-2]
initialize: f[0] = 1
answer: f[n] // index from 0\~n

Lintcode 116.[Jump Game](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Jump%20Game.py)
Lintcode 117.[Jump Game II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Jump%20Game%20II.py)
这2个题最优的方法是使用“贪心法”, 动态规划复杂度较高 (Greedy题目间相似性小, 可复用性太差)

## 2.5. 接龙型动态规划 
属于“坐标型”动态规划的一种, 一维的坐标型
接龙规则 -> 求出long最长多长

Lintcode 76.[Longest Increasing Subsequence](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Longest%20Increasing%20Subsequence.py)
Given a sequence of integers, find the longest increasing subsequence (LIS 递增序列)
将n个数看做n个木桩, 目的是从某个木桩出发, 从前向后, 从低往高, 看最多能踩多少个木桩 
- state: f[i]表示(从任意某个木桩)跳到第i个木桩, 最多踩过多少根木桩 (LIS是多少)
    f[i] 以第i位置结尾的最长LIS?  ✔️ (坐标型也是这样)
         前i个数里的LIS?
- function: f[i] = max{f[j] + 1}, j必须满足 j < i && nums[j] < nums[i]
- initialize: f[0..n-1] = 1     --> 每个位置都可以作为起点
- answer: max{f[0..n-1]}        --> for循环所有位置
e.g. [5, 4, 1, 2, 3] 对应一种subsequence的方案[0, 0, 1, 1, 1]  共2^n种方案, 可以用二进制对应方案 (可以用二进制的方法)

Lintcode 602.[Russian Doll Envelopes](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Russian%20Doll%20Envelopes.py) LIS+排序  3维  没懂bisect那个。。

Lintcode 603.[Largest Divisible Subset](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Largest%20Divisible%20Subset.py) 
先排序; 之前的接龙条件是小于关系, 现在的接龙条件是倍数关系

动态规划只能记录一种最优的方案, 动规无法记录所有的最优方案, 为什么? 可以记录状态最优值是从哪里来的

Lintcode 622.[Frog Jump](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Frog%20Jump.py)


# 3. 九章算法提高班 5, 6 讲

# 4. 第五讲
Overview
滚动数组
House Robber I/II
Maximal Square
记忆化搜索
Longest Increasing Subsequence
Coin in a line I/II/III
  

动态规划的4点要素 1. 状态 State
灵感，创造力，存储小规模问题的结果
最优解/Maximum/Minimum
Yes/No
Count(*)
2. 方程 Function
状态之间的联系，怎么通过小的状态，来求得大的状态
3. 初始化 Intialization
最极限的小状态是什么, 起点
4. 答案 Answer
最大的那个状态是什么，终点
    
滚动数组优化
f[i] = max(f[i-1], f[i-2] + A[i]);
转换为
f[i%2] = max(f[(i-1)%2]和 f[(i-2)%2])
   

 
    House Robber
http://www.lintcode.com/en/problem/house-robber/
http://www.jiuzhang.com/solutions/house-robber/
公主追王子 For循环 -----> DP

  序列型动态规划
状态 State
f[i] 表示前i个房子中，偷到的最大价值 方程 Function
f[i] = max(f[i-1], f[i-2] + A[i]);
初始化 Intialization
f[0] = 0;
f[1] = A[0];
答案 Answer
f[n]
  

House Robber II
http://www.lintcode.com/en/problem/house-robber-ii/
http://www.jiuzhang.com/solutions/house-robber-ii/
 
   滚动数组优化一维
  这类题目特点
f[i] = max(f[i-1], f[i-2] + A[i]); 由 f[i-1],f[i-2] 来决定状态
可以转化为
f[i%2] = max(f[(i-1)%2]和 f[(i-2)%2]) 由f[(i-1)%2]和 f[(i-2)%2] 来决定状态
观察我们需要保留的状态来确定模数
其他一维滚动数组的题目
http://www.lintcode.com/en/problem/climbing-stairs/
   

 
    Maximal Square
http://www.lintcode.com/en/problem/maximal-square/
http://www.jiuzhang.com/solutions/maximal-square/
    
 
    小技巧
网格类的题目 正方形用右下角作为定位角 长方形可以用左上角和右下角作为定位角
  
 
  Maximal Square
1. 状态 State
f[i][j] 表示以i和j作为正方形右下角可以拓展的最大边长
2. 方程 Function
if matrix[i][j] == 1
f[i][j] = min(LEFT[i - 1][j], UP[i][j-1], f[i-1][j-1]) + 1; if matrix[i][j] == 0
f[i][j] = 0
3. 初始化 Intialization
f[i][0] = matrix[i][0];
f[0][j] = matrix[0][j];
4. 答案 Answer
max{f[i][j]}
  
 
  Maximal Square
1. 状态 State
f[i][j] 表示以i和j作为正方形右下角可以拓展的最大边长
2. 方程 Function
if matrix[i][j] == 1
f[i][j] = min(f[i - 1][j], f[i][j-1], f[i-1][j-1]) + 1; if matrix[i][j] == 0
f[i][j] = 0
3. 初始化 Intialization
f[i][0] = matrix[i][0];
f[0][j] = matrix[0][j];
4. 答案 Answer
max{f[i][j]}
  
 
  Maximal Square
1. 状态 State
f[i][j] 表示以i和j作为正方形右下角可以拓展的最大边长
2. 方程 Function
if matrix[i][j] == 1
f[i%2][j] = min(f[(i - 1)%2][j], f[i%2][j-1], f[(i-1)%2][j-1]) + 1; if matrix[i][j] == 0
f[i%2][j] = 0
3. 初始化 Intialization
f[i%2][0] = matrix[i%2][0];
f[0][j] = matrix[0][j];
4. 答案 Answer
max{f[i%2][j]}
  
 
Follow up
01矩阵里面找一个，对角线全为1， 其他为0的矩阵
  
 
二维动态规划空间优化
这类题目特点
f[i][j] = 由f[i-1]行 来决定状态， 第i行跟 i-1行之前毫无关系， 所以状态转变为
f[i%2][j] = 由f[(i-1)%2]行来决定状态
  
 
二维滚动数组相关题目 Unique Paths
http://www.lintcode.com/en/problem/unique-paths/
Minimum Path Sum
http://www.lintcode.com/en/problem/minimum-path-sum/
Edit Distance
http://www.lintcode.com/en/problem/edit-distance/
      
记忆化搜索
本质上:动态规划
动态规划就是解决了重复计算的搜索
动态规划的实现方式:
循环(从小到大递推)
记忆化搜索(从大到小搜索)
画搜索树 万金油

Longest Increasing Subsequence
http://www.lintcode.com/en/problem/longest-increasing-
continuous-subsequence/
http://www.jiuzhang.com/solutions/longest-increasing-continuous- subsequence/
[4, 2, 5, 4, 3, 9,8,10]
       

 
Longest Increasing continuous Subsequence 2D
http://www.lintcode.com/en/problem/longest-increasing-continuous-subsequence-ii/ 
http://www.jiuzhang.com/solutions/longest-increasing-continuous- subsequence-ii/

多重循环DP遇到的困难:
从上到下循环不能解决问题 初始状态找不到
那我们有没有可以比较暴力解决的方法呢? 有搜索， 我们从大的往小的搜索

普通搜索 记忆化搜索
那怎么根据DP四要素转化为记忆化搜索呢? State: dp[x][y] 以x,y作为结尾的最长子序列
Function:
遍历x,y 上下左右四个格子 dp[x][y] = dp[nx][ny] + 1
•(if a[x][y] > a[nx][ny]) Intialize:
dp[x][y] 是极小值时，初始化为1 Answer: dp[x][y]中最大值
  
什么时候用记忆化搜索?  1. 状态转移特别麻烦，不是顺序性。 2. 初始化状态不是很容易找到。

博弈类DP

博弈类
 
Coins in a line
http://www.lintcode.com/en/problem/coins-in-a-line/
http://www.jiuzhang.com/solutions/coins-in-a-line/
     
博弈类DP 博弈有先后手
State:
定义一个人的状态
Function:
考虑两个人的状态做状态更新
Intialize: Answer:
先思考最小状态
然后思考大的状态-> 往小的递推，那么非常适合记忆化搜索
    
Coins in a line
State:
dp[i] 现在还剩i个硬币，现在当前取硬币的人最后输赢状况
Function:
dp[n] = (!dp[n-1]) || (!dp[n-2])
Intialize:
dp[0] = false
dp[1] = true dp[2] = true
Answer: dp[n]
  
Coins in a Line II
http://www.lintcode.com/en/problem/coins-in-a-line-ii/
http://www.jiuzhang.com/solutions/coins-in-a-line-ii/
[5,1,2,10]

State:
dp[i] 现在还剩i个硬币，现在当前取硬币的人最后最多取硬币价值
Function:
n 是所有硬币数目
sum[i] 是后i个硬币的总和
dp[i] = sum[i]-min(dp[i-1], dp[i-2])
Intialize:
dp[0] = 0
dp[1] = coin[i-1]
dp[2] = coin[i-2] + coin[i-1]
Answer: dp[n]

 
Coins in a Line III
http://www.lintcode.com/en/problem/coins-in-a-line-iii

  State:
dp[i][j] 现在还第i到第j的硬币，现在当前取硬币的人最后最多取硬币价值
Function:
sum[i][j]第i到第j的硬币价值总和
dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);
Intialize:
dp[i][i] = coin[i],
Answer:
dp[0][n-1]
  
   什么时候用记忆化搜索?
状态转移特别麻烦，不是顺序性。
Longest Increasing continuous Subsequence 2D 遍历x,y 上下左右四个格子 dp[x][y] = dp[nx][ny]
Coins in a Line III
dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);
初始化状态不是很容易找到
Stone Game
初始化dp[i][i] = 0
Longest Increasing continuous Subsequence 2D 初始化极小值
从大到小
 
   今日重点三题
  House Robber
滚动数组优化最简单的入门。
Longest Increasing continuous Subsequence 2D 记忆化搜索的经典题，此题只有记忆化搜索才能最优。
Coins in a Line III
博弈问题和记忆化搜索的结合

 
# 5. 第六讲
Overview
I. 区间类DP
I. Stone Game
II. Burst Ballons
III. Scramble String

II. 背包类DP
I. BackPackI
II. BackPackII
III. K SUM
IV. Minimum Adjustment Cost

## 5.1. 区间类DP
区间类Dp 特点: 1. 求一段区间的解max/min/count 2. 转移方程通过区间更新 3. 从大到小的更新

Stone Game
http://www.lintcode.com/en/problem/stone-game/ [3,4,5,6]

Stone-Game
死胡同:容易想到的一个思路从小往大，枚举第一次合并是在哪?
记忆化搜索的思路，从大到小，先考虑最后的0-n-1 合并的总花费
State:
dp[i][j] 表示把第i到第j个石子合并到一起的最小花费
Function:
预处理sum[i,j] 表示i到j所有石子价值和
dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum[i,j]) 对于所有k属于{i,j}
Intialize:
for each i
dp[i][i] = 0
Answer:
dp[0][n-1]

Burst Ballons
http://www.lintcode.com/en/problem/burst-balloons/
贪心反例: [1,1,1,1]

Burst Ballons
死胡同:容易想到的一个思路从小往大，枚举第一次在哪吹爆气球?
记忆化搜索的思路，从大到小，先考虑最后的0-n-1 合并的总价值 State:
dp[i][j] 表示把第i到第j个气球打爆的最大价值
Function:
对于所有k属于{i,j}, 表示第k号气球最后打爆。
midValue = arr[i- 1] * arr[k] * arr[j+ 1];
dp[i][j] = min(dp[i][k-1]+d[k+1][j]+midvalue)
Intialize:
for each i
dp[i][i] = 0
Answer:
dp[0][n-1]

Scramble String
http://www.lintcode.com/en/problem/scramble-string/
看 f[great][rgreat] 这个参考例子
f[gr|eat][rgreat] = f[gr][rg] && f[eat][eat] f[gr][at] && f[eat][rgr]

State:
dp[x][y][k] 表示是从s1串x开始，s2串y开始，他们后面k个字符组成的substr是Scramble String
Function:
对于所有i属于{1,k}
s11 = s1.substring(0, i); s12 = s1.substring(i, s1.length());
s21 = s2.substring(0, i); s22 = s2.substring(i, s2.length());
s23 = s2.substring(0, s2.length() - i); s24 = s2.substring(s2.length() - i, s2.length());
for i = x -> x+k
dp[x][y][k] = (dp[x][y][i] && dp[x+i][y+i][k-i]) || dp[x][y+k-i][i] && dp[x+i][y][k-i])
Intialize:
dp[i][j][1] = s1[i]==s[j].
Answer:
dp[0][0][len]

区间DP
coin in a line III stone game
scramble string
这种题目共性就是区间最后求[0,n-1] 这样一个区间 逆向思维分析 从大到小就能迎刃而解
逆向=》 分治类似

## 5.2. 背包类Dp 
特点: 1. 用值作为DP维度 2. Dp过程就是填写矩阵 3. 可以滚动数组优化


BackPack
http://www.lintcode.com/en/problem/backpack/
硬币凑整

State:
f[i][S] “前i”个物品，取出一些能否组成和为S Function:
f[i][S] = f[i-1][S - a[i]] or f[i-1][S]
Intialize:
f[i][0] = true; f[0][1..target] = false
Answer:
检查所有的f[n][j]
O(n*S) ， 滚动数组优化

BackPack 马甲题型 变1 硬币凑整
给1，2，5，10硬币无数多个，请问凑80元的方案总数

BackPack 马甲题型 变2 把一个[1,24,5,6]数组尽量平分。
Backpack II
http://www.lintcode.com/en/problem/backpack-ii/
贪心反例: 背包容量 = 9 A=[4,5,7] V=[3,4,6]

状态 State
f[i][j] 表示前i个物品当中选一些物品组成容量为j的最大价值
方程 Function
f[i][j] = max(f[i-1][j], f[i-1][j-A[i-1]] + V[i-1]);
初始化 Intialization f[0][0]=0;
答案 Answer f[n][s]
O(n*s)

K Sum
http://www.lintcode.com/en/problem/k-sum/
n个数，取k个数，组成和为target State:
f[i][j][t]前i个数取j个数出来能否和为t Function:
f[i][j][t] = f[i - 1][j - 1][t - a[i-1]] or f[i - 1][j][t]
Intialization
f[i][0][0] = 1
Answer
f[n][k][target]

Minimum Adjustment Cost
http://www.lintcode.com/en/problem/minimum-adjustment-cost/

最小调整代价 State:
f[i][v] 前i个数，第i个数调整为v，满足相邻两数<=target，所需要的最小代价 Function:
f[i][v] = min(f[i-1][v’] + |A[i]-v|, |v-v’| <= target)
Answer:
f[n][a[n]-target~a[n]+target]
O(n * A * T)

Summary
区间类DP问题
从大到小去思考
主要是通过记忆化来直观理解DP的思路
背包DP问题
用值作为DP维度
Dp过程就是填写矩阵 可以滚动数组优化

今日重点题型 Backpack II
有价值的背包题目才有价值 Stone-Game
区间类DP的入门题