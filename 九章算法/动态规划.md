<!-- TOC -->

- [1. 九章算法班 第9节课: 动态规划 Dynamic Programming](#1-%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E7%8F%AD-%E7%AC%AC9%E8%8A%82%E8%AF%BE-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming)
    - [1.1. 适用动态规划的三个条件 & 不适用动态规划的三个条件](#11-%E9%80%82%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6--%E4%B8%8D%E9%80%82%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6)
    - [1.2. 动态规划与递归的关系 (联系与区别)](#12-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E9%80%92%E5%BD%92%E7%9A%84%E5%85%B3%E7%B3%BB-%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB)
    - [1.3. 面试中常见的动态规划类型 (按照状态定义方式划分)](#13-%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B1%BB%E5%9E%8B-%E6%8C%89%E7%85%A7%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86)
- [2. 坐标型动态规划](#2-%E5%9D%90%E6%A0%87%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
    - [2.1. 滚动数组 Sliding Array 动态规划空间优化](#21-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84-sliding-array-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96)
- [3. 接龙型动态规划](#3-%E6%8E%A5%E9%BE%99%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
- [4. 划分型动态规划 Partition DP](#4-%E5%88%92%E5%88%86%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-partition-dp)
- [5. 博弈类动态规划 Game DP](#5-%E5%8D%9A%E5%BC%88%E7%B1%BB%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-game-dp)
- [6. 区间类 Interval DP](#6-%E5%8C%BA%E9%97%B4%E7%B1%BB-interval-dp)
- [7. 双序列型动态规划](#7-%E5%8F%8C%E5%BA%8F%E5%88%97%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
- [8. 背包型DP backpack](#8-%E8%83%8C%E5%8C%85%E5%9E%8Bdp-backpack)
    - [8.1. 背包 Backpack](#81-%E8%83%8C%E5%8C%85-backpack)
    - [8.2. 0-1背包 knapsack](#82-0-1%E8%83%8C%E5%8C%85-knapsack)
    - [8.3. 完全背包](#83-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85)
    - [8.4. 多重背包](#84-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85)
    - [8.5. 优化拓展 (空间优化)](#85-%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96)
- [9. DP面试要求 & 现状:](#9-dp%E9%9D%A2%E8%AF%95%E8%A6%81%E6%B1%82--%E7%8E%B0%E7%8A%B6)

<!-- /TOC -->

This note includes:
- 九章算法班v4.2第九章 动态规划  (Done)
- 九章算法提高班(2019) Chapter 5 & 6  (Doing)
- 九章算法背包四讲  (Doing)
- 九章算法强化班(旧) Chapter 5 & 6
- 九章算法动态规划班 Chapter 1~7

---

最优解/方式数 -> DP
所有解 -> Recursion, DFS

1.计数 (有多少种方式、方法) how many ways   (也有可能是贪心, greedy algorithm)
2.求最值 (最大数字和, 最大上升子序列长度)
3.求存在性 (是或否, 博弈游戏, 谁获胜, 能不能? 存不存在策略?) 输出True/False 

Lintcode 669: Coin Change


# 1. 九章算法班 第9节课: 动态规划 Dynamic Programming
动态规划是一种思想 (类比 Divide Conquer 也是一种思想..)
OOD考察class..

Lintcode 109.[Triangle](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Triangle.py)
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
h=高度 triangle有1+2+..h=O(h^2)个节点(多项式级别), 每个节点有两个前继节点, 坐标变化规则 (x, y) -> [(x+1, y), (x+1, y+1)]
二叉树有O(2^n)个节点(指数级别), 二叉树上每个节点只有一个前继节点
* Soln 1: DFS-Traverse      TC=O(2^n) 慢!
    递归: 1 -> 2 -> 4 -> 8 .. 所以为2^n
    ``` python
    def minimumTotal1(self, triangle):  # (TLE)
        best = self.traverse(0, 0, 0, triangle, float('inf'))
        return best     # best is the answer
        
    def traverse(self, x, y, pathsum, triangle, best):
        if x == len(triangle): # found a whole path from top to bottom
            if pathsum < best:
                return pathsum
        return min(self.traverse(x + 1, y, pathsum + triangle[x][y], triangle, best), self.traverse(x + 1, y + 1, pathsum + triangle[x][y], triangle, best))
    ```
* Soln 2: DFS-Divide Conquer        TC=O(2^n)
    DFS=枚举, 找出所有路径/所有方案  -> n层=2^n条路径
    ``` python
    def minimumTotal2(self, triangle): # (TLE)
        return self.dc(0, 0, triangle) # 从(0, 0)出发走到最底层
        
    def dc(self, x, y, triangle):
        if x == len(triangle):    # None节点, 0..n-1层才有值
            return 0    # if x == len(triangle) - 1: return triangle[x][y] #也可
        return triangle[x][y] + min(self.dc(x + 1, y, triangle), self.dc(x + 1, y + 1, triangle)) # 左右两个节点中的最小值
    ```
* Soln 3: DFS-Divide Conquer + Memorization 避免重复计算表, 把做过的事情&得到的结果 存起来
    TC=O(n^2) SC=O(n^2)
    = DC中, (x, y)不同的组合有多少个 = 参数的组合形式/状态 = O(n^2)种状态 * O(1)每个状态的tc 
    ```python
    def minimumTotal(self, triangle):
        return self.dc_memo(0, 0, triangle, {})

    def dc_memo(self, x, y, triangle, memo): # return minimum path from (x, y) to bottom
        if x == len(triangle): # row index from 0 to n-1 
            return 0
            
        # if already got the minimum path from (x, y) to bottom; just return
        if (x, y) in memo:
            return memo[(x, y)]
            
        # set before return
        memo[(x, y)] = triangle[x][y] + min(self.dc_memo(x + 1, y, triangle, memo), self.dc_memo(x + 1, y + 1, triangle, memo))
        return memo[(x, y)]
    ```
* **记忆化搜索 = 动态规划的实质** Traditional Dynamic Programming
    动态规划为什么会快? 避免重复的中间结果计算, 2^n -> n^2
    动态规划与分治的区别? 动态规划(左边也可能到右边); 分治(左边就是左边, 右边就是右边)
    - 多重循环(推荐) vs 记忆化搜索
        - 多重循环优点: 正规, 大多数面试官可以接受, 存在空间优化可能性    缺点: 思考有难度  
        - 记忆化搜索优点: 容易从搜索算法直接转化过来。有时候可以节省时间    缺点: 递归
    - 自底向上 vs 自顶向下(推荐)

* Soln 4: Dynamic Programming 多重循环 自底向上 Bottom-Up
    TC=O(n^2)
    ```python
    def minimumTotal(self, triangle): # (Iterative Bottom Up)
        f = {}      # define the state 定义状态数组 f: 从(i, j)开始走到底的最小路径长度
        for i in range(len(triangle)):      # initialization 初始化, 先有值
            f[(len(triangle) - 1, i)] = triangle[len(triangle) - 1][i]
        
        # iteration for solution 循环递推求解
        for i in reversed(range(len(triangle)-1)):
            for j in range(0, i+1):
                f[(i, j)] = triangle[i][j] + min(f[(i + 1, j)], f[(i + 1, j + 1)])
        return f[(0, 0)]  # result 求结果=起点
    ```
* Soln 5: Dynamic Programming 多重循环 自顶向下 Top-Down
    ```python
    def minimumTotal(self, triangle): # Iterative Top Down
        f = {(0, 0): triangle[0][0]}  # 初始化, 起点 f: 从(0,0)开始走到(i,j)最小路径长度
        
        # 初始化三角形的左边和右边 (左边无左上角, 右边无右上角)
        for i in range(1, len(triangle)):
            f[(i, 0)] = f[(i - 1, 0)] + triangle[i][0]
            f[(i, i)] = f[(i - 1, i - 1)] + triangle[i][i]
            
        # top Down (亦可不初始化三角形左右边, 在此加入if语句)
        for i in range(1, len(triangle)):
            for j in range(1, i):
                f[(i, j)] = triangle[i][j] + min(f[(i - 1, j)], f[(i - 1, j - 1)])
                
        return min([f[(len(triangle) - 1, j)] for j in range(len(triangle))]) # 底层最小值
    ```
    SC优化: 滚动数组  [i % 2], 这样只用两个一维数组储存f即可


## 1.1. 适用动态规划的三个条件 & 不适用动态规划的三个条件
什么情况下使用动态规划(动态规划解决的问题)? 满足下面三个条件之一, 则*极有可能*是使用动态规划求解: (最优, 可行, 方案数)
- 求最大值最小值 (但有时是DFS/BFS)
- 判断是否可行   
- 统计方案个数

什么情况下不使用动态规划?  (所有方案而不是方案数, 集合而非序列, 暴力算法已经是多项式级别复杂度)
- 求出所有*具体*的方案而非方案个数 Lintcode 136.[Palindrome Partitioning]()
- 输入数据是一个*集合*而不是*序列* (集合可以换顺序, 序列不可) Lintcode 124.[Longest Consecutive Sequence]()
- 暴力算法的复杂度已经是多项式级别: 动态规划擅长与优化指数级别复杂度(2^n, n!)到多项式级别复杂度(n^2, n^3); 不擅长优化n^3(3个循环)到n^2(2个循环)
则 极不可能 使用动态规划求解

## 1.2. 动态规划与递归的关系 (联系与区别)
动规四要素 (状态, 方程, 初始化, 答案)
* **状态 State** 灵感, 创造力, 存储小规模问题的结果
* **方程 Function** 状态之间的联系, 怎么通过小的状态, 来算大的状态 (大问题拆解成小问题)
* **初始化 Initialization** 最极限的小状态是什么, 起点
* **答案 Answer** 最大的那个状态是什么, 终点

**动态规划四个组成部分**
1. 确定状态
    研究最优策略的最后一步, 化为子问题 (把问题规模缩小, subproblem; 与原问题相同但规模更小)
2. 转移方程: 子问题 -> 大问题
    根据子问题定义直接得到
    左, 要求的问题(大问题, 规模大一点的); 右, 告诉你怎么求 (子问题)
3. 初始条件和边界情况 
    初始条件, 某些状态不能由转移方程得出, 但又需要
    边界情况, 不要数组越界
    细心, 考虑周全
4. 计算顺序 (子问题先算, 大问题后算) 
    利用之前的计算结果

递归三要素: (以及调用参数时传什么)
* 定义(状态) 接受什么参数; 做了什么事; 返回什么值   
* 拆解(方程) 如何将参数变小   
* 出口(初始化) 什么时候可以直接 return

## 1.3. 面试中常见的动态规划类型 (按照状态定义方式划分)
坐标型(矩阵)动态规划 10%    (f[x][y], 有坐标信息)
接龙型动态规划 20%  
划分型动态规划      匹配型动态规划      背包型动态规划      区间型动态规划      树图型动态规划  
博弈型动态规划 (游戏, 2人博弈 90%都是DP)

# 2. 坐标型动态规划
state: f[x]表示从起点走到坐标x...      f[x][y]表示从起点走到坐标x, y...
function: 研究走到x,y这个点之前的一步   
initialize: 起点    answer: 终点

给定以下3*5的矩阵 [1, 5, 7, 6, 8][4, 7, 4, 4, 9][9, 3, 2, 3, 2]求一个从左上角(0, 0)到右下角的路径, 每一步只能向下或者向右走一步, 使得路径上的格子里数字最小, 则路径内所有数字之和最小为? 22
使路径上数字最小的路径是(0,0)->(1,0)->(1,1)->(2,1)->(2,2)->(2,3)->(2,4), 总和为1+4+7+3+2+3+2为15, 其他所有路径的总和均大于这个路径

Lintcode 110.[Minimum Path Sum](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Minimum%20Path%20Sum.py)
给定m行n列的网格, 每个格子(i,j)里都一个非负数A[i][j], 求一个从左上角(0,0)到右下角的路径, 每一步只能向下或者向右走一步, 使得路径上的格子里的数字之和最小, 输出最小数字和
* Soln 1: 暴力递归 TC=指数级别 O(2^n)
* Soln 2: 动态规划, 开个数组 f[i], f[i][j].. 代表状态
    state: f[x][y]从起点走到x,y的最短路径
    function: f[x][y] = min(f[x-1][y], f[x][y-1]) + A[x][y]
    intialize: f[i][0] = sum(0,0 ~ i,0), f[0][i] = sum(0,0 ~ 0,i)
    answer: f[n-1][m-1]

    - 确定状态:
        无论用何种方式到达右下角, 总有最后一步:向右 或者 向下
        右下角坐标设为(m-1,n-1), 则前一步一定是在(m-2,n-1) 或者 (m-1,n-2)  
        从(0,0)格走到(i,j)格的路径最小路径数字总和为f[i][j]
    - 转移方程: f[i][j] = min{f[i-1][j], f[i][j-1]} + A[i][j]
            左, 要求的问题(大问题, 规模大一点的); 右, 告诉你怎么求 (子问题); 子问题 -> 大问题 (转移方程)
    - 初始条件和边界情况:  
        f[0][0] = A[0][0]  (初始条件, 某些f[i][j]不能由转移方程得出, 但又需要)
        i = 0 或 j = 0, 则前一步只能有一个方向过来 (不要数组越界)
    - 计算顺序: (子问题先算, 大问题后算)
        f[0][0..n-1]  f[1][0..n-1] –...
    TC=O(MN), SC=O(MN)
    
* 行滚动数组 Sliding Array by rows 
    SC=O(n)

独孤九剑 —— 破气式 初始化一个二维的动态规划时,就去初始化第0行和第0列 (自顶向下)

## 2.1. 滚动数组 Sliding Array 动态规划空间优化
f[i][j] = min{f[i-1][j], f[i][j-1]} + A[i][j]
计算第i行时, 只需要第i行和第i-1行的f; 所以, 只需要保存两行的f值: f[i][0..n-1]和f[i-1][0..n-1], 用滚动数组实现

这道题可以按照行滚动, 也可以按列滚动, 那能否同时按行按列滚动, 只开一个2*2的数组? 不可以, 若同时按行和列滚动, 无法保存足够的信息来推出最终的结果。行和列中只能滚动一维来使空间复杂度降为O(n)    
判断能不能用滚动数组, 就是看它是不是只与本行和前一行有关, 具体写的时候可以用old和now, 或者用模来写(不推荐, 取模的操作比较慢)
- f[old], f[now], now = 1 - now (0变1, 1变0)
- f[i % 2] 除2取余

这道题可以只开一行数组? **下节课讲**

LintCode 366.[Fibonacci](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Fibonacci.py)

Lintcode 114.[Unique Paths](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Unique%20Paths.py)
state: f[x][y]从起点到x,y的路径数
function: (研究倒数第一步) f[x][y] = f[x - 1][y] + f[x][y - 1]
initialize: f[0][i] = 1, f[i][0] = 1
answer: f[n-1][m-1]

Lintcode 115.[Unique Paths II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Unique%20Paths%20II.py)

Lintcode 111.[Climbing Stairs](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Climbing%20Stairs.py)
state: f[i]表示跳到第i个位置的方案总数   
function: f[i] = f[i-1] + f[i-2]
initialize: f[0] = 1
answer: f[n] // index from 0\~n

Lintcode 116.[Jump Game](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Jump%20Game.py)
Lintcode 117.[Jump Game II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Jump%20Game%20II.py)
这2个题最优的方法是使用“贪心法”, 动态规划复杂度较高 (Greedy题目间相似性小, 可复用性太差)

# 3. 接龙型动态规划 
属于“坐标型”动态规划的一种, 一维的坐标型
接龙规则 -> 求出long最长多长

Lintcode 76.[Longest Increasing Subsequence](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Longest%20Increasing%20Subsequence.py)
Given a sequence of integers, find the longest increasing subsequence (LIS 递增序列)
将n个数看做n个木桩, 目的是从某个木桩出发, 从前向后, 从低往高, 看最多能踩多少个木桩 
- state: f[i]表示(从任意某个木桩)跳到第i个木桩, 最多踩过多少根木桩 (LIS是多少)
    f[i] · 以第i位置结尾的最长LIS?  ✔️ (坐标型也是这样)
         · 前i个数里的LIS?
- function: f[i] = max{f[j] + 1}, j必须满足 j < i && nums[j] < nums[i]
- initialize: f[0..n-1] = 1     --> 每个位置都可以作为起点
- answer: max{f[0..n-1]}        --> for循环所有位置
e.g. [5, 4, 1, 2, 3] 对应一种subsequence的方案[0, 0, 1, 1, 1]  共2^n种方案, 可以用二进制对应方案 (可以用二进制的方法)

Lintcode 602.[Russian Doll Envelopes](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Russian%20Doll%20Envelopes.py) LIS+排序  3维  没懂bisect那个。。

Lintcode 603.[Largest Divisible Subset](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Largest%20Divisible%20Subset.py) 
先排序; 之前的接龙条件是小于关系, 现在的接龙条件是倍数关系

动态规划只能记录一种最优的方案, 动规无法记录所有的最优方案, 为什么? 可以记录状态最优值是从哪里来的

Lintcode 622.[Frog Jump](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Frog%20Jump.py)

# 4. 划分型动态规划 Partition DP
给定长度为N的序列或字符串, 按照某种要求划分成若干段 
    段数不限, 或指定K段
    每一段满足一定的性质

LintCode 512.[Decode Ways](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Decode%20Ways.py)
有一段由A-Z组成的字母串信息被加密成数字串, 加密方式为 A=1, B=2 .. Z=26, 给定加密后的数字串S[0...N-1], 问有多少种方式解密成字母串
输入 12 输出 2(AB或者L)
- 确定状态: f[i] 前i个数字
    最后一步: (最后一个数字 or 最后两个数字) 一定有最后一个字母, A, B, ..., 或Z
    这个字母加密时变成1, 2, ..., 或26
    需要知道数字串前N-1和N-2个字符的解密方式数
- (有条件的)转移方程: 最后一个数字代表一个字母(i.e. 不是0) + 最后两个数字可以解密为一个字母 (10~26)
    f[i] = f[i-1] | S[i-1]对应一个字母 + f[i-2] | S[i-2]S[i-1]对应一个字母
- 初始条件和边界情况:
    f[0] = 1, 即空串有1种方式解密, 空串解密成空串
    i = 1, 只看最后一个数字
- 计算顺序: f[0], f[1], ..., f[n]
- TC=O(N), SC=O(N), 滚动数组可以优化SC=O(1)

LintCode 676.[Decode Ways II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Decode%20Ways%20II.py)
有一段由A-Z组成的字母串信息被加密成数字串, 加密方式为: A=1, B=2 .. Z=26
给定加密后的数字串S[0...N-1], 问有多少种方式解密成字母串? 其中可能出现*字符, 可以被替换成为1~9中的任何一个字符
输入:1*  输出:18(11~19各有两种方式)

- 确定状态: 和Decode Ways基本相同, 需要知道数字串前N-1和N-2个字符的解密方式数
    - 情况一: 最后一个字符翻译成字母 S[i-1]
        - S[i-1] ='0' 不能翻译成字母
        - S[i-1] ∈ {'1', ..., '9'} 1种方式翻译成一个字母, 共f[i-1]种方式 
        - S[i-1] = '*' 9种可能翻译成一个字母, 共 9 * f[i-1]种方式
    - 情况二:最后两个字符翻译成字母 S[i-2]S[i-1]
        - S[i-2] = '0' 不能翻译成字母
        - S[i-2] = '1'
            S[i-1] ∈ {'0', ..., '9'} 1种可能翻译成一个字母, 共f[i-2]种方式
            S[i-1] = '*' 9种可能翻译成一个字母, 共 9 * f[i-2]种方式
        - S[i-2] = '2'
            S[i-1] ∈ {'0', ..., '6'} 1种可能翻译成一个字母, 共f[i-2]种方式
            S[i-1] ∈ {'7', ..., '9'} 不能翻译成字母
            S[i-1] = '*' 6种可能翻译成一个字母, 共 6 * f[i-2]种方式
        - S[i-2] ∈ {'3', ..., '9'} 不能翻译成字母
        - S[i-2] = '*'
            S[i-1] ∈ {'0', ..., '6'} 2种可能翻译成一个字母, 共 2 * f[i-2]种方式
            S[i-1] ∈ {'7', ..., '9'} 1种可能翻译成一个字母, 共 f[i-2]种方式
            S[i-1] = '*' 15种可能翻译成一个字母, 共 15 * f[i-2]种方式

虽然题目中要求对结果取模, 但为什么要在中间就取模呢? 其一, 如果中间不取模, 可能在过程中就会爆long的范围(比如字符串是100个*), 其二, 即使在中间取模, 也不会导致结果发生变化

正序求解 vs 倒序求解
我们现在说的是一种bottom-up的方式, 每个大问题用子问题去求解, 保证每次要用到的子问题都已经先被计算过了, 也叫递推(recurrence)
还有一种叫记忆化搜索(memorization), 就是递归得求答案, 并把算过的内容存在数组里, 因为他是从上往下算的, 这是一种top-down的方式
一般来说动态规划题两种都可以用, 但是有些时候某一种写法能比另一种写法简单很多, 所以两种写法都要掌握。

动态规划题的四个步骤: 确定状态, 转移方程, 初始条件, 边界情况, 计算顺序, 用最后一步和子问题确定状态

# 5. 博弈类动态规划 Game DP
博弈为两方游戏, 一方先下, 在一定规则下依次出招; 如果满足一定条件, 则一方胜
目标: 取胜
先手: 先出招的一方 (=当前局面要出招的人)
出招后, 先手换人, 新的先手面对一个新的局面

现在有一堆石子, A和B每人可以从中取出1个或者2个石子, A先取, 取完最后一颗石子的人获胜. 假设现在这堆石子中共有8个石子, 且A与B足够聪明, 那么谁将获胜? A会获胜   A只需先取2个石子, 不管B取多少个, A都可以将剩下的石子个数取至3的倍数, 直到取完

LintCode 394.[Coins in a line](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Coins%20in%20a%20line.py)
有一排N个石子, Alice, Bob两人轮流取石子, 每次一个人可以从最右边取走1个或2个石子, 取走最后石子的人胜
问先手Alice是否必胜 (先手必胜: true, 先手必败: false)
输入: N=5 输出: true (先手取走2个石子, 剩下3个石子, 无论后手怎么拿, 先手都可以 取走最后一个石子)

面对N个石子, 先手Alice第一步可以拿1个或2个石子, 这样后手Bob就面对N-1个石子或N-2个石子
先手Alice一定会选择能让自己赢的一步  因为双方都是采取最优策略
怎么选择让自己赢的一步? 就是走了这一步之后, 对手面对剩下的石子, 他必输  (循环定义?????)

博弈动态规划:必胜 vs 必败
(图)  TODO
如果取1个或2个石子后, 能让剩下的局面先手必败, 则当前先手必胜
如果不管怎么走, 剩下的局面都是先手必胜, 则当前先手必败
宗旨--必胜和必败状态
    必胜: 在当下的局面走出一步,  让对手无路可逃
    必败: 自己无路可逃      3的倍数石子 -> 必败

- 状态: 设f[i]表示面对i个石子, 是否先手必胜 (f[i] = TRUE / FALSE)
- 转移方程: f[i] = f[i-1] == FALSE OR f[i-2] == FALSE
- 初始条件和边界情况:
    f[0] = FALSE            面对0个石子, 先手必败
    f[1] = f[2] = TRUE      面对1个石子或2个石子, 先手必胜
- 计算顺序: 从小到大 f[0], f[1], f[2], ..., f[N]
- 如果f[N] = TRUE则先手必胜, 否则先手必败
TC=O(N), SC=O(N), 可以滚动数组优化至O(1)  (f[i]只和f[i-1], f[i-2]有关)

LintCode 395.[Coins in a Line II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Coins%20in%20a%20Line%20II.py)
给定一个序列a[0], a[1], ..., a[N-1], 两个玩家Alice和Bob轮流取数, 每个人每次只能从左边取1或2个数
双方都用最优策略, 使得自己的数字和尽量比对手大, 问先手是否必胜? 如果数字和一样, 也算先手胜
输入:[1, 2, 2] 输出: True

这题是一道博弈题, 目标是让自己拿到的数字之和不比对手小
设己方数字和是A, 对手数字和是B, 即目标是A>=B, 等价于A-B>=0。即如果 SA=A-B, SB=B-A, Alice的目标是最大化SA, Bob的目标是最大化SB
当一方X面对剩下的数字, 可以认为X就是当前的先手, 他的目标就是最大化 SX=X-Y
当他这一步取走数字的和为m后, 对手Y变成先手, 同理他也要最大化 SY=Y-X
对于X来说, SX = -SY + m
    Explanation: SY = Y' - X', SX = X - Y = (m + X') - Y' = m + X' - Y' = m - (Y' - X') = m - SY    
    m是当前这步的数字(这一步的得分), -SY是对手看来的数字差取相反数 (因为先手是X)

- 状态: 设f[i]为一方在面对a[i..n-1]这些数字时, 能得到的最大的与对手的数字差 
- 转移方程: 两种情况
    f[i] = max{a[i] - f[i+1], a[i] + a[i+1] - f[i+2]}
- 初始条件: f[n] = 0   (面对空数组时, 得分为0)
- 计算顺序: f[n], f[n-1], ..., f[0]
- 如果f[0]>=0, 先手Alice必赢, 否则必输
TC=O(N), SC=O(N), 可以滚动数组优化至O(1)

# 6. 区间类 Interval DP
特点: 1. 求一段区间的解max/min/count 2. 转移方程通过区间更新 3. 大区间的值依赖于小区间

给数组[4, 1, 5, 10], 每次可以拿走其中的一个元素, 然后得到这个元素两边的元素以及它本身的乘积的分数, 那么最多能获得多少分? 假定两端都有一个1, 也就是说, 如果第一个拿走4, 会得到1 * 4 * 1=4分 
最优策略是先拿走1, 得到20分, 剩下[4, 5, 10]; 然后拿走5, 得到200分, 剩下[4, 10]; 然后拿走4, 得到40分, 剩下[10]; 最终拿走10得到10分, 共计20+200+40+10=270分

LintCode 168.[Burst Ballons](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Burst%20Ballons.py) 消去型(东西越来越少) 不要顺着题意想, 逆着想!
给定N个气球, 每个气球上都标有一个数字: a1, a2, ..aN, 要求扎破所有气球, 扎破第i个气球可以获得a[left] * a[i] * a[right]枚金币, left和right是与i相邻的下标, 扎破气球i以后, left和right就变成相邻的气球, 求最多获得的金币数 (设a[0]=a[N+1]=1)
输入: [3, 1, 5, 8] 输出: 167
[3,1,5,8] -> [3,5,8] -> [3,8] -> [8] -> [] 金币3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167
先首尾各加1

- 确定状态:
    最后一步: 一定有最后一个被扎破的气球, 编号是i; 扎破i时, 左边是气球0, 右边是气球N+1, 获得金币1 × a[i] × 1 = a[i]
    此时气球 1 ~ i-1 以及 i+1 ~ N 都已经被扎破, 并且已经获得对应金币 --> 子问题  
- 状态: 设f[i][j]为扎破 i+1 ~ j-1 号气球, 最多获得的金币数 (i, j为不能扎破的气球, 扎完i~j之间的气球得分f[i][j])
- 转移方程: f[i][j] = max i < k < j {f[i][k] + f[k][j] + a[i] * a[k] * a[j]}   (a[k]: 最后扎破的气球)
- 初始条件和边界情况: f[0][1] = f[1][2] = ... = f[N][N+1] = 0  相邻气球间无法扎破 f=0
- 计算顺序: 枚举顺序 (长度由小到大 1 ~ N, 固定长度从左到右)
    f[0][1], f[1][2], f[2][3], .. f[N][N+1]
    f[0][2], f[1][3], f[2][4], .. f[N-1][N+1] 
    ...
    f[0][N+1]
    ```python
    for interval in range(1, len(nums)):
        for i in range(0, len(nums) - interval):
            j = i + interval
            dp[i][j] = ...
    ```
时间复杂度O(N3), 空间复杂度O(N2)

LintCode 396.[Coins in a Line III](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Coins%20in%20a%20Line%20III.py) 区间 + 博弈型    no permission....
给定一个序列a[0], a[1], ..., a[N-1], 两个玩家Alice和Bob轮流取数, 每个人每次只能取第一个数或最后一个数, 双方都用最优策略, 使得自己的数字和尽量比对手大, 问先手是否必胜? 如果数字和一样, 也算先手胜
输入: [1, 5, 233, 7] 输出: True (先手取走1, 无论后手取哪个, 先手都能取走233)

博弈
和Coins in a Line II类似, 目标是让自己拿到的数字之和不比对手小
设己方数字和是A, 对手数字和是B, 即目标是A>=B, 等价于A-B>=0
也就是说, 如果Alice和Bob都存着自己的数字和与对手的数字和之差, 分别记为 SA=A-B, SB=B-A
则Alice的目标是最大化SA, Bob的目标是最大化SB  

- 状态: 设f[i][j]为一方先手在面对a[i..j]这些数字时, 能得到的最大的与对手的 数字差 --> 区间型动态规划
- 转移方程: 取头, 剩下数字 i+1 ~ j + 取尾, 剩下数字 i ~ j-1
    f[i][j] = max{a[i] - f[i+1][j], a[j] - f[i][j-1]}
- 初始条件: f[i][i] = a[i]  (面对一个数字 -> 拿走!)
- 计算顺序:
    长度1 f[0][0], f[1][1], f[2][2], ..., f[N-1][N-1]  
    长度2 f[0][1], ..., f[N-2][N-1]
    长度N f[0][N-1]
- 如果f[0][N-1]>=0, 先手Alice必赢, 否则必输
- 时间复杂度O(N2), 空间复杂度O(N2), 也可以用记忆化搜索; 也可以滚动数组, 滚动方向为对角线, 从左下到右上 (但定义比较麻烦)

区间DP总结 
* 最后都是求 0~n-1 这段区间的值
* 逆向思维: 考虑最后一步如何做, 而不考虑第一步如何做 (消去型: 最后一步; 最后一个被消去的blahblah..)

题目: 矩阵链乘法  a * b * c.... 怎么加括号使计算代价最小?

# 7. 双序列型动态规划
两个序列/字符串的最优值/方案数/可行性 
可以使用滚动数组优化空间

字符串
子串 substring: 字符串中的一段连续的字符 (continuous)
子序列 subsequence: 所有子串一定是子序列, 但子序列不一定是子串, 且子序列不能改变字符串的相对顺序 (not continuous)

假定空串不算子序列也不算子串, 那么一个长度为N的字符串最多有多少个不同的子序列和子串?
子序列, 类似数学里的子集, 有n个元素的集合, 那么子集个数就是2^n, 空串不是子序列, 因此2^N-1个子序列
子串, 以第一个字符开头的子串个数有n个, 第二个字符有n-1个.. 第n个字符有1个, 因此总数(N+1)*N/2个子串, 空串不是一个字符串的子串, 因此不需要加一

LintCode 77.[Longest Common Subsequence](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Longest%20Common%20Subsequence.py)
给定两个字符串A, B, 一个字符串的子序列是这个字符串去掉某些字符(可能0个)之后剩下的字符串, 找到两个字符串的最长公共子序列的长度 (不需要连续)
输入: A="jiuzhang", B="lijiang" 输出: 5(最长公共子序列是jiang)

- 确定状态:
    对子连相同的字符, 最长公共子序列=最多对子个数 (每个字符最多只连一个对子 + 对子不交叉)
    最后一步: 观察A[m-1]和B[n-1]这两个字符是否作为一个对子在最优策略中
        情况1 A尾巴不要,     ------------------------------------->>  A前m-1个字符 和 B前n个字符
        情况2 B尾巴不要,     ------------------------------------->>  A前m个字符 和 B前n-1个字符
        情况3 AB尾巴都要, 且A[m]==B[n], 两个字符正好连一个对子    ---->>  A前m-1个字符 和 B前n-1个字符
        AB尾巴都不要包含在情况1&2中了
    状态: 设f[i][j]为A前i个字符A[0..i-1]和B前j个字符[0..j-1]的最长公共子序列的长度
- 转移方程: f[i][j] = max{f[i-1][j], f[i][j-1], f[i-1][j-1]+1 | A[i-1]=B[j-1]}
- 初始条件和边界情况: f[0][j]=0 (j=0..n) f[i][0]=0 (i=0..m)  空串和另一个字符串的最长公共子序列=0
- 计算顺序: f[0][0..n] ... f[m][0..n]
- 答案是f[m][n]
TC=O(MN), SC=O(MN), 可以用滚动数组优化空间至O(N)  (f[i][j]只与 f[i-1][j]和f[i][j-1]有关)

LintCode 119.[Edit Distance](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Edit%20Distance.py)
给定两个字符串A, B, 要求把A变成B, 每次可以进行下面一种操作: 增加一个字符; 去掉一个字符; 替换一个字符. 最少需要多少次操作, 即最小编辑距离
输入: A="mart", B="karma" 输出: 3 (m换成k, t换成m, 加上a)
* Soln 1: 搜索
* Soln 2: 动态规划 题目复杂, 先梳理顺序 -> 从左改起?
    1. 增加B[j]在A[i]后 -----> A[i]和B[j-1]   操作+1
    2. 替换A[i]->B[j] ------> A[i-1]和B[j-1] 操作+1
    3. 删除A[i] ------------> A[i-1]和B[j]   操作+1
    4. A[i] == B[j] 尾巴相等                 操作+0
    问题缩小了 (要么A缩小, 要么B缩小, 要么AB一起缩小)
    - 确定状态:
    最后一步: 观察B[n-1]是如何产生的(插入, 删除, 替换, 和A[m-1]匹配)  
    状态: 设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]的最小编辑距离
    - 转移方程: 插入 + 替换 + 删除
        f[i][j] = min{f[i][j-1]+1, f[i-1][j-1]+1, f[i-1][j]+1, f[i-1][j-1]|A[i-1]=B[j-1]}
    - 初始条件和边界情况:  
        f[0][j] = j, j=0..n  空串 -> 长度为j, 插入j次
        f[i][0] = i, i=0..m  长度为i -> 空串, 删除i次
    - 计算顺序:  f[0][0..n] .. f[m][0..n]
    - 答案是f[m][n]
    TC=O(MN), SC=O(MN), 可以用滚动数组优化空间至O(N) 

LintCode 29.[Interleaving String](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Interleaving%20String.py)
给定三个字符串A, B, X, 判断X是否是由A, B交错在一起形成; 即A是X的子序列, 去掉A后, 剩下的字符组成B
输入: A="aabcc" B="dbbac", X="aadbbcbcac" 输出:True (X="aadbbcbcac")

从尾巴出发, 去掉最后一位 = A去掉尾巴 + B or B去掉尾巴 + A
f[i][j][k]: X前i个字符是否为A前j个字符和B前k个字符交错形成 (降维: 利用变量间关系找等式, i=j+k)
- 最后一步: 假设X是由A和B交错形成的, 那么X的最后一个字符X[m+n-1]要么是A[m-1], 要么是B[n-1]
- 状态: f[i][j] = X前i+j个字符是否由A前i个字符和B前j个字符交错形成
- 转移方程: f[i][j] = (f[i-1][j] AND X[i+j-1]==A[i-1]) OR (f[i][j-1] AND X[i+j-1]==B[j-1])
- 初始条件: f[0][0] = True 空串和空串可以组成空串
- 计算顺序: f[0][0], f[0][1], ..., f[0][n]     .......     f[m][0], f[m][1], ..., f[m][n]
时间复杂度(计算步数)O(MN), 空间复杂度(数组大小)O(MN), 可以用滚动数组优化空间至O(N)

LintCode 623.[K Edit Distance](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/K%20Edit%20Distance.py) n次edit distance?
给定N个字符串, 以及目标字符串T, 问哪些字符串和T的编辑距离不大于K, 一次编辑包括插入一个字符或删除一个字符或修改一个字符
输入: A = ["abc", "abd", "abcd", "adc"] target="ac" K=1     输出: ["abc", "adc"] 

如果依次用Edit Distance得到结果, 存在重复计算  
    如果给定的字符串是"abca", "abcb", "abcc"
    三个字符串的前3个字符都一样
    "abca"前0~3个字符和Target前0~n个字符的最小编辑距离  
    "abcb"前0~3个字符和Target前0~n个字符的最小编辑距离  
    "abcc"前0~3个字符和Target前0~n个字符的最小编辑距离
如何避免重复计算? 前缀一样
如果几个字符串共享一段前缀, 他们对应的f[i][j]可以共享, 即只计算一次 (同样前缀, 只计算一次)
数据结构Trie: 字典树 (解决前缀造成的冗余)

(图)  DFS -> 每层开一个数组
一个词的所有前缀就是从根到这个词的节点路径上形成的所有的字符串

- 状态: f[S_P][j]为前缀S_P(即节点P对应的字符串)和T前j个字符的最小编辑距离
设P的父亲是Q
- 转移方程: f[S_P][j] = min{f[S_P][j-1]+1,f[S_Q][j-1]+1,f[S_Q][j]+1,f[S_Q][j-1]|sP[last]=T[j-1]
- 初始条件:一个空串和一个长度为L的串的最小编辑距离是L  
    f[S_root][j] = f[""][j] = j (j = 0, 1, 2, ..., n)
    f[S_P][0] = length(S_P)
- 计算顺序
    初始化f[S_root][0]~f[S_root][n]
    按照字母树深度优先搜索顺序计算每个f[S_P][0]~f[S_P][n]  
    答案是满足f[S_P][n]<=K且sP在给定列表中的所有单词  
    用DFS实现 (DFS字典树)
    时间复杂度(计算步数)O(前缀个数 * N), 空间复杂度(数组大小)O(前缀个数 + 最长单词长度*N)


给定两个字符串A和B, 问A的所有子序列中B出现了多少次? 枚举法, 枚举A所有的子序列(复杂度O(2^N), 效率很低); 动态规划 
    f[i][j]表示A的前i个字符的子序列中B的前j个字符的子串出现的次数 (选择这个)
    f[i][j]表示A的以i结尾的子序列中B的前j个字符的子串出现的次数 (复杂~)

# 8. 背包型DP backpack
LintCode 92.[BackPack]()
http://www.lintcode.com/problem/backpack/
给定N个物品, 重量分别为正整数A0, A1, ..., AN-1, 一个背包最大承重是正整数M, 最多能带走多重的物品
输入: 4个物品, 重量为2, 3, 5, 7 背包最大承重是11    输出:10 (三个物品:2, 3, 5)

每个装物品的方案的总重量都是0到M, 如果对于每个总重量, 我们能知道有没 有方案能做到, 就可以解决
背包问题中, 数组大小和总承重有关
最后一步: 最后一个物品(重量AN-1)是否进入背包
状态: 设f[i][w] = 能否用前i个物品拼出重量w (TRUE / FALSE)
常见误区: 错误 设f[i]表示前i个物品能拼出的最大重量(不超过M)  反例:A=[3 9 5 2], M=10
错误原因: 最优策略中, 前N-1个物品拼出的不一定是不超过M的最大重量

转移方程:f[i][w] = f[i-1][w] OR f[i-1][w-Ai-1]
初始条件和边界情况:
 f[0][0] = TRUE: 0个物品可以拼出重量0
 f[0][1..M] = FALSE: 0个物品不能拼出大于0的重量  f[i-1][w-Ai-1]只能在w≥Ai-1时使用
计算顺序:  f[0][0..m]
–...
 f[n][0..m]
答案是最大的j使得f[n][j]=True
时间复杂度:O(MN), 空间复杂度:O(MN), 可以用滚动数组优化空间至O(N) 

BackPack 马甲题型 把一个[1,24,5,6]数组尽量平分。

LintCode 125.[Backpack II]()
http://www.lintcode.com/problem/backpack-ii/
给定N个物品, 重量分别为正整数A0, A1, ..., AN-1, 价值分别为正整数V0, V1, ..., VN-1
一个背包最大承重是正整数M
最多能带走多大价值的物品
输入:4个物品, 重量为2, 3, 5, 7, 价值为1, 5, 2, 4. 背包最大承重是11
输出:9 (物品一+物品三, 重量3+7=10, 价值5+4=9)

每个装物品的方案的总重量都是0到M, 如果对于每个总重量, 我们能知道对应 的最大价值是多少, 就能知道答案
背包问题中, 数组大小和总承重有关
最后一步:最后一个物品(重量AN-1, 价值VN-1)是否进入背包
状态:设f[i][w] = 用前i个物品拼出重量w时最大总价值 (-1表示不能拼出w)

转移方程:f[i][w] = max{f[i-1][w], f[i-1][w-Ai-1] + Vi-1 | w≥Ai-1 且f[i-1][w-Ai-1] ≠-1}
初始条件和边界情况:
 f[0][0] = 0: 0个物品可以拼出重量0, 最大总价值是0
 f[0][1..M] = -1: 0个物品不能拼出大于0的重量
 f[i-1][w-Ai-1]只能在w≥Ai-1, 并且f[i-1][w-Ai-1] ≠-1时使用
计算顺序:  f[0][0..m]
–...
 f[n][0..m]
答案是max0<=j<=M{f[N][j] | f[N][j] ≠-1} 

LintCode 440.[Backpack III]()
http://www.lintcode.com/problem/backpack-iii/
给定N种物品, 重量分别为正整数A0, A1, ..., AN-1, 价值分别为正整数V0, V1, ..., VN-1
每种物品都有无穷多个
一个背包最大承重是正整数M
最多能带走多大价值的物品

输入:4个物品, 重量为2, 3, 5, 7, 价值为1, 5, 2, 4. 背包最大承重是10
输出:15 (3个物品一, 重量3*3=9, 价值5*3=15)

和Backpack II唯一的不同是:每种物品都有无穷多个
状态:设f[i][w] = 用前i种物品拼出重量w时最大总价值 (-1表示不能拼出w) 转移方程:f[i][w] = maxk>=0{f[i-1][w-kAi-1] + kVi-1}
可以转化为f[i][w] = max{f[i-1][w], f[i][w-Ai-1] + Vi-1}

优化
f[i][w] = max{f[i-1][w], f[i][w-Ai-1] + Vi-1} 实际编程中可以进一步优化
w=0 1 2 3 4 5 6 7 i=0
i=1 i=2 i=3

LintCode 89.[K Sum]()
http://www.lintcode.com/problem/k-sum/
给定数组A, 包含n个互不相等的正整数
问有多少种方式从中找出K个数, 使得它们的和是Target
输入: A=[1, 2, 3, 4], K=2, Target = 5 输出:2 (1+4=5,2+3=5)

最后一步: 最后一个数An-1是否选入这K个数
状态: f[i][k][s]表示有多少种方法可以在前i个数中选出k个, 使得它们的和是s
转移方程: f[i][k][s] = f[i-1][k][s] + f[i-1][k-1][s-Ai-1]|k>=1 AND s>=Ai-1
初始条件:
 f[0][0][0] = 1
 f[0][0][s] = 0, s = 1, 2, ..., Target
计算顺序:
 f[0][0~K][0~Target] –...
 f[N][0~K][0~Target]
时间复杂度O(N*K*Target), 空间复杂度O(N*K*Target), 可以用滚动数组优化 至O(K*Target)

总结
双序列型DP问题 二维数组
最后一步考虑两个序列最后的元素 可以滚动数组优化
背包型DP问题
用背包承重作为DP维度之一
最后一步考虑最后一个物品是否进背包 可以滚动数组优化

今日重点题型
Longest Common Subsequence 双序列常考题
Edit Distance 双序列常考题
Backpack II
有价值的背包题目才有价值

## 8.1. 背包 Backpack
重要性: 动态规划中的重难点; 面试中的常考点
什么是背包问题? 背包(容量), 物品(所占空间, 价值) -> 不超过背包容量, 价值最大化
主要分类: 0-1背包(取/不取), 完全/无穷背包(所有物品无穷多个), 多重背包(物品有一定的数量)

基本思路 
* 0-1背包 knapsack
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - A[i]] + V[i])
* 完全背包: 枚举每件物品取0, 1, 2, 3 ... m / A[i] 件     
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 
* 多重背包: 枚举每件物品取0, 1, 2, 3 ... amounts[i]件  
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 

## 8.2. 0-1背包 knapsack
0-1背包三种方法
1. 0-1背包 爆搜 (物品→取/不取, n个物体 枚举2^n) 爆搜不加优化很可能TLE超时
举例: 背包容量 m = 10 物品大小 A = [2, 3, 5, 7] 物品价值 V = [1, 5, 2, 4]
爆搜解法:分别枚举每一个物体取或者不取,1代表取,0代表不取

爆搜算法的局限	TC=O(2^n)
搜索树 (略)
优化的两种思路: ??? ; 剪枝pruning
结果状态
对于前i个物体, 每个都枚举了取或者不取。在确定容量j下, 可能包含了不同的情况, 但我们只需要知道最好的价值就可以了

2. 0-1背包 贪心
取价值最高 m=2, A=[1,1,2], V=[2,2,3]				    贪心答案:3, 正确答案:4
取重量最轻 m=2, A=[1,1,2], V=[1,1,3]				    贪心答案:2, 正确答案:3
取单位价值最高(性价比最高) m=3, A=[1,1,3], V=[2,2,5]	   贪心答案:4, 正确答案:5
局限: 所有的贪心,都是错误的!!!    因为都是考虑当前最优解≠最终最优解

3. 0-1背包 动态规划实现:
背包容量 m = 10 物品大小 A = [2, 3, 5, 7] 物品价值 V = [1, 5, 2, 4]
使用数组来记录取前i个物品, 在容量j的情况下能取的最大价值
*Note: 加一行一列的0, 这样第一个物品可以当做普通物品考虑, 不需要单独处理了*

dp[i][j]表示前i个物体,在容量j的情况下, 能取到的最大价值  row=i=object, col=j=weight
当前物品(物品i)2个选择:
如果取第i个物体,价值为dp[i - 1][j - A[i]] + V[i]   (j-A[i]>0; 若<0则数组越界) 
如果不取第i个物体,价值为dp[i - 1][j]
状态转移: dp[i][j] = max(dp[i - 1][j - A[i]] + V[i], dp[i - 1][j])

空间优化: 滚动数组, 一维数组

LintCode 125. [Backpack II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Backpack%20II.py)
```python
def backPackII(self, m, A, V): # m:背包容量 A:物品大小 V:物品价值
	dp = [[0] * (m + 1) for _ in range(len(A) + 1)]
    
	for i in range(1, len(A) + 1):         # row = num of objects
		for j in range(1, m + 1):   # col = values
			if j - A[i-1] < 0:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - A[i-1]] + V[i-1])
        
	# [print(line) for line in dp]
	return dp[-1][-1]   # dp[len(A) + 1][m]

# 滚动数组优化空间至O(m)
def backPackII(self, m, A, V): # m:背包容量 A:物品大小 V:物品价值
    f = [0 for i in range(m+1)]
    for i in range(len(A)):
        for j in range(m, A[i]-1, -1):
            f[j] = max(f[j] , f[j-A[i]] + V[i])
    return f[m]
    
def backPackII(self, m, A, V): # m:背包容量 A:物品大小 V:物品价值
    dp = [[0] * (m + 1), [0] * (m + 1)]     # 滚动数组
    
    for i in range(1, len(A) + 1):  # i = index of object
        dp[i % 2][0] = 0            
        for j in range(1, m + 1):   # j = total value of objects (0...m)
            dp[i % 2][j] = dp[(i - 1) % 2][j]
            if A[i - 1] <= j:
                dp[i % 2][j] = max(dp[i % 2][j], dp[(i - 1) % 2][j - A[i - 1]] + V[i - 1])
    return dp[len(A) % 2][m]
```
LintCode 563. [Backpack V]()

LintCode 92 两种做法: 体积当做价值 A[i]=V[i] 转化为0-1背包; 装多满的问题, 给定空间x, 能否装满x
LintCode 562 无穷/完全背包 (状态转移方程..)

## 8.3. 完全背包
完全背包: 给定 n 种物品, 每种物品都有无限个。第 i 个物品的体积为A[i], 价值为V[i]。再给定一个容量为 m 的背包。问可以装入背包的最大价值是多少?

1. 基本思路
转移方程
0-1背包: dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - A[i]] + V[i])   当前物品取 vs 不取           容量j
完全背包:枚举每件物品取0, 1, 2, 3…m/A[i]件   (最多取m/A[i]件)
		dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 	不取 vs 取k个

例子分析
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 

i→k (k为最多可以取几次)

2. 完全背包转化为0-1背包: 将第i件物品最多取k个, 转化为k件 (A[i], V[i]) 的物品  (每件都当做单件物品处理)
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]
A = [2, 3, 4, 5] 最多取 4, 2, 2, 1次

LintCode 440. [..]()

在两重循环的条件下, 0-1背包的倒序枚举能解决完全背包的问题吗? 不能  (why???)

0-1背包 一维优化 (二维数组优化成一维)
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]

0-1背包可以用倒序来做; 若正序呢? (0-1背包若正序处理, 每一种物品可能被添加多次, 正好是完全背包的要求)

3. 完全背包 O(V*m) 优化
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]

三种状态: 1)不装该物品   2)第一次装该物品  3)多次添加该物品		3)一定 > 2)
@dp[1][2]  	1) 从dp[0][2]转移     2)从dp[0][2-2] = dp[0][0]转移    3)从dp[1][2-2] = dp[1][0]转移
@dp[1][2]  	1) 从dp[0][2]转移     2)从dp[0][2-2] = dp[0][0]转移    3)从dp[1][2-2] = dp[1][0]转移

LintCode 801 [...]()
LintCode 562 [...]()

## 8.4. 多重背包
多重背包: 给定 n 种物品, 每种物品都有amounts[i]个 (一定个数)。第 i 个物品的体积为 A[i], 价值为 V[i]。再给定一个容量为 m 的背包。问可以装入背包的最大价值是多少? 

1. 基本思路 
0-1 背包: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - A[i]] + V[i]) 
完全背包: 枚举每件物品取0, 1, 2, 3 ... m / A[i] 件     dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 
多重背包: 枚举每件物品取0, 1, 2, 3 ... amounts[i]件  dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 

例子分析 
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 物品数量 A = [2, 1, 2, 1] 

2.完全背包转化为 0-1 背包 
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 
将第i件物品最多取k 个, 转化为k件 (A[i], V[i])的物品 

LintCode 798. [...]()
物品 重量 	价值 	个数
	3	300	1
	2	160	6

LintCode 799. [...]()

## 8.5. 优化拓展 (空间优化)
1. 0-1 背包 滚动数组优化 & 一维数组优化
举例2: 背包容量m = 8 物品大小A = [2, 3, 4, 5] 物品价值V = [3, 4, 5, 6]

dp[i][j] = max(dp[i - 1][j  A[i]] + V[i], dp[i - 1][j]) 

①滚动数组优化 
前i个物品能取到的最优价值, 只和前i-1个物品能取到有关 (只需要前面1维)
dp[1][j] = max(dp[0][j  A[i]] + V[i], dp[0][j]) 

②一维数组优化
当前j只和上一层的j, 以及上一层的j - A[i]有关
新的状态转移方程 dp[j] = max(dp[j  A[i]] + V[i], dp[j]) (一定要倒序!!! 倒序更新, 从后往前, 覆盖不影响) 

2. 完全背包 二进制优化
m=8 A=[2, 3, 4, 5] V=[30, 50, 100, 200] 
第0个物品: A[0] = 2, V[0] = 30, 最多取4个 (0, 1, 2, 4)
第1个物品: 最多取2个 
第i个物品: 最多取x个(2^n <= x) 拆分为1, 2, 4, 8...2^n  (→看做取n个不同的物品)
类似快速幂 x^m  (1)for循环n次  (2)m/2

LintCode 1538. [...]()
LintCode 800. [...]() 物品带来的价值 *, 而不是 +
LintCode 700. [...]()
LintCode 749. [...]()

# 9. DP面试要求 & 现状:
Medium 难度往上
若使用递归, TC为指数级别
DP特点: 难, 程序短, 易错