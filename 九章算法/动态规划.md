<!-- TOC -->

- [1. 背包 Backpack](#1-%E8%83%8C%E5%8C%85-backpack)
    - [1.1. -1背包 knapsack](#11--1%E8%83%8C%E5%8C%85-knapsack)
    - [1.2. 完全背包](#12-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85)
    - [1.3. 多重背包](#13-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85)
    - [1.4. 优化拓展 (空间优化)](#14-%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96)
- [2. 九章算法班 第9节课: 动态规划 Dynamic Programming](#2-%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E7%8F%AD-%E7%AC%AC9%E8%8A%82%E8%AF%BE-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming)
    - [2.1. 适用动态规划的三个条件 & 不适用动态规划的三个条件](#21-%E9%80%82%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6--%E4%B8%8D%E9%80%82%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6)
    - [2.2. 动态规划与递归的关系 (联系与区别)](#22-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E9%80%92%E5%BD%92%E7%9A%84%E5%85%B3%E7%B3%BB-%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB)
    - [2.3. 面试中常见的动态规划类型 (按照状态定义方式划分)](#23-%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B1%BB%E5%9E%8B-%E6%8C%89%E7%85%A7%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86)
    - [2.4. 坐标型动态规划](#24-%E5%9D%90%E6%A0%87%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
    - [2.5. 接龙型动态规划](#25-%E6%8E%A5%E9%BE%99%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
- [3. 九章算法提高班 5, 6 讲](#3-%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E7%8F%AD-5-6-%E8%AE%B2)
- [4. 第五讲 滚动数组, 划分, 博弈与区间型](#4-%E7%AC%AC%E4%BA%94%E8%AE%B2-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84-%E5%88%92%E5%88%86-%E5%8D%9A%E5%BC%88%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9E%8B)
    - [4.1. 划分型动态规划 常见动态规划类型](#41-%E5%88%92%E5%88%86%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%B8%B8%E8%A7%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B1%BB%E5%9E%8B)
    - [4.2. 博弈类动态规划 Game DP](#42-%E5%8D%9A%E5%BC%88%E7%B1%BB%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-game-dp)
    - [4.3. 区间类DP Interval](#43-%E5%8C%BA%E9%97%B4%E7%B1%BBdp-interval)
- [5. 第六讲 动态规划(下) - 双序列与背包](#5-%E7%AC%AC%E5%85%AD%E8%AE%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8B---%E5%8F%8C%E5%BA%8F%E5%88%97%E4%B8%8E%E8%83%8C%E5%8C%85)
    - [5.1. 双序列型动态规划](#51-%E5%8F%8C%E5%BA%8F%E5%88%97%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
    - [5.2. 背包型DP](#52-%E8%83%8C%E5%8C%85%E5%9E%8Bdp)

<!-- /TOC -->

This note includes:
- 九章算法班v4.2第九章 动态规划
- 九章算法提高班(2019) Chapter 5 & 6
- 九章算法背包四讲
- 九章算法强化班(旧) Chapter 5 & 6
- 九章算法动态规划班 Chapter 1~7

---

最优解/方式数 -> DP
所有解 -> Recursion, DFS

1.计数 (有多少种方式、方法) how many ways   (也有可能是贪心, greedy algorithm)
2.求最值 (最大数字和, 最大上升子序列长度)
3.求存在性 (是或否, 博弈游戏, 谁获胜, 能不能? 存不存在策略?) 输出True/False 

Lintcode 669: Coin Change

# 1. 背包 Backpack
重要性: 动态规划中的重难点; 面试中的常考点
什么是背包问题? 背包(容量), 物品(所占空间, 价值) -> 不超过背包容量, 价值最大化
主要分类: 0-1背包(取/不取), 完全/无穷背包(所有物品无穷多个), 多重背包(物品有一定的数量)

基本思路 
* 0-1背包 knapsack
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - A[i]] + V[i])
* 完全背包: 枚举每件物品取0, 1, 2, 3 ... m / A[i] 件     
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 
* 多重背包: 枚举每件物品取0, 1, 2, 3 ... amounts[i]件  
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 

## 1.1. -1背包 knapsack
0-1背包三种方法
1. 0-1背包 爆搜 (物品→取/不取, n个物体 枚举2^n) 爆搜不加优化很可能TLE超时
举例: 背包容量 m = 10 物品大小 A = [2, 3, 5, 7] 物品价值 V = [1, 5, 2, 4]
爆搜解法:分别枚举每一个物体取或者不取,1代表取,0代表不取

爆搜算法的局限	TC=O(2^n)
搜索树 (略)
优化的两种思路: ??? ; 剪枝pruning
结果状态
对于前i个物体, 每个都枚举了取或者不取。在确定容量j下, 可能包含了不同的情况, 但我们只需要知道最好的价值就可以了

2. 0-1背包 贪心
取价值最高 m=2, A=[1,1,2], V=[2,2,3]				    贪心答案:3, 正确答案:4
取重量最轻 m=2, A=[1,1,2], V=[1,1,3]				    贪心答案:2, 正确答案:3
取单位价值最高(性价比最高) m=3, A=[1,1,3], V=[2,2,5]	   贪心答案:4, 正确答案:5
局限: 所有的贪心,都是错误的!!!    因为都是考虑当前最优解≠最终最优解

3. 0-1背包 动态规划实现:
背包容量 m = 10 物品大小 A = [2, 3, 5, 7] 物品价值 V = [1, 5, 2, 4]
使用数组来记录取前i个物品, 在容量j的情况下能取的最大价值
*Note: 加一行一列的0, 这样第一个物品可以当做普通物品考虑, 不需要单独处理了*

dp[i][j]表示前i个物体,在容量j的情况下, 能取到的最大价值  row=i=object, col=j=weight
当前物品(物品i)2个选择:
如果取第i个物体,价值为dp[i - 1][j - A[i]] + V[i]   (j-A[i]>0; 若<0则数组越界) 
如果不取第i个物体,价值为dp[i - 1][j]
状态转移: dp[i][j] = max(dp[i - 1][j - A[i]] + V[i], dp[i - 1][j])

空间优化: 滚动数组, 一维数组

LintCode 125. [Backpack II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Backpack%20II.py)
```python
def backPackII(self, m, A, V): # m:背包容量 A:物品大小 V:物品价值
	dp = [[0] * (m + 1) for _ in range(len(A) + 1)]
    
	for i in range(1, len(A) + 1):         # row = num of objects
		for j in range(1, m + 1):   # col = values
			if j - A[i-1] < 0:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - A[i-1]] + V[i-1])
        
	# [print(line) for line in dp]
	return dp[-1][-1]   # dp[len(A) + 1][m]

# 滚动数组优化空间至O(m)
def backPackII(self, m, A, V): # m:背包容量 A:物品大小 V:物品价值
    f = [0 for i in range(m+1)]
    for i in range(len(A)):
        for j in range(m, A[i]-1, -1):
            f[j] = max(f[j] , f[j-A[i]] + V[i])
    return f[m]
    
def backPackII(self, m, A, V): # m:背包容量 A:物品大小 V:物品价值
    dp = [[0] * (m + 1), [0] * (m + 1)]     # 滚动数组
    
    for i in range(1, len(A) + 1):  # i = index of object
        dp[i % 2][0] = 0            
        for j in range(1, m + 1):   # j = total value of objects (0...m)
            dp[i % 2][j] = dp[(i - 1) % 2][j]
            if A[i - 1] <= j:
                dp[i % 2][j] = max(dp[i % 2][j], dp[(i - 1) % 2][j - A[i - 1]] + V[i - 1])
    return dp[len(A) % 2][m]
```
LintCode 563. [Backpack V]()

LintCode 92 两种做法: 体积当做价值 A[i]=V[i] 转化为0-1背包; 装多满的问题, 给定空间x, 能否装满x
LintCode 562 无穷/完全背包 (状态转移方程..)

## 1.2. 完全背包
完全背包: 给定 n 种物品, 每种物品都有无限个。第 i 个物品的体积为A[i], 价值为V[i]。再给定一个容量为 m 的背包。问可以装入背包的最大价值是多少?

1. 基本思路
转移方程
0-1背包: dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - A[i]] + V[i])   当前物品取 vs 不取           容量j
完全背包:枚举每件物品取0, 1, 2, 3…m/A[i]件   (最多取m/A[i]件)
		dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 	不取 vs 取k个

例子分析
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 

i→k (k为最多可以取几次)

2. 完全背包转化为0-1背包: 将第i件物品最多取k个, 转化为k件 (A[i], V[i]) 的物品  (每件都当做单件物品处理)
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]
A = [2, 3, 4, 5] 最多取 4, 2, 2, 1次

LintCode 440. [..]()

在两重循环的条件下, 0-1背包的倒序枚举能解决完全背包的问题吗? 不能  (why???)

0-1背包 一维优化 (二维数组优化成一维)
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]

0-1背包可以用倒序来做; 若正序呢? (0-1背包若正序处理, 每一种物品可能被添加多次, 正好是完全背包的要求)

3. 完全背包 O(V*m) 优化
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]

三种状态: 1)不装该物品   2)第一次装该物品  3)多次添加该物品		3)一定 > 2)
@dp[1][2]  	1) 从dp[0][2]转移     2)从dp[0][2-2] = dp[0][0]转移    3)从dp[1][2-2] = dp[1][0]转移
@dp[1][2]  	1) 从dp[0][2]转移     2)从dp[0][2-2] = dp[0][0]转移    3)从dp[1][2-2] = dp[1][0]转移

LintCode 801 [...]()
LintCode 562 [...]()

## 1.3. 多重背包
多重背包: 给定 n 种物品, 每种物品都有amounts[i]个 (一定个数)。第 i 个物品的体积为 A[i], 价值为 V[i]。再给定一个容量为 m 的背包。问可以装入背包的最大价值是多少? 

1. 基本思路 
0-1 背包: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - A[i]] + V[i]) 
完全背包: 枚举每件物品取0, 1, 2, 3 ... m / A[i] 件     dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 
多重背包: 枚举每件物品取0, 1, 2, 3 ... amounts[i]件  dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 

例子分析 
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 物品数量 A = [2, 1, 2, 1] 

2.完全背包转化为 0-1 背包 
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 
将第i件物品最多取k 个, 转化为k件 (A[i], V[i])的物品 

LintCode 798. [...]()
物品 重量 	价值 	个数
	3	300	1
	2	160	6

LintCode 799. [...]()

## 1.4. 优化拓展 (空间优化)
1. 0-1 背包 滚动数组优化 & 一维数组优化
举例2: 背包容量m = 8 物品大小A = [2, 3, 4, 5] 物品价值V = [3, 4, 5, 6]

dp[i][j] = max(dp[i - 1][j – A[i]] + V[i], dp[i - 1][j]) 

①滚动数组优化 
前i个物品能取到的最优价值, 只和前i-1个物品能取到有关 (只需要前面1维)
dp[1][j] = max(dp[0][j – A[i]] + V[i], dp[0][j]) 

②一维数组优化
当前j只和上一层的j, 以及上一层的j - A[i]有关
新的状态转移方程 dp[j] = max(dp[j – A[i]] + V[i], dp[j]) (一定要倒序!!! 倒序更新, 从后往前, 覆盖不影响) 

2. 完全背包 二进制优化
m=8 A=[2, 3, 4, 5] V=[30, 50, 100, 200] 
第0个物品: A[0] = 2, V[0] = 30, 最多取4个 (0, 1, 2, 4)
第1个物品: 最多取2个 
第i个物品: 最多取x个(2^n <= x) 拆分为1, 2, 4, 8...2^n  (→看做取n个不同的物品)
类似快速幂 x^m  (1)for循环n次  (2)m/2

LintCode 1538. [...]()
LintCode 800. [...]() 物品带来的价值 *, 而不是 +
LintCode 700. [...]()
LintCode 749. [...]()


# 2. 九章算法班 第9节课: 动态规划 Dynamic Programming
动态规划是一种思想 (类比 Divide Conquer 也是一种思想..)
OOD考察class..

Lintcode 109.[Triangle](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Triangle.py)
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
h=高度 triangle有1+2+..h=O(h^2)个节点(多项式级别), 每个节点有两个前继节点, 坐标变化规则 (x, y) -> [(x+1, y), (x+1, y+1)]
二叉树有O(2^n)个节点(指数级别), 二叉树上每个节点只有一个前继节点
* Soln 1: DFS-Traverse      TC=O(2^n) 慢!
    递归: 1 -> 2 -> 4 -> 8 .. 所以为2^n
    ``` python
    def minimumTotal1(self, triangle):  # (TLE)
        best = self.traverse(0, 0, 0, triangle, float('inf'))
        return best     # best is the answer
        
    def traverse(self, x, y, pathsum, triangle, best):
        if x == len(triangle): # found a whole path from top to bottom
            if pathsum < best:
                return pathsum
        return min(self.traverse(x + 1, y, pathsum + triangle[x][y], triangle, best), self.traverse(x + 1, y + 1, pathsum + triangle[x][y], triangle, best))
    ```
* Soln 2: DFS-Divide Conquer        TC=O(2^n)
    DFS=枚举, 找出所有路径/所有方案  -> n层=2^n条路径
    ``` python
    def minimumTotal2(self, triangle): # (TLE)
        return self.dc(0, 0, triangle) # 从(0, 0)出发走到最底层
        
    def dc(self, x, y, triangle):
        if x == len(triangle):    # None节点, 0..n-1层才有值
            return 0    # if x == len(triangle) - 1: return triangle[x][y] #也可
        return triangle[x][y] + min(self.dc(x + 1, y, triangle), self.dc(x + 1, y + 1, triangle)) # 左右两个节点中的最小值
    ```
* Soln 3: DFS-Divide Conquer + Memorization 避免重复计算表, 把做过的事情&得到的结果 存起来
    TC=O(n^2) SC=O(n^2)
    = DC中, (x, y)不同的组合有多少个 = 参数的组合形式/状态 = O(n^2)种状态 * O(1)每个状态的tc 
    ```python
    def minimumTotal(self, triangle):
        return self.dc_memo(0, 0, triangle, {})

    def dc_memo(self, x, y, triangle, memo): # return minimum path from (x, y) to bottom
        if x == len(triangle): # row index from 0 to n-1 
            return 0
            
        # if already got the minimum path from (x, y) to bottom; just return
        if (x, y) in memo:
            return memo[(x, y)]
            
        # set before return
        memo[(x, y)] = triangle[x][y] + min(self.dc_memo(x + 1, y, triangle, memo), self.dc_memo(x + 1, y + 1, triangle, memo))
        return memo[(x, y)]
    ```
* **记忆化搜索 = 动态规划的实质** Traditional Dynamic Programming
    动态规划为什么会快? 避免重复的中间结果计算, 2^n -> n^2
    动态规划与分治的区别? 动态规划(左边也可能到右边); 分治(左边就是左边, 右边就是右边)
    - 多重循环(推荐) vs 记忆化搜索
        - 多重循环优点: 正规, 大多数面试官可以接受, 存在空间优化可能性    缺点: 思考有难度  
        - 记忆化搜索优点: 容易从搜索算法直接转化过来。有时候可以节省时间    缺点: 递归
    - 自底向上 vs 自顶向下(推荐)

* Soln 4: Dynamic Programming 多重循环 自底向上 Bottom-Up
    TC=O(n^2)
    ```python
    def minimumTotal(self, triangle): # (Iterative Bottom Up)
        f = {}      # define the state 定义状态数组 f: 从(i, j)开始走到底的最小路径长度
        for i in range(len(triangle)):      # initialization 初始化, 先有值
            f[(len(triangle) - 1, i)] = triangle[len(triangle) - 1][i]
        
        # iteration for solution 循环递推求解
        for i in reversed(range(len(triangle)-1)):
            for j in range(0, i+1):
                f[(i, j)] = triangle[i][j] + min(f[(i + 1, j)], f[(i + 1, j + 1)])
        return f[(0, 0)]  # result 求结果=起点
    ```
* Soln 5: Dynamic Programming 多重循环 自顶向下 Top-Down
    ```python
    def minimumTotal(self, triangle): # Iterative Top Down
        f = {(0, 0): triangle[0][0]}  # 初始化, 起点 f: 从(0,0)开始走到(i,j)最小路径长度
        
        # 初始化三角形的左边和右边 (左边无左上角, 右边无右上角)
        for i in range(1, len(triangle)):
            f[(i, 0)] = f[(i - 1, 0)] + triangle[i][0]
            f[(i, i)] = f[(i - 1, i - 1)] + triangle[i][i]
            
        # top Down (亦可不初始化三角形左右边, 在此加入if语句)
        for i in range(1, len(triangle)):
            for j in range(1, i):
                f[(i, j)] = triangle[i][j] + min(f[(i - 1, j)], f[(i - 1, j - 1)])
                
        return min([f[(len(triangle) - 1, j)] for j in range(len(triangle))]) # 底层最小值
    ```
    SC优化: 滚动数组  [i % 2], 这样只用两个一维数组储存f即可


## 2.1. 适用动态规划的三个条件 & 不适用动态规划的三个条件
什么情况下使用动态规划(动态规划解决的问题)? 满足下面三个条件之一, 则*极有可能*是使用动态规划求解: (最优, 可行, 方案数)
- 求最大值最小值 (但有时是DFS/BFS)
- 判断是否可行   
- 统计方案个数

什么情况下不使用动态规划?  (所有方案而不是方案数, 集合而非序列, 暴力算法已经是多项式级别复杂度)
- 求出所有*具体*的方案而非方案个数 Lintcode 136.[Palindrome Partitioning]()
- 输入数据是一个*集合*而不是*序列* (集合可以换顺序, 序列不可) Lintcode 124.[Longest Consecutive Sequence]()
- 暴力算法的复杂度已经是多项式级别: 动态规划擅长与优化指数级别复杂度(2^n, n!)到多项式级别复杂度(n^2, n^3); 不擅长优化n^3(3个循环)到n^2(2个循环)
则 极不可能 使用动态规划求解

## 2.2. 动态规划与递归的关系 (联系与区别)
动规四要素 (状态, 方程, 初始化, 答案)
* **状态 State** 灵感, 创造力, 存储小规模问题的结果
* **方程 Function** 状态之间的联系, 怎么通过小的状态, 来算大的状态 (大问题拆解成小问题)
* **初始化 Initialization** 最极限的小状态是什么, 起点
* **答案 Answer** 最大的那个状态是什么, 终点

递归三要素: (以及调用参数时传什么)
* 定义(状态) 接受什么参数; 做了什么事; 返回什么值   
* 拆解(方程) 如何将参数变小   
* 出口(初始化) 什么时候可以直接 return

## 2.3. 面试中常见的动态规划类型 (按照状态定义方式划分)
坐标型(矩阵)动态规划 10%    (f[x][y], 有坐标信息)
接龙型动态规划 20%  
划分型动态规划      匹配型动态规划      背包型动态规划      区间型动态规划      树图型动态规划  
博弈型动态规划 (游戏, 2人博弈 90%都是DP)

## 2.4. 坐标型动态规划
state: f[x]表示从起点走到坐标x...      f[x][y]表示从起点走到坐标x, y...
function: 研究走到x,y这个点之前的一步   
initialize: 起点    answer: 终点

Lintcode 110.[Minimum Path Sum](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Minimum%20Path%20Sum.py)
state: f[x][y]从起点走到x,y的最短路径
function: f[x][y] = min(f[x-1][y], f[x][y-1]) + A[x][y]
intialize: f[i][0] = sum(0,0 ~ i,0), f[0][i] = sum(0,0 ~ 0,i)
answer: f[n-1][m-1]

独孤九剑 —— 破气式 初始化一个二维的动态规划时,就去初始化第0行和第0列 (自顶向下)

Lintcode 114.[Unique Paths](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Unique%20Paths.py)
state: f[x][y]从起点到x,y的路径数
function: (研究倒数第一步) f[x][y] = f[x - 1][y] + f[x][y - 1]
initialize: f[0][i] = 1, f[i][0] = 1
answer: f[n-1][m-1]

Lintcode 115.[Unique Paths II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Unique%20Paths%20II.py)

Lintcode 111.[Climbing Stairs](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Climbing%20Stairs.py)
state: f[i]表示跳到第i个位置的方案总数   
function: f[i] = f[i-1] + f[i-2]
initialize: f[0] = 1
answer: f[n] // index from 0\~n

Lintcode 116.[Jump Game](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Jump%20Game.py)
Lintcode 117.[Jump Game II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Jump%20Game%20II.py)
这2个题最优的方法是使用“贪心法”, 动态规划复杂度较高 (Greedy题目间相似性小, 可复用性太差)

## 2.5. 接龙型动态规划 
属于“坐标型”动态规划的一种, 一维的坐标型
接龙规则 -> 求出long最长多长

Lintcode 76.[Longest Increasing Subsequence](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Longest%20Increasing%20Subsequence.py)
Given a sequence of integers, find the longest increasing subsequence (LIS 递增序列)
将n个数看做n个木桩, 目的是从某个木桩出发, 从前向后, 从低往高, 看最多能踩多少个木桩 
- state: f[i]表示(从任意某个木桩)跳到第i个木桩, 最多踩过多少根木桩 (LIS是多少)
    f[i] · 以第i位置结尾的最长LIS?  ✔️ (坐标型也是这样)
         · 前i个数里的LIS?
- function: f[i] = max{f[j] + 1}, j必须满足 j < i && nums[j] < nums[i]
- initialize: f[0..n-1] = 1     --> 每个位置都可以作为起点
- answer: max{f[0..n-1]}        --> for循环所有位置
e.g. [5, 4, 1, 2, 3] 对应一种subsequence的方案[0, 0, 1, 1, 1]  共2^n种方案, 可以用二进制对应方案 (可以用二进制的方法)

Lintcode 602.[Russian Doll Envelopes](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Russian%20Doll%20Envelopes.py) LIS+排序  3维  没懂bisect那个。。

Lintcode 603.[Largest Divisible Subset](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Largest%20Divisible%20Subset.py) 
先排序; 之前的接龙条件是小于关系, 现在的接龙条件是倍数关系

动态规划只能记录一种最优的方案, 动规无法记录所有的最优方案, 为什么? 可以记录状态最优值是从哪里来的

Lintcode 622.[Frog Jump](https://github.com/bitterengsci/algorithm/blob/master/九章算法/动态规划/Frog%20Jump.py)


# 3. 九章算法提高班 5, 6 讲

# 4. 第五讲 滚动数组, 划分, 博弈与区间型
Sliding Array & Partition, Game, Interval

Overview
滚动数组
Minimum Path Sum
划分型动态规划
Decode Ways I/II
博弈动态规划
Coin in a line I/II/III
区间型动态规划 Burst Balloons

滚动数组 - DP空间优化神器

Minimum Path Sum
http://www.lintcode.com/problem/minimum-path-sum/ http://www.jiuzhang.com/solutions/minimum-path-sum/


LintCode 110
给定m行n列的网格, 每个格子(i, j)里都一个非负数A[i][j]
求一个从左上角(0, 0)到右下角的路径, 每一步只能向下或者向右走一步 使得路径上的格子里的数字之和最小
输出最小数字和

分析
确定状态:
– 无论用何种方式到达右下角, 总有最后一步:向右 或者 向下
– 右下角坐标设为(m-1, n-1), 则前一步一定是在(m-2, n-1)或者(m-1, n-2) – 设从(0, 0)走到(i, j)的路径最小数字总和为f[i][j]
转移方程:f[i][j]=min{f[i-1][j],f[i][j-1]}+A[i][j]
初始条件和边界情况: – f[0][0] = A[0][0]
– i = 0 或 j = 0, 则前一步只能有一个方向过来 计算顺序:
– f[0][0..n-1] – f[1][0..n-1] –...
时间复杂度:O(MN) 空间复杂度:O(MN)  

动态规划四个组成部分
四个组成部分
确定状态
研究最优策略的最后一步 化为子问题
转移方程
根据子问题定义直接得到
初始条件和边界情况 细心, 考虑周全
计算顺序
 利用之前的计算结果

空间优化
f[i][j] = min{f[i-1][j], f[i][j-1]} + A[i][j]
计算第i行时, 只需要第i行和第i-1行的f

空间优化
所以, 只需要保存两行的f值:f[i][0..n-1]和f[i-1][0..n-1] 用滚动数组实现

滚动数组相关问题
Unique Paths
https://www.lintcode.com/problem/unique-paths/
Fibonacci
https://www.lintcode.com/problem/fibonacci/

## 4.1. 划分型动态规划 常见动态规划类型
给定长度为N的序列或字符串, 要求划分成若干段 段数不限, 或指定K段
每一段满足一定的性质

划分型动态规划 常见动态规划类型
给定长度为N的序列或字符串, 要求划分成若干段 段数不限, 或指定K段
每一段满足一定的性质

Decode Ways
http://www.lintcode.com/problem/decode-ways/ http://www.jiuzhang.com/solutions/decode-ways/

LintCode 512
题意:有一段由A-Z组成的字母串信息被加密成数字串
加密方式为:Aà1, Bà2, ..., Zà26
给定加密后的数字串S[0...N-1], 问有多少种方式解密成字母串
例子:
输入:12
输出:2(AB或者L)

分析
确定状态:
– 最后一步:一定有最后一个字母, A, B, ..., 或Z
– 这个字母加密时变成1, 2, ..., 或26
– 需要知道数字串前N-1和N-2个字符的解密方式数
转移方程:f[i]=f[i-1]|S[i-1]对应一个字母+f[i-2]|S[i-2]S[i-1]对应一个字母
初始条件和边界情况:
– f[0] = 1, 即空串有1种方式解密 – 如果i = 1, 只看最后一个数字
计算顺序:
– f[0], f[1], ..., f[n]
时间复杂度O(N),空间复杂度O(N)

Decode Ways II
http://www.lintcode.com/en/problem/decode-ways-ii/ http://www.jiuzhang.com/solution/decode-ways-ii/

LintCode 676
题意:有一段由A-Z组成的字母串信息被加密成数字串
加密方式为:Aà1, Bà2, ..., Zà26
给定加密后的数字串S[0...N-1], 问有多少种方式解密成字母串 其中可能出现*字符, 可以被替换成为1~9中的任何一个字符
例子:
输入:1*
输出:18(11~19各有两种方式)

分析
确定状态:
– 和Decode Ways基本相同
– 需要知道数字串前N-1和N-2个字符的解密方式数
•
情况一:最后一个字符翻译成字母
S[i-1] =‘0’ :不能翻译成字母
S[i-1] ∈{‘1’, ..., ‘9’} :1种方式翻译成一个字母, 共f[i-1]种方式 S[i-1] =‘*’ :9种可能翻译成一个字母, 共9*f[i-1]种方式


题目分析
情况二:最后两个字符翻译成字母
S[i-2] = ‘0’ :不能翻译成字母
S[i-2] = ‘1’
S[i-1] ∈{‘0’, ..., ‘9’} , 1种可能翻译成一个字母, 共f[i-2]种方式
S[i-1] = ‘*’ ,  9种可能翻译成一个字母, 共9*f[i-2]种方式
S[i-2] = ‘2’
S[i-1] ∈{‘0’, ..., ‘6’} , 1种可能翻译成一个字母, 共f[i-2]种方式
S[i-1] ∈{‘7’, ..., ‘9’} , 不能翻译成字母
S[i-1] = ‘*’ ,  6种可能翻译成一个字母, 共6*f[i-2]种方式
S[i-2] ∈{‘3’, ..., ‘9’} :不能翻译成字母
S[i-2] = ‘*’
S[i-1] ∈{‘0’, ..., ‘6’} , 2种可能翻译成一个字母, 共2*f[i-2]种方式
S[i-1] ∈{‘7’, ..., ‘9’} , 1种可能翻译成一个字母, 共f[i-2]种方式
S[i-1] =‘*’ , 15种可能翻译成一个字母, 共15*f[i-2]种方式

## 4.2. 博弈类动态规划 Game DP
博弈为两方游戏
一方先下, 在一定规则下依次出招 如果满足一定条件, 则一方胜
目标:取胜

博弈
先手:先出招的一方
出招后, 先手换人, 新的先手面对一个新的局面
先手

Coins in a line
https://www.lintcode.com/problem/coins-in-a-line/ https://www.jiuzhang.com/solutions/coins-in-a-line/

LintCode 394
有一排N个石子, Alice, Bob两人轮流取石子
每次一个人可以从最右边取走1个或2个石子
取走最后石子的人胜
问先手Alice是否必胜 (先手必胜: true,先手必败: false)
例子:
输入:N=5
输出:true (先手取走2个石子, 剩下3个石子, 无论后手怎么拿, 先手都可以 取走最后一个石子)

分析
面对N个石子, 先手Alice第一步可以拿1个或2个石子
这样后手Bob就面对N-1个石子或N-2个石子
先手Alice一定会选择能让自己赢的一步 – 因为双方都是采取最优策略
怎么选择让自己赢的一步
就是走了这一步之后, 对手面对剩下的石子, 他必输

博弈动态规划:必胜 vs 必败 必胜

博弈动态规划: 必胜 vs 必败
知识点
如果取1个或2个石子后, 能让剩下的局面先手必败, 则当前先手必胜
知识点
如果不管怎么走, 剩下的局面都是先手必胜, 则当前先手必败
宗旨
必胜:在当下的局面走出一步,  让对手无路可逃
必败:自己无路可逃

状态:设f[i]表示面对i个石子, 是否先手必胜(f[i] = TRUE / FALSE)
转移方程:f[i] = f[i-1] == FALSE OR f[i-2] == FALSE
初始条件和边界情况:
– f[0] = FALSE --- 面对0个石子, 先手必败
– f[1] = f[2] = TRUE --- 面对1个石子或2个石子, 先手必胜
计算顺序:f[0], f[1], f[2], ..., f[N]
如果f[N] = TRUE则先手必胜, 否则先手必败
时间复杂度O(N), 空间复杂度O(N), 可以滚动数组优化至O(1)  

Coins in a Line II
https://www.lintcode.com/problem/coins-in-a-line-ii/ https://www.jiuzhang.com/solutions/coins-in-a-line-ii/

LintCode 395
给定一个序列a[0], a[1], ..., a[N-1]
两个玩家Alice和Bob轮流取数
每个人每次只能从左边取1或2个数
双方都用最优策略, 使得自己的数字和尽量比对手大 问先手是否必胜
– 如果数字和一样, 也算先手胜
例子:
输入:[1, 2, 2] 输出:True


分析
这题是一道博弈题, 目标是让自己拿到的数字之和不比对手小
设己方数字和是A, 对手数字和是B, 即目标是A>=B, 等价于A-B>=0。即如果
SA=A-B,  SB=B-A, Alice的目标是最大化SA, Bob的目标是最大化SB
当一方X面对剩下的数字, 可以认为X就是当前的先手, 他的目标就是最大化
SX=X-Y
当他这一步取走数字的和为m后, 对手Y变成先手, 同理他也要最大化SY=Y-X
对于X来说, SX=-SY+m
– 其中, m是当前这步的数字, -SY是对手看来的数字差取相反数(因为先手是X)


分析
状态:设f[i]为一方在面对a[i..n-1]这些数字时, 能得到的最大的与对手的数字差 转移方程:f[i] = max{a[i] - f[i+1], a[i] + a[i + 1] - f[i + 2]}
初始条件:f[n] = 0
计算顺序:f[n], f[n-1], ..., f[0]
如果f[0]>=0, 先手Alice必赢, 否则必输
时间复杂度O(N), 空间复杂度O(N)


## 4.3. 区间类DP Interval
特点: 1. 求一段区间的解max/min/count 2. 转移方程通过区间更新 3. 大区间的值依赖于小区间

Burst Ballons
http://www.lintcode.com/problem/burst-balloons/ http://www.jiuzhang.com/solutions/burst-ballons/

LintCode 168
给定N个气球, 每个气球上都标有一个数字:a1, a2, ..., aN
要求扎破所有气球, 扎破第i个气球可以获得a[left]*a[i]*a[right]枚金币 – left和right是与i相邻的下标
– 扎破气球i以后, left和right就变成相邻的气球
求最多获得的金币数(设a[0]=a[N+1]=1)
例子:
输入:[3, 1, 5, 8]
输出:167
– [3,1,5,8]à[3,5,8]à[3,8]à[8]à[]
– 金币3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167

确定状态:
– 最后一步:一定有最后一个被扎破的气球, 编号是i
– 扎破i时, 左边是气球0, 右边是气球N+1, 获得金币1*ai*1=ai
– 此时气球1~i-1以及i+1~N都已经被扎破, 并且已经获得对应金币—子问题 – 状态:设f[i][j]为扎破i+1~j-1号气球, 最多获得的金币数
转移方程:f[i][j] = maxi<k<j{f[i][k] + f[k][j] + a[i] * a[k] * a[j]}
初始条件和边界情况:f[0][1] = f[1][2] = ... = f[N][N+1] = 0
计算顺序:
– f[0][1], f[1][2], f[2][3], ..., f[N][N+1]
– f[0][2], f[1][3], f[2][4], ..., f[N-1][N+1] –...
– f[0][N+1]
时间复杂度O(N3), 空间复杂度O(N2)

Coins in a Line III
http://www.lintcode.com/problem/coins-in-a-line-iii http://www.jiuzhang.com/solutions/coins-in-a-line-iii

LintCode 396
给定一个序列a[0], a[1], ..., a[N-1]
两个玩家Alice和Bob轮流取数
每个人每次只能取第一个数或最后一个数
双方都用最优策略, 使得自己的数字和尽量比对手大
问先手是否必胜
– 如果数字和一样, 也算先手胜
例子:
输入:[1, 5, 233, 7]
输出:True (先手取走1, 无论后手取哪个, 先手都能取走233)


博弈
和Coins in a Line II类似, 目标是让自己拿到的数字之和不比对手小
设己方数字和是A, 对手数字和是B, 即目标是A>=B
等价于A-B>=0
也就是说, 如果Alice和Bob都存着自己的数字和与对手的数字和之差, 分别记为 SA=A-B,  SB=B-A
则Alice的目标是最大化SA, Bob的目标是最大化SB  

分析
状态:设f[i][j]为一方先手在面对a[i..j]这些数字时, 能得到的最大的与对手的 数字差—区间型动态规划
转移方程:f[i][j] = max{a[i] - f[i+1][j], a[j] - f[i][j-1]}
初始条件:f[i][i] = a[i]
计算顺序:
– 长度1:f[0][0], f[1][1], f[2][2], ..., f[N-1][N-1] – 长度2: f[0][1], ..., f[N-2][N-1]
–...
– 长度N: f[0][N-1]
如果f[0][N-1]>=0, 先手Alice必赢, 否则必输
时间复杂度O(N2), 空间复杂度O(N2), 也可以用记忆化搜索
区间+博弈


区间DP总结 最后都是求 0~n-1 这段区间的值
逆向思维:考虑最后一步如何做, 而不考虑第一步如何做

今日重点三题
Minimum Path Sum 滚动数组优化
Coins in a Line 博弈问题
必胜和必败状态
Burst Balloons
区间型动态规划 消去型问题

# 5. 第六讲 动态规划(下) - 双序列与背包
双序列型DP
Longest Common Subsequence
Interleaving String
Edit Distance
K Edit Distance
背包型DP
BackPack I
BackPack II
BackPack III
KSUM

## 5.1. 双序列型动态规划
两个序列/字符串的最优值/方案数/可行性 可以使用滚动数组优化空间

Longest Common Subsequence
http://www.lintcode.com/problem/longest-common-subsequence/ http://www.jiuzhang.com/solutions/longest-common-subsequence/


LintCode 77
给定两个字符串A, B
一个字符串的子序列是这个字符串去掉某些字符(可能0个)之后剩下的字符串 找到两个字符串的最长公共子序列的长度
例子:
输入:A=“jiuzhang”, B=“lijiang”
输出:5(最长公共子序列是jiang )

确定状态:
– 最后一步:观察A[m-1]和B[n-1]这两个字符是否作为一个对子在最优策略中
– 状态:设f[i][j]为A前i个字符A[0..i-1]和B前j个字符[0..j-1]的最长公共子序列的长度
转移方程:f[i][j] = max{f[i-1][j], f[i][j-1], f[i-1][j-1]+1|A[i-1]=B[j-1]}
初始条件和边界情况: – f[0][j] = 0, j=0..n
– f[i][0] = 0, i=0..m
计算顺序: – f[0][0..n]
–...
– f[m][0..n]
答案是f[m][n]
时间复杂度:O(MN), 空间复杂度:O(MN), 可以用滚动数组优化空间至O(N) 

Edit Distance
http://www.lintcode.com/problem/edit-distance/ http://www.jiuzhang.com/solutions/edit-distance/

LintCode 119
给定两个字符串A, B
要求把A变成B, 每次可以进行下面一种操作: – 增加一个字符
– 去掉一个字符
– 替换一个字符
最少需要多少次操作, 即最小编辑距离
例子:
输入:A=“mart”, B=“karma”
输出:3 (m换成k, t换成m, 加上a)

确定状态:
– 最后一步:观察B[n-1]是如何产生的(插入, 删除, 替换, 和A[m-1]匹配) – 状态:设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]的最小编辑距离
转移方程:f[i][j]=min{f[i][j-1]+1, f[i-1][j-1]+1, f[i-1][j]+1, f[i-1][j-1]|A[i-1]=B[j-1]}
初始条件和边界情况: – f[0][j] = j, j=0..n
– f[i][0] = i, i=0..m
计算顺序: – f[0][0..n]
–...
– f[m][0..n]
答案是f[m][n]
时间复杂度:O(MN), 空间复杂度:O(MN), 可以用滚动数组优化空间至O(N) 

Interleaving String
http://www.lintcode.com/problem/interleaving-string/ http://www.jiuzhang.com/solutions/interleaving-string/

LintCode 29
给定三个字符串A, B, X
判断X是否是由A, B交错在一起形成
– 即A是X的子序列, 去掉A后, 剩下的字符组成B
例子:
输入:A=“aabcc” B=“dbbac”, X=“aadbbcbcac” 输出:True( X=“aadbbcbcac” )

最后一步:假设X是由A和B交错形成的, 那么X的最后一个字符X[m+n-1]要么是 A[m-1], 要么是B[n-1]
状态:f[i][j]=X前i+j个字符是否由A前i个字符和B前j个字符交错形成
转移方程:f[i][j] = (f[i-1][j] AND X[i+j-1]==A[i-1])OR(f[i][j-1] AND X[i+j-1]==B[j-1])
初始条件:f[0][0]=True
计算顺序:
– f[0][0], f[0][1], ..., f[0][n] –...
– f[m][0], f[m][1], ..., f[m][n]
时间复杂度(计算步数)O(MN), 空间复杂度(数组大小)O(MN), 可以用滚 动数组优化空间至O(N)

K Edit Distance
http://www.lintcode.com/problem/k-edit-distance/ http://www.jiuzhang.com/solutions/k-edit-distance/


LintCode 623
给定N个字符串, 以及目标字符串T
问哪些字符串和T的编辑距离不大于K
一次编辑包括插入一个字符或删除一个字符或修改一个字符
输入:
– A = ["abc", "abd", "abcd", "adc"] – Target = "ac”
–K=1
输出: ["abc", "adc"] 

如果依次用Edit Distance得到结果, 存在重复计算 – 如果给定的字符串是"abca", "abcb", "abcc"
– 三个字符串的前3个字符都一样
– "abca"前0~3个字符和Target前0~n个字符的最小编辑距离 – "abcb"前0~3个字符和Target前0~n个字符的最小编辑距离 – "abcc"前0~3个字符和Target前0~n个字符的最小编辑距离
如何避免重复计算
如果几个字符串共享一段前缀, 他们对应的f[i][j]可以共享, 即只计算一次
数据结构Trie:字母树 

字母树Trie
一个词的所有前缀就是从根到这个词 的节点路径上形成的所有的字符串

状态:f[sP][j]为前缀sP(即节点P对应的字符串)和T前j个字符的最小编辑距离
设P的父亲是Q
转移方程:f[sP][j]=min{f[sP][j-1]+1,f[sQ][j-1]+1,f[sQ][j]+1,f[sQ][j-1]|sP[last]=T[j-1]
初始条件:一个空串和一个长度为L的串的最小编辑距离是L – f[sroot][j] = f[""][j] = j (j = 0, 1, 2, ..., n)
– f[sp][0] = length(sp)
计算顺序
– 初始化f[sroot][0]~f[sroot][n]
– 按照字母树深度优先搜索顺序计算每个f[sP][0]~f[sP][n] – 答案是满足f[sP][n]<=K且sP在给定列表中的所有单词 – 用DFS实现
– 时间复杂度(计算步数)O(前缀个数*N)
– 空间复杂度(数组大小)O(前缀个数 + 最长单词长度*N)

## 5.2. 背包型DP
BackPack
http://www.lintcode.com/problem/backpack/
http://www.jiuzhang.com/solutions/backpack/

LintCode 92
给定N个物品, 重量分别为正整数A0, A1, ..., AN-1 一个背包最大承重是正整数M
最多能带走多重的物品
例子:
输入:4个物品, 重量为2, 3, 5, 7. 背包最大承重是11 输出:10 (三个物品:2, 3, 5)

每个装物品的方案的总重量都是0到M, 如果对于每个总重量, 我们能知道有没 有方案能做到, 就可以解决
背包问题中, 数组大小和总承重有关
最后一步:最后一个物品(重量AN-1)是否进入背包
状态:设f[i][w] = 能否用前i个物品拼出重量w (TRUE / FALSE)
常见误区:错误 设f[i]表示前i个物品能拼出的最大重量(不超过M) – 反例:A=[3 9 5 2], M=10
– 错误原因:最优策略中, 前N-1个物品拼出的不一定是不超过M的最大重量

转移方程:f[i][w] = f[i-1][w] OR f[i-1][w-Ai-1]
初始条件和边界情况:
– f[0][0] = TRUE: 0个物品可以拼出重量0
– f[0][1..M] = FALSE: 0个物品不能拼出大于0的重量 – f[i-1][w-Ai-1]只能在w≥Ai-1时使用
计算顺序: – f[0][0..m]
–...
– f[n][0..m]
答案是最大的j使得f[n][j]=True
时间复杂度:O(MN), 空间复杂度:O(MN), 可以用滚动数组优化空间至O(N) 

BackPack 马甲题型 把一个[1,24,5,6]数组尽量平分。

Backpack II
http://www.lintcode.com/problem/backpack-ii/ http://www.jiuzhang.com/solutions/backpack-ii/

LintCode 125
给定N个物品, 重量分别为正整数A0, A1, ..., AN-1, 价值分别为正整数V0, V1, ..., VN-1
一个背包最大承重是正整数M
最多能带走多大价值的物品
例子:
输入:4个物品, 重量为2, 3, 5, 7, 价值为1, 5, 2, 4. 背包最大承重是11
输出:9 (物品一+物品三, 重量3+7=10, 价值5+4=9)

每个装物品的方案的总重量都是0到M, 如果对于每个总重量, 我们能知道对应 的最大价值是多少, 就能知道答案
背包问题中, 数组大小和总承重有关
最后一步:最后一个物品(重量AN-1, 价值VN-1)是否进入背包
状态:设f[i][w] = 用前i个物品拼出重量w时最大总价值 (-1表示不能拼出w)

转移方程:f[i][w] = max{f[i-1][w], f[i-1][w-Ai-1] + Vi-1 | w≥Ai-1 且f[i-1][w-Ai-1] ≠-1}
初始条件和边界情况:
– f[0][0] = 0: 0个物品可以拼出重量0, 最大总价值是0
– f[0][1..M] = -1: 0个物品不能拼出大于0的重量
– f[i-1][w-Ai-1]只能在w≥Ai-1, 并且f[i-1][w-Ai-1] ≠-1时使用
计算顺序: – f[0][0..m]
–...
– f[n][0..m]
答案是max0<=j<=M{f[N][j] | f[N][j] ≠-1} 

Backpack III
http://www.lintcode.com/problem/backpack-iii/ http://www.jiuzhang.com/solutions/backpack-iii/

LintCode 440
给定N种物品, 重量分别为正整数A0, A1, ..., AN-1, 价值分别为正整数V0, V1, ..., VN-1
每种物品都有无穷多个
一个背包最大承重是正整数M
最多能带走多大价值的物品
例子:
输入:4个物品, 重量为2, 3, 5, 7, 价值为1, 5, 2, 4. 背包最大承重是10
输出:15 (3个物品一, 重量3*3=9, 价值5*3=15)

和Backpack II唯一的不同是:每种物品都有无穷多个
状态:设f[i][w] = 用前i种物品拼出重量w时最大总价值 (-1表示不能拼出w) 转移方程:f[i][w] = maxk>=0{f[i-1][w-kAi-1] + kVi-1}
可以转化为f[i][w] = max{f[i-1][w], f[i][w-Ai-1] + Vi-1}

优化
f[i][w] = max{f[i-1][w], f[i][w-Ai-1] + Vi-1} 实际编程中可以进一步优化
w=0 1 2 3 4 5 6 7 i=0
i=1 i=2 i=3

K Sum
http://www.lintcode.com/problem/k-sum/ http://www.jiuzhang.com/solutions/k-sum/


LintCode 89
给定数组A, 包含n个互不相等的正整数
问有多少种方式从中找出K个数, 使得它们的和是Target
例子:
输入:A=[1, 2, 3, 4], K=2, Target = 5 输出:2 (1+4=5,2+3=5)

最后一步:最后一个数An-1是否选入这K个数
状态:f[i][k][s]表示有多少种方法可以在前i个数中选出k个, 使得它们的和是s
转移方程:f[i][k][s] = f[i-1][k][s] + f[i-1][k-1][s-Ai-1]|k>=1 AND s>=Ai-1
初始条件:
– f[0][0][0] = 1
– f[0][0][s] = 0, s = 1, 2, ..., Target
计算顺序:
– f[0][0~K][0~Target] –...
– f[N][0~K][0~Target]
时间复杂度O(N*K*Target), 空间复杂度O(N*K*Target), 可以用滚动数组优化 至O(K*Target)

总结
双序列型DP问题 二维数组
最后一步考虑两个序列最后的元素 可以滚动数组优化
背包型DP问题
用背包承重作为DP维度之一
最后一步考虑最后一个物品是否进背包 可以滚动数组优化

今日重点题型
Longest Common Subsequence 双序列常考题
Edit Distance 双序列常考题
Backpack II
有价值的背包题目才有价值