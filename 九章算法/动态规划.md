最优解/方式数 -> DP
所有解 -> Recursion, DFS

1.计数 (有多少种方式、方法) how many ways   (也有可能是贪心, greedy algorithm)
2.求最值 (最大数字和, 最大上升子序列长度)
3.求存在性 (是或否, 博弈游戏, 谁获胜, 能不能? 存不存在策略?) 输出True/False 

Lintcode 669: Coin Change 




# 背包 Backpack
重要性: 动态规划中的重难点; 面试中的常考点
什么是背包问题? 背包(容量), 物品(所占空间, 价值) -> 不超过背包容量, 价值最大化
主要分类: 0-1背包(取/不取), 完全/无穷背包(所有物品无穷多个), 多重背包(物品有一定的数量)

基本思路 
* 0-1背包 knapsack
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - A[i]] + V[i])
* 完全背包: 枚举每件物品取0, 1, 2, 3 ... m / A[i] 件     
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 
* 多重背包: 枚举每件物品取0, 1, 2, 3 ... amounts[i]件  
    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 

## 0-1背包 knapsack
outline—— 爆搜, 贪心的思路与局限; 动态规划算法实例与代码, 以及空间优化

0-1背包三种方法
1. 0-1背包 爆搜 (物品→取/不取, n个物体 枚举2^n) 爆搜不加优化很可能TLE超时
举例: 背包容量 m = 10 物品大小 A = [2, 3, 5, 7] 物品价值 V = [1, 5, 2, 4]
爆搜解法:分别枚举每一个物体取或者不取,1代表取,0代表不取

爆搜算法的局限	TC=O(2^n)
搜索树 (略)
优化的两种思路: ??? ; 剪枝pruning
结果状态
对于前i个物体, 每个都枚举了取或者不取。在确定容量j下, 可能包含了不同的情况, 但我们只需要知道最好的价值就可以了

2. 0-1背包 贪心
取价值最高 m=2, A=[1,1,2], V=[2,2,3]				    贪心答案:3, 正确答案:4
取重量最轻 m=2, A=[1,1,2], V=[1,1,3]				    贪心答案:2, 正确答案:3
取单位价值最高(性价比最高) m=3, A=[1,1,3], V=[2,2,5]	   贪心答案:4, 正确答案:5
所有的贪心,都是错误的!!!    因为都是考虑当前最优解≠最终最优解

3. 0-1背包 动态规划实现:
背包容量 m = 10 物品大小 A = [2, 3, 5, 7] 物品价值 V = [1, 5, 2, 4]
使用数组来记录取前i个物品, 在容量j的情况下能取的最大价值
*Note: 加一行一列的0, 这样第一个物品可以当做普通物品考虑, 不需要单独处理了*

dp[i][j]表示前i个物体,在容量j的情况下, 能取到的最大价值
当前物品(物品i)2个选择:
如果取第i个物体,价值为dp[i - 1][j - A[i]] + V[i]   (j-A[i]>0; 若<0则数组越界) 
如果不取第i个物体,价值为dp[i - 1][j]
状态转移: dp[i][j] = max(dp[i - 1][j - A[i]] + V[i], dp[i - 1][j])

LintCode 125. [Backpack II]()
LintCode 563

LintCode 92		两种做法: 体积当做价值 A[i]=V[i] 转化为0-1背包;  装多满的问题, 给定空间x, 能否装满x
LintCode 562	无穷/完全背包 (状态转移方程..)

## 完全背包
outline—— 什么是完全背包? 基本思路;将完全背包转化为0-1背包; O(V*m)的实现

完全背包: 给定 n 种物品, 每种物品都有无限个。第 i 个物品的体积为A[i], 价值为V[i]。再给定一个容量为 m 的背包。问可以装入背包的最大价值是多少?

基本思路
转移方程
0-1背包: dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - A[i]] + V[i])   当前物品取 vs 不取           容量j
完全背包:枚举每件物品取0, 1, 2, 3…m/A[i]件   (最多取m/A[i]件)
		dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 	不取 vs 取k个

例子分析
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 

i→k (k为最多可以取几次)

转化为0-1背包: 将第i件物品最多取k个, 转化为k件 (A[i], V[i]) 的物品  (每件都当做单件物品处理)
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]
A = [2, 3, 4, 5] 最多取 4, 2, 2, 1次


LintCode 440

在两重循环的条件下, 0-1背包的倒序枚举能解决完全背包的问题吗? 不能  (why???)

0-1背包 一维优化 (二维数组优化成一维)
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]

0-1背包可以用倒序来做; 若正序呢? (0-1背包若正序处理, 每一种物品可能被添加多次, 正好是完全背包的要求)

完全背包 O(V*m) 优化 
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200]

三种状态: 1)不装该物品   2)第一次装该物品  3)多次添加该物品		3)一定 > 2)
@dp[1][2]  	1) 从dp[0][2]转移     2)从dp[0][2-2] = dp[0][0]转移    3)从dp[1][2-2] = dp[1][0]转移
@dp[1][2]  	1) 从dp[0][2]转移     2)从dp[0][2-2] = dp[0][0]转移    3)从dp[1][2-2] = dp[1][0]转移

LintCode 801
LintCode 562

## 多重背包
outline—— 什么是多重背包? 基本思路; 将完全背包转化为0-1背包

多重背包: 给定 n 种物品, 每种物品都有amounts[i]个 (一定个数)。第 i 个物品的体积为 A[i], 价值为 V[i]。再给定一个容量为 m 的背包。问可以装入背包的最大价值是多少? 

基本思路 
0-1 背包: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - A[i]] + V[i]) 
完全背包: 枚举每件物品取0, 1, 2, 3 ... m / A[i] 件     dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 
多重背包: 枚举每件物品取0, 1, 2, 3 ... amounts[i]件  dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * A[i]] + k * V[i]) 


例子分析 
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 物品数量 A = [2, 1, 2, 1] 

转化为 0-1 背包 
背包容量 m=8 物品大小 A = [2, 3, 4, 5] 物品价值 V = [30, 50, 100, 200] 
将第i件物品最多取k 个，转化为k件 (A[i], V[i])的物品 

LintCode 798
物品 重量 	价值 	个数
	3	300	1
	2	160	6


LintCode 799

## 优化拓展 (空间优化)
0-1 背包 滚动数组优化 & 一维数组优化
举例2: 背包容量m = 8 物品大小A = [2, 3, 4, 5] 物品价值V = [3, 4, 5, 6]

dp[i][j] = max(dp[i - 1][j – A[i]] + V[i], dp[i - 1][j]) 

①滚动数组优化 
前i个物品能取到的最优价值, 只和前i-1个物品能取到有关 (只需要前面1维)
dp[1][j] = max(dp[0][j – A[i]] + V[i], dp[0][j]) 

②一维数组优化
当前j只和上一层的j, 以及上一层的j - A[i]有关
新的状态转移方程 dp[j] = max(dp[j – A[i]] + V[i], dp[j]) (一定要倒序!!! 倒序更新, 从后往前, 覆盖不影响) 

完全背包 二进制优化
m=8 A=[2, 3, 4, 5] V=[30, 50, 100, 200] 
第0个物品: A[0] = 2, V[0] = 30, 最多取4个 (0, 1, 2, 4)
第1个物品: 最多取2个 
第i个物品: 最多取x个(2^n <= x) 拆分为1, 2, 4, 8...2^n  (→看做取n个不同的物品)
类似快速幂 x^m  (1)for循环n次  (2)m/2


LintCode 1538
LintCode 800  物品带来的价值 *, 而不是 +
LintCode 700
LintCode 749
