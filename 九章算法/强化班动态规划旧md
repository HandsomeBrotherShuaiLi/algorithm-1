# 第五讲

Overview
滚动数组
House Robber I/II
Maximal Square
记忆化搜索
Longest Increasing Subsequence
Coin in a line I/II/III
  

动态规划的4点要素 1. 状态 State
灵感，创造力，存储小规模问题的结果
最优解/Maximum/Minimum
Yes/No
Count(*)
2. 方程 Function
状态之间的联系，怎么通过小的状态，来求得大的状态
3. 初始化 Intialization
最极限的小状态是什么, 起点
4. 答案 Answer
最大的那个状态是什么，终点
    
滚动数组优化
f[i] = max(f[i-1], f[i-2] + A[i]);
转换为
f[i%2] = max(f[(i-1)%2]和 f[(i-2)%2])
   
House Robber
http://www.lintcode.com/en/problem/house-robber/
http://www.jiuzhang.com/solutions/house-robber/
公主追王子 For循环 -----> DP

  序列型动态规划
状态 State
f[i] 表示前i个房子中，偷到的最大价值 方程 Function
f[i] = max(f[i-1], f[i-2] + A[i]);
初始化 Intialization
f[0] = 0;
f[1] = A[0];
答案 Answer
f[n]
  

House Robber II
http://www.lintcode.com/en/problem/house-robber-ii/
http://www.jiuzhang.com/solutions/house-robber-ii/
 
   滚动数组优化一维
  这类题目特点
f[i] = max(f[i-1], f[i-2] + A[i]); 由 f[i-1],f[i-2] 来决定状态
可以转化为
f[i%2] = max(f[(i-1)%2]和 f[(i-2)%2]) 由f[(i-1)%2]和 f[(i-2)%2] 来决定状态
观察我们需要保留的状态来确定模数
其他一维滚动数组的题目
http://www.lintcode.com/en/problem/climbing-stairs/
   

 
    Maximal Square
http://www.lintcode.com/en/problem/maximal-square/
http://www.jiuzhang.com/solutions/maximal-square/
    
 
    小技巧
网格类的题目 正方形用右下角作为定位角 长方形可以用左上角和右下角作为定位角
  
 
  Maximal Square
1. 状态 State
f[i][j] 表示以i和j作为正方形右下角可以拓展的最大边长
2. 方程 Function
if matrix[i][j] == 1
f[i][j] = min(LEFT[i - 1][j], UP[i][j-1], f[i-1][j-1]) + 1; if matrix[i][j] == 0
f[i][j] = 0
3. 初始化 Intialization
f[i][0] = matrix[i][0];
f[0][j] = matrix[0][j];
4. 答案 Answer
max{f[i][j]}
  
 
  Maximal Square
1. 状态 State
f[i][j] 表示以i和j作为正方形右下角可以拓展的最大边长
2. 方程 Function
if matrix[i][j] == 1
f[i][j] = min(f[i - 1][j], f[i][j-1], f[i-1][j-1]) + 1; if matrix[i][j] == 0
f[i][j] = 0
3. 初始化 Intialization
f[i][0] = matrix[i][0];
f[0][j] = matrix[0][j];
4. 答案 Answer
max{f[i][j]}
  
 
  Maximal Square
1. 状态 State
f[i][j] 表示以i和j作为正方形右下角可以拓展的最大边长
2. 方程 Function
if matrix[i][j] == 1
f[i%2][j] = min(f[(i - 1)%2][j], f[i%2][j-1], f[(i-1)%2][j-1]) + 1; if matrix[i][j] == 0
f[i%2][j] = 0
3. 初始化 Intialization
f[i%2][0] = matrix[i%2][0];
f[0][j] = matrix[0][j];
4. 答案 Answer
max{f[i%2][j]}
  
 
Follow up
01矩阵里面找一个，对角线全为1， 其他为0的矩阵
  
 
二维动态规划空间优化
这类题目特点
f[i][j] = 由f[i-1]行 来决定状态， 第i行跟 i-1行之前毫无关系， 所以状态转变为
f[i%2][j] = 由f[(i-1)%2]行来决定状态
  
 
二维滚动数组相关题目 Unique Paths
http://www.lintcode.com/en/problem/unique-paths/
Minimum Path Sum
http://www.lintcode.com/en/problem/minimum-path-sum/
Edit Distance
http://www.lintcode.com/en/problem/edit-distance/
      
记忆化搜索
本质上:动态规划
动态规划就是解决了重复计算的搜索
动态规划的实现方式:
循环(从小到大递推)
记忆化搜索(从大到小搜索)
画搜索树 万金油

Longest Increasing Subsequence
http://www.lintcode.com/en/problem/longest-increasing-
continuous-subsequence/
http://www.jiuzhang.com/solutions/longest-increasing-continuous- subsequence/
[4, 2, 5, 4, 3, 9,8,10]
       

 
Longest Increasing continuous Subsequence 2D
http://www.lintcode.com/en/problem/longest-increasing-continuous-subsequence-ii/ 
http://www.jiuzhang.com/solutions/longest-increasing-continuous- subsequence-ii/

多重循环DP遇到的困难:
从上到下循环不能解决问题 初始状态找不到
那我们有没有可以比较暴力解决的方法呢? 有搜索， 我们从大的往小的搜索

普通搜索 记忆化搜索
那怎么根据DP四要素转化为记忆化搜索呢? State: dp[x][y] 以x,y作为结尾的最长子序列
Function:
遍历x,y 上下左右四个格子 dp[x][y] = dp[nx][ny] + 1
•(if a[x][y] > a[nx][ny]) Intialize:
dp[x][y] 是极小值时，初始化为1 Answer: dp[x][y]中最大值
  
什么时候用记忆化搜索?  1. 状态转移特别麻烦，不是顺序性。 2. 初始化状态不是很容易找到。

## 4.1. 博弈类DP (游戏, 2人博弈 90%都是DP)
Coins in a line
http://www.lintcode.com/en/problem/coins-in-a-line/
http://www.jiuzhang.com/solutions/coins-in-a-line/
     
博弈类DP 博弈有先后手
State:
定义一个人的状态
Function:
考虑两个人的状态做状态更新
Intialize: Answer:
先思考最小状态
然后思考大的状态-> 往小的递推，那么非常适合记忆化搜索
    
Coins in a line
State:
dp[i] 现在还剩i个硬币，现在当前取硬币的人最后输赢状况
Function:
dp[n] = (!dp[n-1]) || (!dp[n-2])
Intialize:
dp[0] = false
dp[1] = true dp[2] = true
Answer: dp[n]
  
Coins in a Line II
http://www.lintcode.com/en/problem/coins-in-a-line-ii/
http://www.jiuzhang.com/solutions/coins-in-a-line-ii/
[5,1,2,10]

State:
dp[i] 现在还剩i个硬币，现在当前取硬币的人最后最多取硬币价值
Function:
n 是所有硬币数目
sum[i] 是后i个硬币的总和
dp[i] = sum[i]-min(dp[i-1], dp[i-2])
Intialize:
dp[0] = 0
dp[1] = coin[i-1]
dp[2] = coin[i-2] + coin[i-1]
Answer: dp[n]

Coins in a Line III
http://www.lintcode.com/en/problem/coins-in-a-line-iii

State:
dp[i][j] 现在还第i到第j的硬币，现在当前取硬币的人最后最多取硬币价值
Function:
sum[i][j]第i到第j的硬币价值总和
dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);
Intialize:
dp[i][i] = coin[i],
Answer:
dp[0][n-1]
  
什么时候用记忆化搜索?
状态转移特别麻烦，不是顺序性。
Longest Increasing continuous Subsequence 2D 遍历x,y 上下左右四个格子 dp[x][y] = dp[nx][ny]
Coins in a Line III
dp[i][j] = sum[i][j] - min(dp[i+1][j], dp[i][j-1]);
初始化状态不是很容易找到
Stone Game
初始化dp[i][i] = 0
Longest Increasing continuous Subsequence 2D 初始化极小值
从大到小
 
   今日重点三题
  House Robber
滚动数组优化最简单的入门。
Longest Increasing continuous Subsequence 2D 记忆化搜索的经典题，此题只有记忆化搜索才能最优。
Coins in a Line III
博弈问题和记忆化搜索的结合

 
# 5. 第六讲
Overview
I. 区间类DP
I. Stone Game
II. Burst Ballons
III. Scramble String

II. 背包类DP
I. BackPackI
II. BackPackII
III. K SUM
IV. Minimum Adjustment Cost

## 5.1. 区间类DP
区间类Dp 特点: 1. 求一段区间的解max/min/count 2. 转移方程通过区间更新 3. 从大到小的更新

Stone Game
http://www.lintcode.com/en/problem/stone-game/ [3,4,5,6]

Stone-Game
死胡同:容易想到的一个思路从小往大，枚举第一次合并是在哪?
记忆化搜索的思路，从大到小，先考虑最后的0-n-1 合并的总花费
State:
dp[i][j] 表示把第i到第j个石子合并到一起的最小花费
Function:
预处理sum[i,j] 表示i到j所有石子价值和
dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum[i,j]) 对于所有k属于{i,j}
Intialize:
for each i
dp[i][i] = 0
Answer:
dp[0][n-1]

Burst Ballons
http://www.lintcode.com/en/problem/burst-balloons/
贪心反例: [1,1,1,1]

Burst Ballons
死胡同:容易想到的一个思路从小往大，枚举第一次在哪吹爆气球?
记忆化搜索的思路，从大到小，先考虑最后的0-n-1 合并的总价值 State:
dp[i][j] 表示把第i到第j个气球打爆的最大价值
Function:
对于所有k属于{i,j}, 表示第k号气球最后打爆。
midValue = arr[i- 1] * arr[k] * arr[j+ 1];
dp[i][j] = min(dp[i][k-1]+d[k+1][j]+midvalue)
Intialize:
for each i
dp[i][i] = 0
Answer:
dp[0][n-1]

Scramble String
http://www.lintcode.com/en/problem/scramble-string/
看 f[great][rgreat] 这个参考例子
f[gr|eat][rgreat] = f[gr][rg] && f[eat][eat] f[gr][at] && f[eat][rgr]

State:
dp[x][y][k] 表示是从s1串x开始，s2串y开始，他们后面k个字符组成的substr是Scramble String
Function:
对于所有i属于{1,k}
s11 = s1.substring(0, i); s12 = s1.substring(i, s1.length());
s21 = s2.substring(0, i); s22 = s2.substring(i, s2.length());
s23 = s2.substring(0, s2.length() - i); s24 = s2.substring(s2.length() - i, s2.length());
for i = x -> x+k
dp[x][y][k] = (dp[x][y][i] && dp[x+i][y+i][k-i]) || dp[x][y+k-i][i] && dp[x+i][y][k-i])
Intialize:
dp[i][j][1] = s1[i]==s[j].
Answer:
dp[0][0][len]

区间DP
coin in a line III stone game
scramble string
这种题目共性就是区间最后求[0,n-1] 这样一个区间 逆向思维分析 从大到小就能迎刃而解
逆向=》 分治类似

## 5.2. 背包类Dp 
特点: 1. 用值作为DP维度 2. Dp过程就是填写矩阵 3. 可以滚动数组优化


BackPack
http://www.lintcode.com/en/problem/backpack/
硬币凑整

State:
f[i][S] “前i”个物品，取出一些能否组成和为S Function:
f[i][S] = f[i-1][S - a[i]] or f[i-1][S]
Intialize:
f[i][0] = true; f[0][1..target] = false
Answer:
检查所有的f[n][j]
O(n*S) ， 滚动数组优化

BackPack 马甲题型 变1 硬币凑整
给1，2，5，10硬币无数多个，请问凑80元的方案总数

BackPack 马甲题型 变2 把一个[1,24,5,6]数组尽量平分。
Backpack II
http://www.lintcode.com/en/problem/backpack-ii/
贪心反例: 背包容量 = 9 A=[4,5,7] V=[3,4,6]

状态 State
f[i][j] 表示前i个物品当中选一些物品组成容量为j的最大价值
方程 Function
f[i][j] = max(f[i-1][j], f[i-1][j-A[i-1]] + V[i-1]);
初始化 Intialization f[0][0]=0;
答案 Answer f[n][s]
O(n*s)

K Sum
http://www.lintcode.com/en/problem/k-sum/
n个数，取k个数，组成和为target State:
f[i][j][t]前i个数取j个数出来能否和为t Function:
f[i][j][t] = f[i - 1][j - 1][t - a[i-1]] or f[i - 1][j][t]
Intialization
f[i][0][0] = 1
Answer
f[n][k][target]

Minimum Adjustment Cost
http://www.lintcode.com/en/problem/minimum-adjustment-cost/

最小调整代价 State:
f[i][v] 前i个数，第i个数调整为v，满足相邻两数<=target，所需要的最小代价 Function:
f[i][v] = min(f[i-1][v’] + |A[i]-v|, |v-v’| <= target)
Answer:
f[n][a[n]-target~a[n]+target]
O(n * A * T)

Summary
区间类DP问题
从大到小去思考
主要是通过记忆化来直观理解DP的思路
背包DP问题
用值作为DP维度
Dp过程就是填写矩阵 可以滚动数组优化

今日重点题型 Backpack II
有价值的背包题目才有价值 Stone-Game
区间类DP的入门题