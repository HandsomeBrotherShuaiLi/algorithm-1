<!-- TOC -->

- [1. Follow Up](#1-follow-up)
    - [1.1. 同向双指针](#11-%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88)
    - [1.2. 求第K大/小元素 (单个数组, 多个数组, 矩阵)](#12-%E6%B1%82%E7%AC%ACk%E5%A4%A7%E5%B0%8F%E5%85%83%E7%B4%A0-%E5%8D%95%E4%B8%AA%E6%95%B0%E7%BB%84-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84-%E7%9F%A9%E9%98%B5)
    - [1.3. Follow Up问题的出题规律](#13-follow-up%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%BA%E9%A2%98%E8%A7%84%E5%BE%8B)
- [2. Heap 堆 & Stack 单调栈](#2-heap-%E5%A0%86--stack-%E5%8D%95%E8%B0%83%E6%A0%88)
    - [2.1. 堆 Heap = 优先队列 Priority Queue](#21-%E5%A0%86-heap--%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-priority-queue)
        - [2.1.1. 双堆](#211-%E5%8F%8C%E5%A0%86)
    - [2.2. 栈 Stack](#22-%E6%A0%88-stack)
        - [2.2.1. 单调栈 Monotonous stack](#221-%E5%8D%95%E8%B0%83%E6%A0%88-monotonous-stack)
- [3. 面试中较难的Follow Up问题 -- Iterator, Subarray Sum, Wiggle Sort](#3-%E9%9D%A2%E8%AF%95%E4%B8%AD%E8%BE%83%E9%9A%BE%E7%9A%84follow-up%E9%97%AE%E9%A2%98----iterator-subarray-sum-wiggle-sort)
    - [3.1. Subarray sum及FollowUp](#31-subarray-sum%E5%8F%8Afollowup)
    - [3.2. Continuous Subarray Sum 及FollowUp](#32-continuous-subarray-sum-%E5%8F%8Afollowup)
    - [3.3. Partition Follow Up](#33-partition-follow-up)
    - [3.4. Iterator Problem](#34-iterator-problem)
- [4. 课程总结](#4-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93)
- [5. 重点/经典题型](#5-%E9%87%8D%E7%82%B9%E7%BB%8F%E5%85%B8%E9%A2%98%E5%9E%8B)

<!-- /TOC -->

# 1. Follow Up
Follow Up问题: 从原题出发, 加/减/改条件 (1D -> 2D)

选择题没整理... TODOs

## 1.1. 同向双指针
LintCode 406: [Minimum Size Subarray Sum](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Minimum%20Size%20Subarray%20Sum.py)
Given an array of n positive integers and a positive integer s, 
find the minimal length of a contiguous subarray of which the sum ≥ s. 最短的连续一段
If there isn't one, return 0 instead. 正整数 连续一段 数字和
* Soln 1: 双指针 i=start, j=end, 枚举sum>S, 长度j-i+1, TC=O(枚举开始×枚举结束×枚举sum)=O(n×n×n)=O(n^3)
* Soln 2: 前缀和数组, prefix sum array, S[j]=a0+...aj, i到j的和为S[j]-S[i-1], TC=O(n^2), 两个for loop
* Soln 3: 同向双指针, 每次删除左指针左边的数字; 只要当前和小于s, 右指针继续向右移动
	for loop + while loop; 右指针往右, 左指针不可能往左 TC=O(左指针移动的次数+右指针移动的次数)=O(n+n)=O(n)
	Note: 有for/while的loop, TC不一定为O(n)

LintCode 384: [Longest Substring Without Repeating Characters](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Longest%20Substring%20Without%20Repeating%20Characters.py)
Given a string, find the length of the longest substring without repeating characters. 最长无重复

固定左指针, i往右移; j可能不动或者往右(不可能往左) --> 同向双指针
i每次往右一步(for loop主指针); j每次往右一步/几步/不动(while loop辅指针)
需要记录两指针中间每个字符出现的次数(均<=1, 0或1); 若右指针下一个字符出现次数为0, 就可以向右移动

使用一个size为26的数组记录各字符出现次数(数组内的值为0或1); 也可以用hashset, 但推荐用array/list, 因为虽然数量级的TC一样, 但是常数项不一样。array为1次, 但是hashmap可能为3次..10次等等。

主指针将数组对应位置-1, 副指针检查数组对应位置是否为0

LintCode 32: [Minimum Window Substring](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Minimum%20Window%20Substring.py)
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). 最短子串

C: 集齐B中字母种类, 阈值处理
同向双指针, 记录每个字符ch在两个指针中间出现的次数freq[ch]
如果ch在T中出现w次, 一旦freq[ch]增加到w, 记录这个字符被完成了
如果ch要从区间中一走, freq[ch]减少到w-1, 记录这个字符没被完成

完成的字符数=T中不同字符数 -> 当前区间包含组成T的所有字符

LintCode 386: [Longest Substring with At Most Two Distinct Characters](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Longest%20Substring%20with%20At%20Most%20Two%20Distinct%20Characters.py)
Given a string s, find the length of the longest substring t that contains at most 2 distinct characters.

[Longest Substring with At Most K Distinct Characters](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Longest%20Substring%20with%20At%20Most%20K%20Distinct%20Characters.py)
Given a string, find the length of the longest substring T that contains at most k distinct characters.
同向双指针, 记录每个字符ch在两个指针中间出现的次数freq[ch]
一旦freq[ch]增加到1, 记录这个字符出现了
一旦freq[ch]减少到0, 记录这个字符不再出现
出现的字符<=K --> 用当前区间长度更新最优解

同向双指针:
* 主指针 -> for, 副指针 -> while
* 记录每个字符ch在两个指针中间出现的次数freq[ch]
* 当freq[ch]增加/减少到临界值, 修改满足条件的字符数

**快慢指针**
[Remove Nth Node From End of List](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Remove%20Nth%20Node%20From%20End%20of%20List.py) 快指针先走N步, 慢指针在开始

[Middle of the Linked List](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Middle%20of%20the%20Linked%20List.py) 快指针走两步, 慢指针走一步

## 1.2. 求第K大/小元素 (单个数组, 多个数组, 矩阵)
LintCode 461: [Kth Largest Element in an Array]()
* Soln 1: 排序O(nlogn) --> 取k-th
* Soln 2: QuickSelect, 每次用当前区间中间的数字P作为pivot; 小于P的放左边, 大于P的放右边
    如果左边的数字个数 >= k, 递归左边; 如果左边数字个数+1 < k, 递归右边, k -= 左边数字个数+1; 否则输出P
    平均时间复杂度O(n), randomly-ordered array
    最差时间复杂度O(n^2)

**QuickSelect**
QuickSelect is similar to QuickSort as both of them are Divide & Conquer algorithms and use Partition to divide the array.
* Partition: take an array (a) and two integers for the beginning and the end of the array (l, r) and choose the last element of the array as a pivot, then it sorts the array putting the pivot in the right place, so that all the elements that are smaller than the pivot on left of it and all elements that are larger than the pivot on the right of it, then returns the index of the pivot.

```python
def partition(nums, left, right):
    x = nums[r]   # pick right as pivot
    i = left - 1
    for j in range(left, right):
        if nums[j] <= x:
            i = i + 1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i + 1], nums[r] = nums[r], nums[i + 1]
    return i + 1
```

LintCode 543: [kth largest in n arrays]() 多个数组  no corresponding leetcode one, skipped this question.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
先将n个数组各自排序, 评价每个数组长度为m, TC=O(n×mlogm), 然后将每个数组最后一个元素放入优先队列(最大堆, 插入删除logN, 求最大O(1))
每次从堆中取出一个数字, 加入他所在数组的前一个数字 (堆的大小永远为n) -> 做k次
时间复杂度O(klogN+nmlogm)

LintCode 1272: [Kth Smallest Element in a Sorted Matrix](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.py) 排序矩阵
Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.
[[1, 5, 9],     左上角的1必定为最小
[10, 11, 13],       
[12, 13, 15]]
k=8

类似n个数组求第k小, 从左上角(必定为最小)开始, 每次从堆中取出一个数字, 加入他右方和下方的数字(如果还没有加入的话) -> 删1个, 加最多两个; 堆最大为k(插入为O(logk))
时间复杂度O(klogk)

LintCode 465: [kth smallest sum in two sorted arrays]() no corresponding leetcode one, skipped this question.
[1, 7, 11], [2, 4, 6]
1+2 1+4 1+6     行递增, 列也递增, --> 递增矩阵求第k小
7+2 7+4 7+6
11+2 11+4 11+6  
M[i, j] = A[i]+ B[j] --> 不需要开一个n*m的数组, 每次计算即可
时间复杂度O(klogk)


## 1.3. Follow Up问题的出题规律
如果我是面试官:
a) 两个包含正整数的数组, 求两两之积的第K小  (两数组排序 -> 递增矩阵)
b) BST上求从小到大第K个 (先求各node子树大小, 递归一遍)
c) 在一个最小堆里(no built-in delete operation)求从小到大第K个 

变化数据结构:
- 1个array -> 多个array
- sorted array -> unsorted array/k sorted array/k unsorted array
- two sorted arrays, sorted matrix
- binary search tree, linked list

# 2. Heap 堆 & Stack 单调栈

若一个栈的进栈序列是a,b,c,d, 在进栈过程中或进栈结束后有一些出栈操作, 则不可能的出栈序列是?
adcb可以通过push, pop, push, push, push, pop, pop, pop来获得
dcba可以通过push, push, push, push, pop, pop, pop, pop来获得
dcab无法通过入栈和出栈获得
abcd可以通过push, pop, push, pop, push, pop, push, pop来获得

向一个空数组中逐渐添加数字[3, 5, 4, 8, 6], 前1个数, 前2个数.. 前5个数的中位数是多少? 假设数组的中位数为排序后index为(n-1)/2的数字, 其中n为数组长度, index从0开始. 
[3]的中位数为3, [3, 5]的中位数为3, [3, 5, 4]的中位数为4, [3, 5, 4, 8]的中位数为4, [3, 5, 4, 8, 5]的中位数为5, 因此为[3, 3, 4, 4, 5]

在求前1个数, 前2个数..前n个数的中位数时, 可以使用两个堆, 用最大堆维护较小的n/2个数, 用最小堆维护较大的后n/2个数。(K个数的中位数, 本质上就是求第k/2小和第k/2大, 因此对于前k/2个较小的数, 我们需要求出最大值, 因此使用最大堆, 而对于后k/2个数, 我们需要求出最小值, 因此使用最小堆)

若要动态维护第K大的数, 应将前K个数加入最小堆。(每次要看的是当前加入的数与前k大的数中最小的数的大小关系, 因此应将前K个数加入最小堆)

## 2.1. 堆 Heap = 优先队列 Priority Queue
堆 Heap = 优先队列 Priority Queue -> 树的结构
支持操作: O(1) Min/Max 求最大/最小 (=根的值)    log(N) Push 插入    log(N) Pop 删除

python: heapq (最小堆 -> 最大堆, 插入时值取负) Java: PriorityQueue  (可以自定义比较函数) C++: priority_queue
堆存在一维数组里, 根x, 左子2x+1, 右子2x+2 (左子<根, 右子<根)
- 解决动态求最大/小值
- 解决动态第K大/小问题 
- 双堆可以解决动态中位数 (不平衡 -> Balance操作)


### 2.1.1. 双堆
LintCode 81: [Find Median from Data Stream]() Data Stream Median 数据流中位数
给N个数, 求前1个数、前2个数...、前N个数的中位数 (the median is A[n//2])
输入:[4,5,1,3,2,6,0] 输出:[4,4,4,3,3,3,3]
* Soln 1: 每次排序, 取中位数k/2, TC=O(n^2logn)
* Soln 2: QuickSelect, 平均O(n)每次, overall TC=O(n^2)  n个数求中位数(静态) -> quickselect
* Soln 3: 类似插入排序, 寻找中位数:O(n2)
* Soln 4: 
    K个数的中位数, 需要知道第K/2小和第K/2大 (最大堆+最小堆)
    动态(有插入/删除操作)维护中位数一般都是用双堆解决 (同理: 动态维护第K大数)  TC=O(nlogn)
    ```text
    [......, N/2, ......]
    <---------->
        最大
            <---------->
                最小
    * 新数加入最大堆or最小堆
    * 调整堆的平衡
    ```

LintCode 360: [Sliding Window Median]()
给定N个数, 求每连续K个数的中位数
输入:[1,2,7,8,5], K = 3 输出:[2, 7, 7]
和Data Stream Median类似(多一个删除操作), 因为窗口移动需要删除已经不在窗口的元素 
维护第K/2小和第K/2大 (最大堆+最小堆)
堆中存数组的index, 不要存数字 (否则相同的数字不知道删除哪个)
TC=O(nlogn)

LintCode 364: [Trapping Rain Water II]()
给定一个nxm的2D地图每个格子的高度, 求其中可以装多少单位的水
输入: 
[[12,13,0,12],
[13,4,13,12],
[13,8,10,12],
[12,13,12,12],
[13,13,13,13]]
输出:14

- 一个格子高度h, 它上面能盛多少水
    检查所有从这个格子到边界的路径, 每条路径i都有最大高度值Mi
    所有路径最小的Mi值就是这个格子的吃水线, 吃水线-h=盛水量
    max{0, 所有路径最小的Mi值-h} 就是答案, 木桶原理
- 用最小堆维护访问的点, 先访问边界一圈的点 (边界的格子不能装水)
- 每次从最小堆顶拿出点P, 向其周围4个方向上看未曾访问过的点, 如Q
    如果Q的高度<=P的吃水线, 说明Q的吃水线就是P的吃水线, 因为Q是第一次被访问到
    如果Q的高度>P的吃水线, 则说明它不能装水, Q的吃水线就是自身的高度
    将(Q, Q的吃水线)加入Heap中 (堆储存已经求过吃水线的位置)
- TC=mnlog(mn)  m*n个点, 每个点只能被插入堆一次, 每次插入log(mn)
- 堆保证吃水线低的先求, 高的后求 (因此不需要求出所有路径的最小吃水线)

## 2.2. 栈 Stack 
先进后出
计算机中实现递归的方式
支持操作: O(1) Push     O(1) Pop        O(1) Top

LintCode 12: [Min Stack]()
支持一个栈的push, pop和min操作, 时间复杂度都是O(1)
```python
push(1)
pop() # return 1 
push(2)
push(3)
min() # return 2 
push(1)
min() # return 1
```
栈的push和pop都是O(1)
求min可以用一个辅助栈minStack, 和stack一样大 (stack插入时, minStack也插入; stack删除时, minStack也删除)
minStack里每个元素表示stack里对应位置元素到栈底的最小值

LintCode 575: [Decode String]()
给定一个表达式, 其中"数字[表达式]"表示方括号里的表达式重复数字次。输出展开的表达式
s = abc3[a] 输出: abcaaa
s = 3[abc] 输出: abcabcabc
s = 4[ac]dy, 输出: acacacacdy
s = 3[2[ad]3[pf]]xyz, 输出: adadpfpfpfadadpfpfpfadadpfpfpfxyz
```text
[.....................]

^                     ^
递归 push             pop   
```
* Soln 1: 可以DFS
* Soln 2: 改成非递归需要栈
    数字和字符都push
    见到"["push当前数字入栈 
    字符直接压栈
    见到"]"就pop字符直到碰到数字A
    这些字符组成的字符串重复A次

[2[3[a]2[bc]]]解码后应为aaabcbcaaabcbc (a重复3次, bc重复两次, 得到aaabcbc; 再把此序列重复2次)

### 2.2.1. 单调栈 Monotonous stack
栈中只保存升序序列 (新元素插入前, pop掉所有比它大的)
stack([1, 2, 8, 10]).push(5) => stack([1, 2, 5])
- 实现非递归  (树的前中后序遍历, 非递归版, 也是常考)
- 单调栈专门解决找一个值左/右第一个比它大/小的值 
- 线性时间复杂度 O(n)

LintCode 122: [Largest Rectangle in Histogram]()
给定直方图中n个柱形的高度, 输出其中最大的矩形
输入:[2, 1, 5, 6, 2, 3] 输出:10
最大矩形一定是某一个柱形往左往右直到不能前进, 形成的矩形
需要知道一个数字往左和往右第一个小于这个数字的位置 (左边第一个比它小的数字的位置 & 右边第一个比它小的数字的位置)
* Soln 1: while loop O(n^2)
* Soln 2: 单调递增栈
    - 压栈时弹出大于等于自己的值 (栈内元素一次变大, 单调递增)
    - 最后停下来时碰到的栈顶就是左边第一个比自己小的值
    - 一个数X被新来的值R弹出栈顶, 那么R就是X右边第一个小于等于X的值
        如果有相同的数, 那么最靠右的bar会求得最大面积 
        最后插入-1
    - 时间复杂度O(N), 每个数只会被压入/弹出栈一次

若现在一个单调栈中的元素为[1, 2, 4, 8], 下一个元素为3, 则将3压入单调栈后, 单调栈内元素为[1, 2, 3] (单调栈在压入一个数之前, 会将栈顶所有大于这个数的元素全部弹出栈, 再将钙元素入栈)

为什么最后要清空栈? 假如给定的长方形高度是[1, 2, 3, 4, 5], 栈内是[1, 2, 3, 4, 5], 答案就不会更新, 清空栈是为了解决这种情况

LintCode 510: [Maximal Rectangle]()
给定一个01矩阵, 求其中最大的全1矩形的面积
输入:
[
  [1, 1, 0, 0, 1],
  [0, 1, 0, 0, 1],
  [0, 0, 1, 1, 1],
  [0, 0, 1, 1, 1],
  [0, 0, 0, 0, 1]
]
输出: 6 
* Soln 1: 枚举左上角, 右下角
* Soln 2: 利用直方图的算法, 以矩阵每一行为直方图的底部, 通过1确定每个柱形的高度, 求出最大全1子矩阵
    时间复杂度O(N^2), 每一行O(n) 共n行
        
LintCode 126: [Max Tree]()
给一个无重复的整数数组。要求建立一棵二叉树, 
规则如下: 
- 最大值作为二叉树的根
- 最大值分出的左右两段数组分别继续建树, 作为根节点的左右子树
输入:[2, 5, 6, 0, 3, 1] 输出: TN(6, [TN(5, [TN(2, None)]), TN(3, [TN(0, None), TN(1, None)])])

* Soln 1: for-loop 找最大值
* Soln 2: 
    每个值X的父亲一定是min{左边第一个比它大的值L, 右边第一个比它大的值R}
    - ....., L, < X, ...,< X, X, < X, ..., < X, R,...
    - 如果L < R, [L, R]里一定R先做根。然后[L, R)里L先做根, 然后就是X 
    - 如果L > R, [L, R]里一定L先做根。然后(L, R]里R先做根, 然后就是X
    如何找到每个值左右第一个比它大的值? 单调递减栈

# 3. 面试中较难的Follow Up问题 -- Iterator, Subarray Sum, Wiggle Sort
非递归的方式实现递归

若给定一个整数序列a, 前缀和数组S[i]=a[0]+a[1]..+a[i]. 若a[i]+..+a[j]=0, 则S[j]-S[i-1]=0

给矩阵a, 矩阵的二维前缀和S[n][m]为以(0,0)为左上端点, (n,m)为右下端点的矩形内 (包括边界)的所有元素之和. 那么以(x1, y1)为左上端点, 以(x2, y2)为右下端点的矩形内(包括边界)的所有元素之和为S[x2][y2]-S[x1-1]S[y2]-S[x2]S[y1-1]+S[x1-1]S[y1-1]

## 3.1. Subarray sum及FollowUp
LintCode 138: [Subarray sum]()
http://www.lintcode.com/problem/subarray-sum/ http://www.jiuzhang.com/solutions/subarray-sum/
给定N个数, 找到一段子数组使得和是0
输入:[-3, 1, 2, -3, 4] 输出:[0, 2]
  
利用前缀和, A[i] +...+ A[j] = S[j] – S[i - 1] 如果A[i] +...+ A[j]=0, 说明S[j]=S[i-1]
利用哈希表

LintCode 139: [Subarray Sum Closest]()
https://www.lintcode.com/problem/subarray-sum-closest/ https://www.jiuzhang.com/solution/subarray-sum-closest/
给定N个数, 找到一段子数组使得和最接近0
输入:[-3, 1, 1, -3, 5] 输出:[0, 2]
  
利用前缀和, A[i] +...+ A[j] = S[j] – S[i - 1]
S[j]与S[i-1]差得越小, A[i] +...+ A[j]越接近0
将所有S值从小到大排序, 检查每个相邻的对子
 
LintCode 405: [Submatrix Sum]()
http://www.lintcode.com/problem/submatrix-sum/ http://www.jiuzhang.com/solutions/submatrix-sum/

给定一个整数矩阵, 找到一个子矩阵使得数字之和为0 
输入:
– [[1 ,5 ,7],
– [3,7,-8],
– [4,-8,9]] 输出:
– [(1, 1), (2, 2)]
枚举子矩阵的上边界U, 下边界D
将U和D之间的数按照列求和, 然后仿照Subarray Sum解决 时间复杂度O(N3)

LintCode 404: [Subarray Sum II]()
http://www.lintcode.com/problem/subarray-sum-ii/ http://www.jiuzhang.com/solutions/subarray-sum-ii/
给定一个正整数数组, 求出在所有子数组中, 数字之和在给定区间内的个数 
输入: [1, 2, 3, 4] 范围 [1, 3] 输出: 4

利用前缀和, A[i] +...+ A[j] = S[j] – S[i - 1]
A都是正整数àS严格递增
每个S[j]要找到在[S[j]-end, S[j]-start]中的S[i]个数 – 同向双指针!
时间复杂度:O(N)
 
## 3.2. Continuous Subarray Sum 及FollowUp
LintCode 402: [Continuous Subarray Sum]()
www.lintcode.com/problem/continuous-subarray-sum/
http://www.jiuzhang.com/solutions/continuous-subarray-sum/
给定一个整数数组, 求出在所有子数组中, 数字之和最大的一个 
输入: [-3, 1, 3, -3, 4] 输出: [1, 4]
  
利用前缀和, A[i] +...+ A[j] = S[j] – S[i - 1] 每个S[j]需要找到之前最小的S[i-1]
时间复杂度:O(N)

LintCode 403: [Continuous Subarray Sum II]()
http://www.lintcode.com/problem/continuous-subarray-sum-ii/ http://www.jiuzhang.com/solutions/continuous-subarray-sum-ii/
给定一个循环整数数组, 求出在所有子数组中, 数字之和最大的一个 
输入: [3, 1, -100, -3, 4] 输出: [4, 1]

先按照Continuous Subarray Sum求出无环情况下的最大非空子数组和S1
再用类似方法求出无环情况下的最小非空子数组和S2
答案即为max{S1, total_sum – S2}
特殊情况:如果选择了最小非空子数组而它是整个数组, 那么选取无环情况下 的最大非空子数组和S1
时间复杂度:O(N)
 
## 3.3. Partition Follow Up
Quick Select
  
LintCode 5: [Kth Largest]()
http://www.lintcode.com/problem/kth-largest-element/ 
http://www.jiuzhang.com/solutions/kth-largest-element/
PriorityQueue
时间复杂度O(nlogk) 更适合动态维护Topk
QuickSelect
时间复杂度O(n) 更适合静态第k大
 
LintCode 508: [Wiggle Sort]()
http://www.lintcode.com/problem/wiggle-sort/ http://www.jiuzhang.com/solutions/wiggle-sort/

给定一个数组, 要求按照如下条件排 nums[0]<=nums[1]>=nums[2]<=nums[3]....
输入: [3,5,2,1,6,4] 输出: [1,6,2,5,3,4]
要求nums[0] <= nums[1] >= nums[2] <= nums[3]...., 即: 当i为奇数时, nums[i] >= nums[i - 1]; 当i为偶数时, nums[i] <= nums[i - 1]
从左到右, 依次处理每个数字
如果和条件不满足, 与之前的数交换位置 时间复杂度O(N)

LintCode 507: [Wiggle Sort II]()
http://www.lintcode.com/problem/wiggle-sort-ii/ http://www.jiuzhang.com/solutions/wiggle-sort-ii/
给定一个数组, 要求按照如下条件排 nums[0]<nums[1]>nums[2]<nums[3]....
输入: [3,5,2,1,6,4] 输出: [1,6,2,5,3,4]
如果获得了中位数, 小于中位数的放在nums[0,2,4,..], 大于中位数的放在 nums[1,3,5,...]
用quickselect获得中位数:O(N)
 
LintCode 399: [Nuts & Bolts Problem]()
http://www.lintcode.com/problem/nuts-bolts-problem/ http://www.jiuzhang.com/solutions/nuts-bolts-problem/
给定一组 n 个不同大小的 nuts 和 n 个不同大小的 bolts
nuts和bolts一一匹配。不允许将nut之间互相比较, 也不允许将bolt之间互相
比较, 只许将 nut 与 bolt 进行比较,  或将 bolt 与 nut 进行比较
输出对应的 nuts 与 bolts
输入: Given nuts = ['ab','bc','dd','gg'], bolts = ['AB','GG', 'DD', 'BC']
输出: 一种可能输出: nuts = ['ab','bc','dd','gg'], bolts = ['AB','BC','DD','GG']

如果nuts之间可以比较, bolts之间可以比较, 那么就可以分别快速排序。只能 比较nuts和bolts, 就可以利用一方排序另一方
先用bolts中的任意一个, B, 去将nuts分成三部分: – 小于B的nuts;正好对应B的nut;大于B的nuts
然后用这个中间的nut, N, 去将bolts分成三部分: – 小于N的bolts;B;大于N的bolts
分别递归
平均时间复杂度:O(nlogn) 

## 3.4. Iterator Problem
Iterator is Non-recursion
必须要用的一个数据结构是什么? 栈
LintCode 22: [Flatten List]()
http://www.lintcode.com/problem/flatten-list/ http://www.jiuzhang.com/solutions/flatten-list/
给定一个列表, 该列表中的每个要素要么是列表, 要么是整数 要求将其扁平化, 即变成一个只包含整数的简单列表
要求不使用递归
输入: [4,[3,[2,[1]]]] 输出: [4,3,2,1]

如果可以使用递归, 遇到整数就塞入结果, 遇到list就递归 不使用递归, 可以用栈模拟
– 遇到整数就输出, 遇到list就将本层iterator塞入栈, 然后处理list的iterator

  
LintCode 528: [Flatten Nested List Iterator]()
http://www.lintcode.com/problem/flatten-nested-list-iterator/ http://www.jiuzhang.com/solutions/flatten-nested-list-iterator/
给定一个列表, 该列表中的每个要素要么是列表, 要么是整数
要求输出一个扁平化后的iterator, 即如果不停调用这个iterator的getNext(), 
返回只包含整数的简单列表
要求不使用递归
输入: [4,[3,[2,[1]]]] 输出:(反复调用iterator) [4,3,2,1]
  
和Flatten List想法类似,  使用栈
先将List里的元素倒序放入栈, 即List第一个元素在栈顶
每次调用getNext时
– 遇到整数输出结果并pop
– 遇到list就倒序放入栈, 继续, 直到遇到整数

LintCode 601: [Flatten 2D Vector]()
http://www.lintcode.com/problem/flatten-2d-vector/ http://www.jiuzhang.com/solutions/flatten-2d-vector/
给定一个二维列表
要求输出一个扁平化后的iterator, 即如果不停调用这个iterator的getNext(), 
返回只包含整数的简单列表
要求不使用递归
输入: [[1,2], [3], [4,5,6]] 输出:(反复调用iterator) [1,2,3,4,5,6]

存储Input List的iterator i
i每次后移一位, 代表处理下一个一维链表
元素的iterator为j
– j一开始指向i指向链表的第一个元素
– 每次如果j是null, 就后移i, j指向i所指链表的第一个元素
类似二维for loop

LintCode 86: [Binary Search Tree Iterator]()
http://www.lintcode.com/problem/binary-search-tree-iterator/ http://www.jiuzhang.com/solutions/binary-search-tree-iterator/
给定一个二叉搜索树, 要求输出一个扁平化后的iterator, 即如果不停调用这个iterator的getNext(), 
返回整棵树中数字, 按照从小到大的顺序, 即按照树的中序遍历
要求不使用递归, hasNext和next的平摊时间复杂度O(1)
输入: 输出:(反复调用iterator) – [1, 6, 10, 11, 12]
  
用栈模拟中序遍历dfs
首先将root, root的左儿子, root的左儿子的左儿子, ...依次放入栈
每次输出栈顶p
– 如果栈顶p有右儿子r, 将r, r的左儿子, r左儿子的左儿子, ...依次放入栈
– 如果栈顶p没有右儿子, 则不停pop栈顶, 直到栈为空, 或者刚pop的元素是新任栈 顶的左儿子
 

Follow Up 常见方式
* 一维转二维 (可以套相同的思路试一试)
    Trapping Water I/II
    Subarray Sum/Submatrix Sum
* 数组变成循环数组 (循环数组小技巧)
    Continuous Subarray Sum 
* 题目条件加强 (可能题目的解题方法会变化) 
    Wiggle Sort I/II
* 换马甲 (变一个描述, 本质不变)
    Number of airplanes on the Sky/ Meeting Room
    Backpack Problem
* 描述完全不一样, 但是方法相同 这种题目得去分析
    Quick Sort/ Bolts and Nuts Problem


# 4. 课程总结
1. 透析热门IT公司中的FollowUp面试题
2. 数据结构(上)—— Union Find, Trie
3. 数据结构(下)—— Heap, Deque, 单调 Stack
4. 二分法第四层境界 + 扫描线算法
5. 动态规划(上)——滚动数组，划分、博弈、区间型动态规划
6. 动态规划(下)——双序列型动态规划，背包动态规划
7. 如何解决困难的 Follow Up 问题 —— Iterator, Subarray Sum, Wiggle Sort


# 5. 重点/经典题型