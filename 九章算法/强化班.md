<!-- TOC -->

- [1. Follow Up](#1-follow-up)
    - [1.1. 同向双指针](#11-%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88)
    - [1.2. 求第K大/小元素 (单个数组, 多个数组, 矩阵)](#12-%E6%B1%82%E7%AC%ACk%E5%A4%A7%E5%B0%8F%E5%85%83%E7%B4%A0-%E5%8D%95%E4%B8%AA%E6%95%B0%E7%BB%84-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84-%E7%9F%A9%E9%98%B5)
    - [1.3. Follow Up问题的出题规律](#13-follow-up%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%BA%E9%A2%98%E8%A7%84%E5%BE%8B)
- [2. Union Find 集合的合并查找操作,并查集  & Trie 字典树](#2-union-find-%E9%9B%86%E5%90%88%E7%9A%84%E5%90%88%E5%B9%B6%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C%E5%B9%B6%E6%9F%A5%E9%9B%86---trie-%E5%AD%97%E5%85%B8%E6%A0%91)
    - [2.1. 并查集 Union Find 集合的合并查找操作,并查集](#21-%E5%B9%B6%E6%9F%A5%E9%9B%86-union-find-%E9%9B%86%E5%90%88%E7%9A%84%E5%90%88%E5%B9%B6%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C%E5%B9%B6%E6%9F%A5%E9%9B%86)
    - [2.2. 字典树Trie, Prefix Tree 前缀树](#22-%E5%AD%97%E5%85%B8%E6%A0%91trie-prefix-tree-%E5%89%8D%E7%BC%80%E6%A0%91)
        - [2.2.1. Trie用于剪枝](#221-trie%E7%94%A8%E4%BA%8E%E5%89%AA%E6%9E%9D)
        - [2.2.2. Typeahead Trie 在系统设计中的运用 (实际运用)](#222-typeahead-trie-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8)
- [3. Heap 堆 & Stack 单调栈](#3-heap-%E5%A0%86--stack-%E5%8D%95%E8%B0%83%E6%A0%88)
    - [3.1. 堆 Heap = 优先队列 Priority Queue](#31-%E5%A0%86-heap--%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-priority-queue)
    - [3.2. 栈 Stack](#32-%E6%A0%88-stack)
        - [3.2.1. 单调栈 Monotonous stack](#321-%E5%8D%95%E8%B0%83%E6%A0%88-monotonous-stack)
- [4. Sweep Line 处理区间问题的扫描线 & Binary Search 二分答案 & Deque 双端队列](#4-sweep-line-%E5%A4%84%E7%90%86%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E7%9A%84%E6%89%AB%E6%8F%8F%E7%BA%BF--binary-search-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88--deque-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97)
    - [4.1. Sweep Line 扫描线算法 -- 区间问题巧妙解法](#41-sweep-line-%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95----%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E5%B7%A7%E5%A6%99%E8%A7%A3%E6%B3%95)
    - [4.2. 二分法难题 Binary Search (Hard)](#42-%E4%BA%8C%E5%88%86%E6%B3%95%E9%9A%BE%E9%A2%98-binary-search-hard)
    - [4.3. Deque 双端队列 (两端都会有push和pop)](#43-deque-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-%E4%B8%A4%E7%AB%AF%E9%83%BD%E4%BC%9A%E6%9C%89push%E5%92%8Cpop)
- [5. DP 滚动数组 划分,博弈 和区间型](#5-dp-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84-%E5%88%92%E5%88%86%E5%8D%9A%E5%BC%88-%E5%92%8C%E5%8C%BA%E9%97%B4%E5%9E%8B)
- [6. DP 双序列与背包](#6-dp-%E5%8F%8C%E5%BA%8F%E5%88%97%E4%B8%8E%E8%83%8C%E5%8C%85)
- [7. 面试中较难的Follow Up问题 -- Iterator, Subarray Sum, Wiggle Sort](#7-%E9%9D%A2%E8%AF%95%E4%B8%AD%E8%BE%83%E9%9A%BE%E7%9A%84follow-up%E9%97%AE%E9%A2%98----iterator-subarray-sum-wiggle-sort)
    - [7.1. Subarray sum及FollowUp](#71-subarray-sum%E5%8F%8Afollowup)
    - [7.2. Continuous Subarray Sum 及FollowUp](#72-continuous-subarray-sum-%E5%8F%8Afollowup)
    - [7.3. Partition Follow Up](#73-partition-follow-up)
    - [7.4. Iterator Problem](#74-iterator-problem)
- [8. 课程总结](#8-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93)
- [9. 面试](#9-%E9%9D%A2%E8%AF%95)
    - [9.1. 电话面试](#91-%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95)
    - [9.2. onsite 现场面授](#92-onsite-%E7%8E%B0%E5%9C%BA%E9%9D%A2%E6%8E%88)
    - [9.3. onsite 后](#93-onsite-%E5%90%8E)

<!-- /TOC -->

九章算法基础班+强化班+树状数组线段树+递归+背包+动态规划
- 位运算 bit manipulation
- 数据结构 Heap
- 数据结构 Stack
- 数据结构 Array
- 数据结构 Linked List
- 数据结构 Deque
- 数据结构 并查集Union Find 字典树Trie
- 数据结构 树状数组 线段树
- 递归 Recursion
- 二分法 (二分, 二分答案)
- 搜索, BFS, DFS
- 扫描线 Sweep Line
- Follow Up 问题
- Greedy
- Divide & Conquer
- 动态规划
    * 背包问题
    * Sliding Array 滚动数组

* 做题的常见误区: 做题获得Accepted就可以了? 看答案抄一遍然后就会了?
* 导致的结果: 做过的题面试中居然还不会; 觉得新题越来越多

* 一题三省: 有哪些类似的题, 他们之间的共通点是什么? 这个题主要考察的是算法思想还是实践能力? 我做题的过程顺利吗, 是否需要再联系一次?
* 如何准备 Follow Up: 定期整理做过的题目, 归类相似问题
    - 题目中哪些条件可以看出这是同类题?
    - 同类题目在思维方式上有什么相似之处?
    - 同类题目在代码实现上有什么相似之处?

# 1. Follow Up
Follow Up问题: 从原题出发, 加/减/改条件 (1D -> 2D)

选择题没整理... TODOs

## 1.1. 同向双指针
LintCode 406: [Minimum Size Subarray Sum](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Minimum%20Size%20Subarray%20Sum.py)
Given an array of n positive integers and a positive integer s, 
find the minimal length of a contiguous subarray of which the sum ≥ s. 最短的连续一段
If there isn't one, return 0 instead. 正整数 连续一段 数字和
* Soln 1: 双指针 i=start, j=end, 枚举sum>S, 长度j-i+1, TC=O(枚举开始×枚举结束×枚举sum)=O(n×n×n)=O(n^3)
* Soln 2: 前缀和数组, prefix sum array, S[j]=a0+...aj, i到j的和为S[j]-S[i-1], TC=O(n^2), 两个for loop
* Soln 3: 同向双指针, 每次删除左指针左边的数字; 只要当前和小于s, 右指针继续向右移动
	for loop + while loop; 右指针往右, 左指针不可能往左 TC=O(左指针移动的次数+右指针移动的次数)=O(n+n)=O(n)
	Note: 有for/while的loop, TC不一定为O(n)

LintCode 384: [Longest Substring Without Repeating Characters](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Longest%20Substring%20Without%20Repeating%20Characters.py)
Given a string, find the length of the longest substring without repeating characters. 最长无重复

固定左指针, i往右移; j可能不动或者往右(不可能往左) --> 同向双指针
i每次往右一步(for loop主指针); j每次往右一步/几步/不动(while loop辅指针)
需要记录两指针中间每个字符出现的次数(均<=1, 0或1); 若右指针下一个字符出现次数为0, 就可以向右移动

使用一个size为26的数组记录各字符出现次数(数组内的值为0或1); 也可以用hashset, 但推荐用array/list, 因为虽然数量级的TC一样, 但是常数项不一样。array为1次, 但是hashmap可能为3次..10次等等。

主指针将数组对应位置-1, 副指针检查数组对应位置是否为0

LintCode 32: [Minimum Window Substring](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Minimum%20Window%20Substring.py)
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). 最短子串

C: 集齐B中字母种类, 阈值处理
同向双指针, 记录每个字符ch在两个指针中间出现的次数freq[ch]
如果ch在T中出现w次, 一旦freq[ch]增加到w, 记录这个字符被完成了
如果ch要从区间中一走, freq[ch]减少到w-1, 记录这个字符没被完成

完成的字符数=T中不同字符数 -> 当前区间包含组成T的所有字符

LintCode 386: [Longest Substring with At Most Two Distinct Characters](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Longest%20Substring%20with%20At%20Most%20Two%20Distinct%20Characters.py)
Given a string s, find the length of the longest substring t that contains at most 2 distinct characters.

[Longest Substring with At Most K Distinct Characters](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Longest%20Substring%20with%20At%20Most%20K%20Distinct%20Characters.py)
Given a string, find the length of the longest substring T that contains at most k distinct characters.
同向双指针, 记录每个字符ch在两个指针中间出现的次数freq[ch]
一旦freq[ch]增加到1, 记录这个字符出现了
一旦freq[ch]减少到0, 记录这个字符不再出现
出现的字符<=K --> 用当前区间长度更新最优解

同向双指针:
* 主指针 -> for, 副指针 -> while
* 记录每个字符ch在两个指针中间出现的次数freq[ch]
* 当freq[ch]增加/减少到临界值, 修改满足条件的字符数

**快慢指针**
[Remove Nth Node From End of List](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Remove%20Nth%20Node%20From%20End%20of%20List.py) 快指针先走N步, 慢指针在开始

[Middle of the Linked List](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Middle%20of%20the%20Linked%20List.py) 快指针走两步, 慢指针走一步

## 1.2. 求第K大/小元素 (单个数组, 多个数组, 矩阵)
LintCode 461: [Kth Largest Element in an Array]()
* Soln 1: 排序O(nlogn) --> 取k-th
* Soln 2: QuickSelect, 每次用当前区间中间的数字P作为pivot; 小于P的放左边, 大于P的放右边
    如果左边的数字个数 >= k, 递归左边; 如果左边数字个数+1 < k, 递归右边, k -= 左边数字个数+1; 否则输出P
    平均时间复杂度O(n), randomly-ordered array
    最差时间复杂度O(n^2)

**QuickSelect**
QuickSelect is similar to QuickSort as both of them are Divide & Conquer algorithms and use Partition to divide the array.
* Partition: take an array (a) and two integers for the beginning and the end of the array (l, r) and choose the last element of the array as a pivot, then it sorts the array putting the pivot in the right place, so that all the elements that are smaller than the pivot on left of it and all elements that are larger than the pivot on the right of it, then returns the index of the pivot.

```python
def partition(nums, left, right):
    x = nums[r]   # pick right as pivot
    i = left - 1
    for j in range(left, right):
        if nums[j] <= x:
            i = i + 1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i + 1], nums[r] = nums[r], nums[i + 1]
    return i + 1
```

LintCode 543: [kth largest in n arrays]() 多个数组  no corresponding leetcode one, skipped this question.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
先将n个数组各自排序, 评价每个数组长度为m, TC=O(n×mlogm), 然后将每个数组最后一个元素放入优先队列(最大堆, 插入删除logN, 求最大O(1))
每次从堆中取出一个数字, 加入他所在数组的前一个数字 (堆的大小永远为n) -> 做k次
时间复杂度O(klogN+nmlogm)

LintCode 1272: [Kth Smallest Element in a Sorted Matrix](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.py) 排序矩阵
Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.
[[1, 5, 9],     左上角的1必定为最小
[10, 11, 13],       
[12, 13, 15]]
k=8

类似n个数组求第k小, 从左上角(必定为最小)开始, 每次从堆中取出一个数字, 加入他右方和下方的数字(如果还没有加入的话) -> 删1个, 加最多两个; 堆最大为k(插入为O(logk))
时间复杂度O(klogk)

LintCode 465: [kth smallest sum in two sorted arrays]() no corresponding leetcode one, skipped this question.
[1, 7, 11], [2, 4, 6]
1+2 1+4 1+6     行递增, 列也递增, --> 递增矩阵求第k小
7+2 7+4 7+6
11+2 11+4 11+6  
M[i, j] = A[i]+ B[j] --> 不需要开一个n*m的数组, 每次计算即可
时间复杂度O(klogk)


## 1.3. Follow Up问题的出题规律
如果我是面试官:
a) 两个包含正整数的数组, 求两两之积的第K小  (两数组排序 -> 递增矩阵)
b) BST上求从小到大第K个 (先求各node子树大小, 递归一遍)
c) 在一个最小堆里(no built-in delete operation)求从小到大第K个 

变化数据结构:
- 1个array -> 多个array
- sorted array -> unsorted array/k sorted array/k unsorted array
- two sorted arrays, sorted matrix
- binary search tree, linked list


# 2. Union Find 集合的合并查找操作,并查集  & Trie 字典树
并查集 Union Find & 字典树 Trie
- 可以解决什么问题 (适用范围) 没有一个DS/Alg是万能的, 都有使用范围
- 代码模板
- 例题

## 2.1. 并查集 Union Find 集合的合并查找操作,并查集
一种用于支持集合(一堆元素形成的整体)快速合并和查找操作的数据结构
* Union 合并(两个集合取并)两个集合 O(1)
* Find 查询元素所属集合 O(1)  给定单个元素, 求所属集合
 
* 应用:
    公司并购 —— 合并两个集合
    查询子公司所在集团 —— 查询所在集合 判断两个子公司是否在同一家集团
* Union Find 是一棵多叉树
    - 根节点
    - 子节点指向父节点
    - 合并: 让一个并查集的根节点指向另一个并查集的根节点
 
实现 Union Find 
* 底层数据结构
    - 父亲表示法, 用一个数组/哈希表记录每个节点的父亲是谁。
    - father[“Nokia”] = “Microsoft”
    - father[“Instagram”] = “Facebook”
* 查询所在集合
    - 用所在集合最顶层的根节点来代表这个集合 
* 合并两个集合
    - 找到两个集合中最顶层的两个根节点 A 和 B
    - father[A] = B OR father[B] = A (如果无所谓谁合并谁的话)
   
初始化
* 使用哈希表或者数组来存储每个节点的父亲节点 
* 如果节点不是连续整数的话,就最好用哈希表来存储 
* 最开始所有的父亲节点都指向自己 (或者指向None/-1)

查找根 
* 沿着父亲节点一路往上走就能找到根
* path compression路径压缩: 在找到根以后,还需要把一路上经过的点都指向根
```
    A -> B -> C -> D    路径压缩后: E -> B -> D     (没有经过E, 故E仍指向B)
    E -> B                              A -> D
                                        C -> D  
```

假设有n个元素,每个元素分别属于某个集合,并且使用并查集来存储这些信息。不带路径压缩的并查集和带路径压缩的并查集,合并两个集合的平均时间复杂度? O(n), O(1)
使用路径压缩的并查集会在find()时将所有经过的元素全部指向根节点, 因此平均时间复杂度可以优化至O(1)

集合合并 
* 找到两个元素所在集合的两个根 A 和 B
* 将其中一个根的父指针指向另外一个根
```python
def __init__():
    f = {}
    for n in nodes:
        f[n] = n  # f[i]: parent/fater of i

def find(x: int, f: dict):
    while f[x] != x: # while不会死循环, UF中没有cycle
        x = f[x]
    return x
# Problem: 高度H, 最差为n TC=O(n) --> path compression

# path compression I
def find(x: int, f: dict):
    root = x
    while f[root] != root: 
        root = f[root]

    # 重走这条路
    while x != root:
        temp = f[root] # 缓存之前的父亲
        f[x] = root  # 指向根节点
        x = temp
        # 或者 x, f[x] = f[x], root

    return root     # return 根节点

# path compression II
def find(node, father):
    path = []
    while node != father[node]:
        path.append(node)
        node = father[node]
    
    for n in path:
        father[n] = node
    return node

def union(x, y, f):
    fx = find(x, f)
    fy = find(y, f)
    if fx != fy:
        f[fx] = fy  # OR f[fy] = fx
```
* 时间复杂度都是O(log* n) 约等于O(1)    O(n) --路径压缩-->> ≈O(1)
    - log* n --> log2log2log2...n until log*n <=1
    -   | x                    | $ log^{*}n $ |
        |----------------------|--------------|
        | (-∞, 1]              | 0            |
        | (1, 2]               | 1            |
        | (2, 4]               | 2            |
        | (4, 16]              | 3            |
        | (16, 65536]          | 4            |
        | (65536, $2^{65536}$] | 5            |
    - Proof of O(log*n) time complexity of union–find: https://en.wikipedia.org/wiki/Proof_of_O(log*n)_time_complexity_of_union–find
    - Iterated Logarithm: https://en.wikipedia.org/wiki/Iterated_logarithm

* Compression by Rank 按照集合大小压缩? 始终让小集合的根节点指向大集合 TC=O(logn)
    - 一条边的存在 = 父亲的子树大小至少为当前子树大小2倍
    - 高度最多logn

将多叉树的大小存在并查集的哪个节点比较方便? 只有根节点的信息容易查询, 因为当合集合并后,我们只能找到这个合集的根节点。因此最好将集合的信息存在根节点中。
 
LintCode 589: [Connecting Graph]()=实现并查集, 联通分量 skipped this question. No lintcode permission
给定n个图中的节点,一开始节点之间没有边。需要支持操作: connect(a,b) 连接a点和b点       query(a,b) 询问a点和b点是否在图中连通
Example:
    n=5
    query(1, 2) 输出 false 
    connect(1, 2) 
    query(1, 3) 输出 false 
    connect(2, 4) 
    query(1, 4) 输出 true

使用并查集,每次对于a和b,找到各自的根节点A和B,其中需要路径压缩
如果A不等于B,将A树指向B树

LintCode 590: [Connecting Graph II]() skipped this question. No lintcode permission
给定n个图中的节点,一开始节点之间没有边。需要支持操作: connect(a,b), 连接a点和b点     query(a), 询问a点所在连通块的节点个数 (一个集合多大)
Example:
    n=5
    query(1) 输出 1 
    connect(1, 2) query(1) 输出 2 
    connect(2, 4) query(1) 输出 3
使用并查集,每次对于a和b,找到各自的根节点A和B,其中进行路径压缩
根节点记录下自己的子树的节点个数 如果A不等于B,将A树指向B树。B树根节点更新节点个数 
FollowUp: 每个点有权值,问A点所在连通块的权值总和/最大权值  (更新时, sum or max)

在求集合所有元素平均值时, 哪个信息是必须存入根节点的? 集合内元素个数。若只存集合内平均值,两个元素合并时,并不能求出新集合的平均值。只存所有元素之和同样无法求出平均值。但是如果存了集合内平均值以及集合内元素个数,则可以通过计算出两个集合所有元素之和,再除以两个集合元素个数来求两个集合合并后的平均值。存集合所有元素之和以及集合内元素个数同理。因此,无论是存集合内元素之和还是平均值,都需要存集合内元素个数。

LintCode 591: [Connecting Graph III](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Connecting%20Graph%20III.py)
给定n个图中的节点,一开始节点之间没有边。需要支持操作: connect(a,b), 连接a点和b点 query() 询问连通块数目 (集合数目, 有几个根节点)
使用并查集,每次对于a和b,找到各自的根节点A和B,其中进行路径压缩
如果A不等于B,将A树指向B树。连通块数目减1 FollowUp:每个点有权值,问当前所有连通块的最大平均权值

LintCode 434: [Number of Islands II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Number%20of%20Islands%20II.py)
给定一个mxn矩阵,一开始每个格子都是大海(一开始岛屿=0)
给定一些格子要依次改成岛屿,需要返回每次一个格子改成岛屿后,当前连通岛屿的个数 (上下左右联通)
并查集在二维中的拓展(矩阵其实也是图),每个格子作为一个节点。当一个格子变成岛屿,和它的四个邻居依次连接,相当于在图中加四条边

给定n*m的矩阵, 要将k个格子改成岛屿, 那么时间复杂度是多少? O(k) = k log*n。每次将格子变成岛屿时, 只需要做四次加边的操作, 每次加边的复杂度是O(1)。因为只需要将k个格子变成岛屿,因此总时间复杂度是O(k)

LintCode 178: [Graph Valid Tree](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Graph%20Valid%20Tree.py)
给定n个节点和一些无向边,判断是否形成一棵树。
树的边数一定是n-1, 并且形成一个连通块(无环)。但边数为n-1不一定为树
使用并查集,将所有边加入
形成树的两个条件: n-1条边, 最后只有一个连通块 
   
LintCode 1070: [Accounts Merge]() 不会!! 需要再看看！！ skipped this question.
给定一些账户,每个账户有一个用户名和一些关联邮箱。如果两个账户含有相同的关联邮箱,则这两个账户同属于一个人。不同的人可能有相同的用户名。输出合并后的账户,一个人一个账户。
输入: accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"],
["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
输出: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
* Soln 1: 将每个原始账户作为一个node,但是两个账户可以连接取决于它们共享至少一个邮箱,处理起来比较麻烦
    - 两两处理, 但 可能叫John的人很多; 可能一个John有很多邮箱
* Soln 2: 将每个邮箱作为一个node(用hashset储存; 每个节点存储parent和account name信息), 同一个原始账户中的邮箱之间连边。用根节点存储用户名  TC=O(n), n个邮箱
* 灵活定义并查集的节点

LintCode 1396: [Set Union]()  不会!! 需要再看看！！ skipped this question.

LintCode 805: [Maximum Association Set](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Maximum%20Association%20Set.py)
类似 Accounts Merge, 只是少了用户名
需要输出最大的连通块。可以在并查集合并过程中打擂台,也可以在最后每个点找一次根节点。
     
跟连通性有关的问题, 都可以使用 BFS(静态连通性) 和 Union Find (动态联通性, i.e. 加边 -> 查询 -> 加边 -> 查询)
什么时候无法使用 Union Find? 需要拆开两个集合的时候无法使用Union Find (UF无法删除边, i.e.集合拆分)
 
并查集总结
- 合并两个集合 + 查询某个元素所在集合 (路径压缩寻找根节点)
- 动态合并集合与查询节点所在集合, 但不能分拆集合
- 判断两个元素是否在同一个集合 
- 获得某个集合的元素个数
- 统计当前集合个数
- 关键操作:快速寻找根节点

## 2.2. 字典树Trie, Prefix Tree 前缀树
来自单词Retrieval,发音与Tree相同, 用于处理字符串
Trie的考点: 实现一个Trie; 比较Trie和Hash的优劣 (字符矩阵类问题使用Trie更高效)

LintCode 442: [Implement Trie (Prefix Tree)](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Implement%20Trie%20(Prefix%20Tree).py)
假设有[b,abc,abd,bcd,abcd,efg,hii]这7个单词 , 查找abc在不在字典里面
- 若放入hashset, 空间浪费
- Trie一旦分开不在合并 -> 保证trie是一棵树
- Trie树的高度 = 最长字符串 (最长单词的长度)
- 边代表字母; 节点代表从根节点一路走下来形成的字符串 (node存储boolean变量isword)
需要一个新的类TrieNode代表Trie中的节点
Insert 插入一个单词 TC=单词的长度
   
LintCode 473: [Add and Search Word](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Add%20and%20Search%20Word.py)
支持两种字符串操作: 
addWord(word): 加入一个词 
search(word): 搜索一个词,其中可能有".", 代表任何单个字符 ("." -> 所有子节点都要尝试 = Recursion)
addWord使用Trie
searchWord在Trie中DFS,一旦需要”.”字符就遍历所有儿子节点: 走到死胡同or找到了到isword=False, return False
 
### 2.2.1. Trie用于剪枝
LintCode 634: [Word Squares](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Word%20Squares.py) 
给出一系列不重复的单词,找出所有用这些单词能构成的单词平方。单词平方是一个k×k的单词方阵: 第k行的单词和第k列的单词相同
输入: ["area", "lead", "wall", "lady", "ball"]
输出:[["wall", "area", "lead", "lady"],["ball", "area", "lead", "lady"]]
限定: 单词个数<=1000, 单词长度在1到5之间
直接搜索,时间复杂度TC=n×(n-1)×(n-2)×(n-3)×(n-4)=n^5, 最高1000^5 
查找冗余/可以剪枝的部分

剪枝一: 第一个词填了ball后, 第二个词必须以a开头; 第二个词填了area后, 第三个词必须以le开头, 以其他开头的就没必要搜下去了
- 用Hash or Trie树记录下以某个前缀开头的有哪些单词
- 比如以l开头的有lead lady, 以le开头的有lead, 以lea开头的有lead
- 每次只用从特定开头的单词中继续往后搜
剪枝二: 第一个词填了ball, 第二个词想填area的话, 字典中必须有以le和la开头的单词, 否则没有的话就不能填area

递归+剪枝的时间复杂度很难分析, TC=n^5, 但在实际中大大快于n^5

LintCode 132: [Word Search II](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Word%20Search%20II.py)
给定一个小写字母矩阵和一个字典。找到字典中所有在矩阵中出现的词。一个词可以在矩阵中任意位置开始,然后向上下左右一个方向走一步。一个格子在一个 词里只能用一次。
输入:[“doaf”, “agai”, “dcan”] {"dog", "dad", "dgdg", "can", "again"}
输出: {"dog", "dad", "can", "again"}
用Trie存储字典里所有词
在矩阵中DFS时,在Trie里对应节点向下走
Trie可以帮助剪枝
  
### 2.2.2. Typeahead Trie 在系统设计中的运用 (实际运用)

字典树Trie
- 合并所有公共的前缀
- 动态插入与查询单词
- 不能查询非前缀(如字符串一部分)

假设共有n只动物, 每次输入[x, y]代表x与y是同种生物。若n=10, 再输入[[1, 2], [3, 4], [6, 8], [4, 6]]后, 在这n只动物中最多有多少种不同生物? 1与2必然是一种生物, 3468必为同种生物, 而5,7,9,10号动物可能互不相同,因此最多有6种生物

有n个平均长度为k的字符串, 若要构造一个字典树trie并将这些字符串依次插入字典树, 总时间复杂度是多少? 每次将长度为k的字符插入trie中的复杂度是O(k), 将n个平均长度为k的字符插入字典树的复杂度为O(nk)

字典树的节点总数代表? 
从根节点到某一节点。路径上经过的字符串连接起来,就是该节点对应的子串,由于这样获得的每个子串都是不同的,且每个子串都是某个原字符串的前缀。因此,字典树的节点总数即所有字符串本质不同的前缀个数

"ab" "abc" "adc" "cad" "bad" "bd"中有多少不同的前缀? 可以自己构建一棵Trie, 将所有字符串插入字典树, 数其中有多少节点即可。共有a, ab, abc, ad, adc, b, ba, bad, bd, c, ca, cad 共12个本质不同的前缀。

# 3. Heap 堆 & Stack 单调栈

若一个栈的进栈序列是a,b,c,d, 在进栈过程中或进栈结束后有一些出栈操作, 则不可能的出栈序列是?
adcb可以通过push, pop, push, push, push, pop, pop, pop来获得
dcba可以通过push, push, push, push, pop, pop, pop, pop来获得
dcab无法通过入栈和出栈获得
abcd可以通过push, pop, push, pop, push, pop, push, pop来获得

向一个空数组中逐渐添加数字[3, 5, 4, 8, 6], 前1个数, 前2个数.. 前5个数的中位数是多少? 假设数组的中位数为排序后index为(n-1)/2的数字, 其中n为数组长度, index从0开始. 
[3]的中位数为3, [3, 5]的中位数为3, [3, 5, 4]的中位数为4, [3, 5, 4, 8]的中位数为4, [3, 5, 4, 8, 5]的中位数为5, 因此为[3, 3, 4, 4, 5]

在求前1个数, 前2个数..前n个数的中位数时, 可以使用两个堆, 用最大堆维护较小的n/2个数, 用最小堆维护较大的后n/2个数。(K个数的中位数, 本质上就是求第k/2小和第k/2大, 因此对于前k/2个较小的数, 我们需要求出最大值, 因此使用最大堆, 而对于后k/2个数, 我们需要求出最小值, 因此使用最小堆)

若要动态维护第K大的数, 应将前K个数加入最小堆。(每次要看的是当前加入的数与前k大的数中最小的数的大小关系, 因此应将前K个数加入最小堆)

## 3.1. 堆 Heap = 优先队列 Priority Queue
堆 Heap = 优先队列 Priority Queue -> 树的结构
支持操作
* O(1) Min/Max 求最大/最小 (=根的值)
* log(N) Push 插入
* log(N) Pop 删除
python: heapq (最小堆 -> 最大堆, 插入时值取负) Java: PriorityQueue  (可以自定义比较函数) C++: priority_queue
堆存在一维数组里, 根x, 左子2x+1, 右子2x+2 (左子<根, 右子<根)
- 解决动态求最大/小值
- 解决动态第K大/小问题 
- 双堆可以解决动态中位数 (不平衡 -> Balance操作)

LintCode 81: [Find Median from Data Stream]() Data Stream Median
给定N个数, 求前1个数、前2个数...、前N个数的中位数
输入:[4,5,1,3,2,6,0] 输出:[4,4,4,3,3,3,3]
* Soln 1: 每次排序, 取中位数k/2, TC=O(n^2logn)
* Soln 2: QuickSelect, 平均O(n)每次, overall TC=O(n^2)  n个数求中位数(静态) -> quickselect
* Soln 3: 类似插入排序, 寻找中位数:O(n2)
* Soln 4: 
    K个数的中位数, 需要知道第K/2小和第K/2大 (最大堆+最小堆)
    动态(有插入/删除操作)维护中位数一般都是用双堆解决 (同理: 动态维护第K大数)  TC=O(nlogn)
    ```text
    [......, N/2, ......]
    <---------->
        最大
            <---------->
                最小
    * 新数加入最大堆or最小堆
    * 调整堆的平衡
    ```

LintCode 360: [Sliding Window Median]()
给定N个数, 求每连续K个数的中位数
输入:[1,2,7,8,5], K = 3 输出:[2, 7, 7]
和Data Stream Median类似(多一个删除操作), 因为窗口移动需要删除已经不在窗口的元素 
维护第K/2小和第K/2大 (最大堆+最小堆)
堆中存数组的index, 不要存数字 (否则相同的数字不知道删除哪个)
TC=O(nlogn)

LintCode 364: [Trapping Rain Water II]()
给定一个nxm的2D地图每个格子的高度, 求其中可以装多少单位的水
输入: 
[[12,13,0,12],
[13,4,13,12],
[13,8,10,12],
[12,13,12,12],
[13,13,13,13]]
输出:14

- 一个格子高度h, 它上面能盛多少水
    检查所有从这个格子到边界的路径, 每条路径i都有最大高度值Mi
    所有路径最小的Mi值就是这个格子的吃水线, 吃水线-h=盛水量
    max{0, 所有路径最小的Mi值-h} 就是答案, 木桶原理
- 用最小堆维护访问的点, 先访问边界一圈的点 (边界的格子不能装水)
- 每次从最小堆顶拿出点P, 向其周围4个方向上看未曾访问过的点, 如Q
    如果Q的高度<=P的吃水线, 说明Q的吃水线就是P的吃水线, 因为Q是第一次被访问到
    如果Q的高度>P的吃水线, 则说明它不能装水, Q的吃水线就是自身的高度
    将(Q, Q的吃水线)加入Heap中 (堆储存已经求过吃水线的位置)
- TC=mnlog(mn)  m*n个点, 每个点只能被插入堆一次, 每次插入log(mn)
- 堆保证吃水线低的先求, 高的后求 (因此不需要求出所有路径的最小吃水线)

## 3.2. 栈 Stack 
先进后出
计算机中实现递归的方式
支持操作: 
O(1) Push 
O(1) Pop 
O(1) Top

LintCode 12: [Min Stack]()
支持一个栈的push, pop和min操作, 时间复杂度都是O(1)
push(1)
pop() // return 1 
push(2)
push(3)
min() // return 2 
push(1)
min() // return 1

栈的push和pop都是O(1)
求min可以用一个辅助栈minStack, 和stack一样大 (stack插入时, minStack也插入; stack删除时, minStack也删除)
minStack里每个元素表示stack里对应位置元素到栈底的最小值

LintCode 575: [Decode String]()
给定一个表达式, 其中"数字[表达式]"表示方括号里的表达式重复数字次。输出展开的表达式
s = abc3[a] 输出: abcaaa
s = 3[abc] 输出: abcabcabc
s = 4[ac]dy, 输出: acacacacdy
s = 3[2[ad]3[pf]]xyz, 输出: adadpfpfpfadadpfpfpfadadpfpfpfxyz
```text
[.....................]

^                     ^
递归 push             pop   
```
* Soln 1: 可以DFS
* Soln 2: 改成非递归需要栈
    数字和字符都push
        见到"["push当前数字入栈 
        字符直接压栈
        见到"]"就pop字符直到碰到数字A
        这些字符组成的字符串重复A次

[2[3[a]2[bc]]]解码后应为aaabcbcaaabcbc (a重复3次, bc重复两次, 得到aaabcbc; 再把此序列重复2次)

### 3.2.1. 单调栈 Monotonous stack
栈中只保存升序序列 (新元素插入前, pop掉所有比它大的)
stack([1, 2, 8, 10]).push(5) => stack([1, 2, 5])
- 实现非递归  (树的前中后序遍历, 非递归版, 也是常考)
- 单调栈专门解决找一个值左/右第一个比它大/小的值 
- 线性时间复杂度 O(n)

LintCode 122: [Largest Rectangle in Histogram]()
给定直方图中n个柱形的高度, 输出其中最大的矩形
输入:[2, 1, 5, 6, 2, 3] 输出:10
最大矩形一定是某一个柱形往左往右直到不能前进, 形成的矩形
需要知道一个数字往左和往右第一个小于这个数字的位置 (左边第一个比它小的数字的位置 & 右边第一个比它小的数字的位置)
* Soln 1: while loop O(n^2)
* Soln 2: 单调递增栈
    - 压栈时弹出大于等于自己的值 (栈内元素一次变大, 单调递增)
    - 最后停下来时碰到的栈顶就是左边第一个比自己小的值
    - 一个数X被新来的值R弹出栈顶, 那么R就是X右边第一个小于等于X的值
        如果有相同的数, 那么最靠右的bar会求得最大面积 
        最后插入-1
    - 时间复杂度O(N), 每个数只会被压入/弹出栈一次

若现在一个单调栈中的元素为[1, 2, 4, 8], 下一个元素为3, 则将3压入单调栈后, 单调栈内元素为[1, 2, 3] (单调栈在压入一个数之前, 会将栈顶所有大于这个数的元素全部弹出栈, 再将钙元素入栈)

为什么最后要清空栈? 假如给定的长方形高度是[1, 2, 3, 4, 5], 栈内是[1, 2, 3, 4, 5], 答案就不会更新, 清空栈是为了解决这种情况

LintCode 510: [Maximal Rectangle]()
给定一个01矩阵, 求其中最大的全1矩形的面积
输入:
[
  [1, 1, 0, 0, 1],
  [0, 1, 0, 0, 1],
  [0, 0, 1, 1, 1],
  [0, 0, 1, 1, 1],
  [0, 0, 0, 0, 1]
]
输出: 6 
* Soln 1: 枚举左上角, 右下角
* Soln 2: 利用直方图的算法, 以矩阵每一行为直方图的底部, 通过1确定每个柱形的高度, 求出最大全1子矩阵
    时间复杂度O(N^2), 每一行O(n) 共n行
        
LintCode 126: [Max Tree]() not have permission to access this problem, skipped
http://www.jiuzhang.com/solutions/max-tree/
给定一个无重复的整数数组。要求建立一棵二叉树, 
规则如下: 
- 最大值作为二叉树的根
- 最大值分出的左右两段数组分别继续建树, 作为根节点的左右子树
输入:[2, 5, 6, 0, 3, 1] 输出: TN(6, [TN(5, [TN(2, None)]), TN(3, [TN(0, None), TN(1, None)])])

* Soln 1: for-loop 找最大值
* Soln 2: 
    每个值X的父亲一定是min{左边第一个比它大的值L, 右边第一个比它大的值R}
    - ....., L, < X, ...,< X, X, < X, ..., < X, R,...
    - 如果L < R, [L, R]里一定R先做根。然后[L, R)里L先做根, 然后就是X 
    - 如果L > R, [L, R]里一定L先做根。然后(L, R]里R先做根, 然后就是X
    如何找到每个值左右第一个比它大的值? 单调递减栈

# 4. Sweep Line 处理区间问题的扫描线 & Binary Search 二分答案 & Deque 双端队列

## 4.1. Sweep Line 扫描线算法 -- 区间问题巧妙解法
扫描问题的特点
1. 事件往往是以区间的形式存在
2. 区间两端代表事件的开始和结束
3. 按照区间起点排序, 起点相同的按照终点排序

扫描线要点: 将起点和终点打散排序
[[1,3], [2,4]] => [[1,start],[2,start],[3,end],[4,end]]

LintCode 391: [Number of Airplanes in the sky]() 扫描线经典入门题目
给定n架飞机的起飞降落时间, 求最多时天上有多少飞机; 如果一架飞机的降落时间恰好等于另一架飞机的起飞时间, 则认为先降落
输入:[[1,10], [2,3], [5,8], [4,7]] 
输出: 3

- 将每架飞机的起降时间作为区间左右端点, 建立两个事件
- 对所有事件排序, 相同时间的事件降落排在起飞前面
- 扫描线, 定义计数器C=0 
- 遇到起飞事件, C+=1 
- 遇到降落事件, C-=1
- C的最大值即为答案
- FollowUp: 如果同时起降, 认为先起飞, 怎么修改算法 

LintCode 131: [Building Outline]()
给定n个矩形的坐标, 底边都在X轴 - 求出所有矩形组成图形的外轮廓线
输入: [[2910], [3715], [51212], [152010], [19248]]
输出: [[2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0]]

- 将每个矩形的左边和右边建立两个事件, 记下对应高度
- 对所有事件按X坐标排序
- 建立高度的最大堆
- 扫描线
- 遇到左边事件, 堆中加入高度
- 遇到右边事件, 堆中删除高度
- 堆中最大值即为组合图形现在的高度
- 将同一个X坐标的事件全部处理完后, 如果新高度≠原来的高度, 说明出现拐点,  记录下来

类似 Number of Airplanes in the Sky 的一题
https://www.lintcode.com/problem/meeting-rooms-ii/
F家高频题:输出两组区间的交集 https://www.lintcode.com/problem/time-intersection/
Building Outline 的算法动图模拟 https://briangordon.github.io/2014/08/the-skyline-problem.html

## 4.2. 二分法难题 Binary Search (Hard)
LintCode 75: [Find Peak Element]()
https://www.lintcode.com/problem/find-peak-element/ https://www.jiuzhang.com/solutions/find-peak-element/
给定A[0..n-1], 其中没有相邻元素相同, 并且A[0]<A[1], A[n-2]>A[n-1] 
找到任意一个P, 满足A[P-1]<A[P]>A[P+1]
输入:[1,5,6,8,7,9,4] 
输出:3

- 首先, 这样的P肯定存在
- 因为A[0]<A[1], 如果A[1]不是要找的元素, A[1]<A[2]; A[2]<A[3]; ...
- 但是A[n-2]>A[n-1]
- 二分查找, 对于mid位置, 如果A[mid]<A[mid+1], 继续向右找;否则向左
   
二分答案 Binary Search on Result
往往没有给你一个数组让你二分 同样是找到满足某个条件的最大或者最小值

解题方法 通过猜值判断是否满足题意不对去搜索可能解
1. 找到可行解范围 
2. 猜答案
3. 检验条件
4. 调整搜索范围

[Sqrt(x)]()
https://www.lintcode.com/problem/sqrtx/ https://www.jiuzhang.com/solutions/sqrt-x Last number that number^2 <= x
follow up: what if return a double, not an integer?
[Sqrt(x) II]()
https://www.lintcode.com/problem/sqrtx-ii/ https://www.jiuzhang.com/solution/sqrtx-ii/
一直二分直到 |number^2 - x| <= 1e-10

LintCode 183: [Wood Cut]()
https://www.lintcode.com/problem/wood-cut/ https://www.jiuzhang.com/solutions/wood-cut/
给定n块木头, 长度分别是L[0]..L[n-1]. 要求找到最长的长度s, 使得这些木头可以切出至少k块长度为s的木头
输入: L=[232, 124, 456], k=7 输出:114

- 首先, 我们发现, 对于一个长度s, 如果可以切出t段;而对于另一个长度S>s,可 以切出T段, 则一定有t>=T
- 所以如果长度s切出的段数不够k, 答案肯定比s小è二分答案!
- 同理, 如果长度s切出的段数>=k, 答案肯定>=s
- 时间复杂度:O(nlogL)

LintCode 437: [Copy Books]()
https://www.lintcode.com/problem/copy-books/ https://www.jiuzhang.com/solutions/copy-books/
有N本书需要被抄写, 第i本书有A, i=0, 1, ..., N-1; 有K个抄写员, 每个抄写员可以抄写连续的若干本书(例如:第3~5本书, 或者第
10本书); 每个抄写员的抄写速度都一样, 最少需要多少时间抄写完所有的书
输入: A = [3, 2, 4], K=2  输出: 5 (第一个抄写员抄写第1本和第2本书, 第二个抄写员抄写第3本书) 

- 题目要求K个抄写员抄完最少需要的时间
- 反过来想, 如果我们限定时间不超过T, 最少需要的抄写员
- 这个问题比较好做, 贪心法
- 从第一本书开始, 第一个人一直抄到时间即将超过T - 第二个人, ...
- 如果需要的抄写员>K, 说明答案一定>T; 反之答案<=Tè二分答案
  
LintCode 633: [Find The Duplicate Number]()
https://www.lintcode.com/problem/find-the-duplicate-number/ https://www.jiuzhang.com/solutions/find-the-duplicate-number/
给定一个长度为n+1的数组, 其中均为1到n之间的整数; 保证只有一个数字重复了多次; 找到这个数字 (辅助空间只能O(1))
输入: [5,5,5,1,2,3] 输出: 5

- 假设答案是S, 数组一定是(假设排好序):[1,3,...,S,...,S,S+1,...,n], 那么其中<=S的数大于S
- 而且对于所有T>=S, <=T的个数大于T
- 而对于所有T<S, <=T的个数小于等于T
- 二分法 O(nlog2n) 

LintCode 617: [Maximum Average Subarray II]() 二分答案的典型题目
https://www.lintcode.com/problem/maximum-average-subarray-ii/ https://www.jiuzhang.com/solutions/maximum-average-subarray- ii/
给定一个数组A, 找到其中平均值最大的子数组, 要求长度>=k
输入: [1, 12, -5, -6, 50, 3], k = 3  输出: 15.667   (-6+50+3)/3=15.667

- 如果要求和最大, 可以用前缀和数组。但是平均值最大不好求
- 那么如果最大平均值是T, 那么我们的目标是找到
- (A[left] + ... + A[right]) / (right - left + 1) >= T, 且right - left + 1>= k - 即(A[left]-T) + ... + (A[right]-T) >= 0
- 换句话说, 对于一个T, 把每个元素A[i]减去T得到B[i]
- 希望找到最大的B[left] + ... + B[right] >= 0, 且right - left + 1>= k
- 这可以通过前缀和实现
- 如果找不到这样的(left, right), 说明答案小于Tè二分答案  

## 4.3. Deque 双端队列 (两端都会有push和pop)

LintCode 362: [Sliding Window Maximum]() 常考题, 滑动窗口经典题型
https://www.lintcode.com/problem/sliding-window-maximum/ https://www.jiuzhang.com/solutions/sliding-window-maximum/
给定一个数组A, 找到其中每个大小为k的窗口中最大值
输入: [1, 2, 7, 7, 8], k = 3  输出: [7, 7, 8]

- 类似单调栈, 但是两端都有操作
- 基本思想:如果A[i]<=A[j], 且i<j, 那么A[i]就没有用了, 即以后永远不会成为窗口最大值
- 窗口向右移动, 左端元素移出队首(如果仍在队列中), 右端元素A[j]移进队尾, 
并删除所有<=A[j]的A[i]
- 时间复杂度O(N)

总结 
- 扫描线: 见到区间需要排序就可以考虑扫描线 
- 二分法: 按值二分, 找到单调的地方 
- 双端队列: 维护一个候选可能的最大值集合

[Debug的基本步骤](http://www.jiuzhang.com/qa/3815/)
```text
为什么Debug一定要靠自己？
- 如果是别人给你指出你的程序哪儿错了, 你自己不会有任何收获, 你下一次依旧会犯同样的错误
- 经过长时间努力Debug获得的错误, 印象更深刻
- Debug能力是面试的考察范围
- 锻炼Debug能力能够提高自己的Bug Free的能力

Debug的基本步骤
- 重新读一遍程序。按照自己当初想的思路, 走一遍程序, 看看程序是不是按照自己的思路在走。（因为很多时候, 你写着写着就忘了很多事儿）这种方式是最有效最快速的Debug方式
- 找到一个非常小非常小的可以让你的程序出错的数据。比如空数组, 空串, 1-5个数的数组, 一个字符的字符串
- 在程序的若干位置输出一些中间结果。比如排序之后输出一下, 看看是不是真的按照你所想的顺序排序的。这样可以定位到程序出错的部分
- 定位了出错的部分之后, 查看自己的程序该部分的逻辑是否有错
- 在第4步中, 如果无法通过肉眼看出错误的部分, 就一步步“模拟执行”程序, 找出错误

实在Debug不出来怎么办？
- 如果你已经Debug了一整天, 可以考虑向他人求助
```

# 5. DP 滚动数组 划分,博弈 和区间型

# 6. DP 双序列与背包


# 7. 面试中较难的Follow Up问题 -- Iterator, Subarray Sum, Wiggle Sort
非递归的方式实现递归

若给定一个整数序列a, 前缀和数组S[i]=a[0]+a[1]..+a[i]. 若a[i]+..+a[j]=0, 则S[j]-S[i-1]=0

给矩阵a, 矩阵的二维前缀和S[n][m]为以(0,0)为左上端点, (n,m)为右下端点的矩形内 (包括边界)的所有元素之和. 那么以(x1, y1)为左上端点, 以(x2, y2)为右下端点的矩形内(包括边界)的所有元素之和为S[x2][y2]-S[x1-1]S[y2]-S[x2]S[y1-1]+S[x1-1]S[y1-1]

## 7.1. Subarray sum及FollowUp
LintCode 138: [Subarray sum]()
http://www.lintcode.com/problem/subarray-sum/ http://www.jiuzhang.com/solutions/subarray-sum/
给定N个数, 找到一段子数组使得和是0
输入:[-3, 1, 2, -3, 4] 输出:[0, 2]
  
利用前缀和, A[i] +...+ A[j] = S[j] – S[i - 1] 如果A[i] +...+ A[j]=0, 说明S[j]=S[i-1]
利用哈希表

LintCode 139: [Subarray Sum Closest]()
https://www.lintcode.com/problem/subarray-sum-closest/ https://www.jiuzhang.com/solution/subarray-sum-closest/
给定N个数, 找到一段子数组使得和最接近0
输入:[-3, 1, 1, -3, 5] 输出:[0, 2]
  
利用前缀和, A[i] +...+ A[j] = S[j] – S[i - 1]
S[j]与S[i-1]差得越小, A[i] +...+ A[j]越接近0
将所有S值从小到大排序, 检查每个相邻的对子
 
LintCode 405: [Submatrix Sum]()
http://www.lintcode.com/problem/submatrix-sum/ http://www.jiuzhang.com/solutions/submatrix-sum/

给定一个整数矩阵, 找到一个子矩阵使得数字之和为0 
输入:
– [[1 ,5 ,7],
– [3,7,-8],
– [4,-8,9]] 输出:
– [(1, 1), (2, 2)]
枚举子矩阵的上边界U, 下边界D
将U和D之间的数按照列求和, 然后仿照Subarray Sum解决 时间复杂度O(N3)

LintCode 404: [Subarray Sum II]()
http://www.lintcode.com/problem/subarray-sum-ii/ http://www.jiuzhang.com/solutions/subarray-sum-ii/
给定一个正整数数组, 求出在所有子数组中, 数字之和在给定区间内的个数 
输入: [1, 2, 3, 4] 范围 [1, 3] 输出: 4

利用前缀和, A[i] +...+ A[j] = S[j] – S[i - 1]
A都是正整数àS严格递增
每个S[j]要找到在[S[j]-end, S[j]-start]中的S[i]个数 – 同向双指针!
时间复杂度:O(N)
 
## 7.2. Continuous Subarray Sum 及FollowUp
LintCode 402: [Continuous Subarray Sum]()
www.lintcode.com/problem/continuous-subarray-sum/
http://www.jiuzhang.com/solutions/continuous-subarray-sum/
给定一个整数数组, 求出在所有子数组中, 数字之和最大的一个 
输入: [-3, 1, 3, -3, 4] 输出: [1, 4]
  
利用前缀和, A[i] +...+ A[j] = S[j] – S[i - 1] 每个S[j]需要找到之前最小的S[i-1]
时间复杂度:O(N)

LintCode 403: [Continuous Subarray Sum II]()
http://www.lintcode.com/problem/continuous-subarray-sum-ii/ http://www.jiuzhang.com/solutions/continuous-subarray-sum-ii/
给定一个循环整数数组, 求出在所有子数组中, 数字之和最大的一个 
输入: [3, 1, -100, -3, 4] 输出: [4, 1]

先按照Continuous Subarray Sum求出无环情况下的最大非空子数组和S1
再用类似方法求出无环情况下的最小非空子数组和S2
答案即为max{S1, total_sum – S2}
特殊情况:如果选择了最小非空子数组而它是整个数组, 那么选取无环情况下 的最大非空子数组和S1
时间复杂度:O(N)
 
## 7.3. Partition Follow Up
Quick Select
  
LintCode 5: [Kth Largest]()
http://www.lintcode.com/problem/kth-largest-element/ 
http://www.jiuzhang.com/solutions/kth-largest-element/
PriorityQueue
时间复杂度O(nlogk) 更适合动态维护Topk
QuickSelect
时间复杂度O(n) 更适合静态第k大
 
LintCode 508: [Wiggle Sort]()
http://www.lintcode.com/problem/wiggle-sort/ http://www.jiuzhang.com/solutions/wiggle-sort/

给定一个数组, 要求按照如下条件排 nums[0]<=nums[1]>=nums[2]<=nums[3]....
输入: [3,5,2,1,6,4] 输出: [1,6,2,5,3,4]
要求nums[0] <= nums[1] >= nums[2] <= nums[3]...., 即: 当i为奇数时, nums[i] >= nums[i - 1]; 当i为偶数时, nums[i] <= nums[i - 1]
从左到右, 依次处理每个数字
如果和条件不满足, 与之前的数交换位置 时间复杂度O(N)

LintCode 507: [Wiggle Sort II]()
http://www.lintcode.com/problem/wiggle-sort-ii/ http://www.jiuzhang.com/solutions/wiggle-sort-ii/
给定一个数组, 要求按照如下条件排 nums[0]<nums[1]>nums[2]<nums[3]....
输入: [3,5,2,1,6,4] 输出: [1,6,2,5,3,4]
如果获得了中位数, 小于中位数的放在nums[0,2,4,..], 大于中位数的放在 nums[1,3,5,...]
用quickselect获得中位数:O(N)
 
LintCode 399: [Nuts & Bolts Problem]()
http://www.lintcode.com/problem/nuts-bolts-problem/ http://www.jiuzhang.com/solutions/nuts-bolts-problem/
给定一组 n 个不同大小的 nuts 和 n 个不同大小的 bolts
nuts和bolts一一匹配。不允许将nut之间互相比较, 也不允许将bolt之间互相
比较, 只许将 nut 与 bolt 进行比较,  或将 bolt 与 nut 进行比较
输出对应的 nuts 与 bolts
输入: Given nuts = ['ab','bc','dd','gg'], bolts = ['AB','GG', 'DD', 'BC']
输出: 一种可能输出: nuts = ['ab','bc','dd','gg'], bolts = ['AB','BC','DD','GG']

如果nuts之间可以比较, bolts之间可以比较, 那么就可以分别快速排序。只能 比较nuts和bolts, 就可以利用一方排序另一方
先用bolts中的任意一个, B, 去将nuts分成三部分: – 小于B的nuts;正好对应B的nut;大于B的nuts
然后用这个中间的nut, N, 去将bolts分成三部分: – 小于N的bolts;B;大于N的bolts
分别递归
平均时间复杂度:O(nlogn) 

## 7.4. Iterator Problem
Iterator is Non-recursion
必须要用的一个数据结构是什么? 栈
LintCode 22: [Flatten List]()
http://www.lintcode.com/problem/flatten-list/ http://www.jiuzhang.com/solutions/flatten-list/
给定一个列表, 该列表中的每个要素要么是列表, 要么是整数 要求将其扁平化, 即变成一个只包含整数的简单列表
要求不使用递归
输入: [4,[3,[2,[1]]]] 输出: [4,3,2,1]

如果可以使用递归, 遇到整数就塞入结果, 遇到list就递归 不使用递归, 可以用栈模拟
– 遇到整数就输出, 遇到list就将本层iterator塞入栈, 然后处理list的iterator

  
LintCode 528: [Flatten Nested List Iterator]()
http://www.lintcode.com/problem/flatten-nested-list-iterator/ http://www.jiuzhang.com/solutions/flatten-nested-list-iterator/
给定一个列表, 该列表中的每个要素要么是列表, 要么是整数
要求输出一个扁平化后的iterator, 即如果不停调用这个iterator的getNext(), 
返回只包含整数的简单列表
要求不使用递归
输入: [4,[3,[2,[1]]]] 输出:(反复调用iterator) [4,3,2,1]
  
和Flatten List想法类似,  使用栈
先将List里的元素倒序放入栈, 即List第一个元素在栈顶
每次调用getNext时
– 遇到整数输出结果并pop
– 遇到list就倒序放入栈, 继续, 直到遇到整数

LintCode 601: [Flatten 2D Vector]()
http://www.lintcode.com/problem/flatten-2d-vector/ http://www.jiuzhang.com/solutions/flatten-2d-vector/
给定一个二维列表
要求输出一个扁平化后的iterator, 即如果不停调用这个iterator的getNext(), 
返回只包含整数的简单列表
要求不使用递归
输入: [[1,2], [3], [4,5,6]] 输出:(反复调用iterator) [1,2,3,4,5,6]

存储Input List的iterator i
i每次后移一位, 代表处理下一个一维链表
元素的iterator为j
– j一开始指向i指向链表的第一个元素
– 每次如果j是null, 就后移i, j指向i所指链表的第一个元素
类似二维for loop

LintCode 86: [Binary Search Tree Iterator]()
http://www.lintcode.com/problem/binary-search-tree-iterator/ http://www.jiuzhang.com/solutions/binary-search-tree-iterator/
给定一个二叉搜索树, 要求输出一个扁平化后的iterator, 即如果不停调用这个iterator的getNext(), 
返回整棵树中数字, 按照从小到大的顺序, 即按照树的中序遍历
要求不使用递归, hasNext和next的平摊时间复杂度O(1)
输入: 输出:(反复调用iterator) – [1, 6, 10, 11, 12]
  
用栈模拟中序遍历dfs
首先将root, root的左儿子, root的左儿子的左儿子, ...依次放入栈
每次输出栈顶p
– 如果栈顶p有右儿子r, 将r, r的左儿子, r左儿子的左儿子, ...依次放入栈
– 如果栈顶p没有右儿子, 则不停pop栈顶, 直到栈为空, 或者刚pop的元素是新任栈 顶的左儿子
 

Follow Up 常见方式
* 一维转二维 (可以套相同的思路试一试)
    Trapping Water I/II
    Subarray Sum/Submatrix Sum
* 数组变成循环数组 (循环数组小技巧)
    Continuous Subarray Sum 
* 题目条件加强 (可能题目的解题方法会变化) 
    Wiggle Sort I/II
* 换马甲 (变一个描述, 本质不变)
    Number of airplanes on the Sky/ Meeting Room
    Backpack Problem
* 描述完全不一样, 但是方法相同 这种题目得去分析
    Quick Sort/ Bolts and Nuts Problem


# 8. 课程总结



# 9. 面试

## 9.1. 电话面试
难度 < onsite
- 自我介绍
- 要和面试官保持一个沟通的状态 (Think Loud)
    说出现在的想法和思路
    用例子来clarify题目
- 提前熟悉CodePad, GoogleDoc 等
- 问面试官的问题

## 9.2. onsite 现场面授
1轮一小时, 一天4-7轮, 无轮间休息时间 (上午2-3轮, 午饭, 下午2-3轮, 最后一轮有时是manager, 问问软实力和past expirence)
whiteboard coding, laptop coding, 有时需要编译,运行,通过测试 (实在做不出来, 可以要提示)

- 保持交流
    - 面试者如何表达想法
    - 面试者遇到困难怎么办


## 9.3. onsite 后
- 没offer (问原因)

- 有offer
    - 约时间谈包裹 (谈判不要超过2轮)
        - 准备其他包裹细节 (以及现在工作的待遇)
            - 基本工资
            - bonus (target 15%..)
            - signon bonus 签字费
            - stock/option (vest细节)
            - relocation fee 搬家费

        - match (competing offer)
    - background check