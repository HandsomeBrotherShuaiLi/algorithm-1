<!-- TOC -->

- [1. Follow Up](#1-follow-up)
    - [1.1. 同向双指针](#11-%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88)
    - [1.2. 求第K大/小元素 (单个数组, 多个数组, 矩阵)](#12-%E6%B1%82%E7%AC%ACk%E5%A4%A7%E5%B0%8F%E5%85%83%E7%B4%A0-%E5%8D%95%E4%B8%AA%E6%95%B0%E7%BB%84-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84-%E7%9F%A9%E9%98%B5)
    - [1.3. Follow Up问题的出题规律](#13-follow-up%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%BA%E9%A2%98%E8%A7%84%E5%BE%8B)
- [2. Union Find 集合的合并查找操作，并查集  & Trie 字典树](#2-union-find-%E9%9B%86%E5%90%88%E7%9A%84%E5%90%88%E5%B9%B6%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C%E5%B9%B6%E6%9F%A5%E9%9B%86---trie-%E5%AD%97%E5%85%B8%E6%A0%91)
- [3. Heap 双端队列 & Stack 单调栈](#3-heap-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97--stack-%E5%8D%95%E8%B0%83%E6%A0%88)
- [4. Binary Search 二分答案 & Sweep Line 处理区间问题的扫描线](#4-binary-search-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88--sweep-line-%E5%A4%84%E7%90%86%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E7%9A%84%E6%89%AB%E6%8F%8F%E7%BA%BF)
- [5. DP 滚动数组 划分，博弈 和区间型](#5-dp-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84-%E5%88%92%E5%88%86%E5%8D%9A%E5%BC%88-%E5%92%8C%E5%8C%BA%E9%97%B4%E5%9E%8B)
- [6. DP 双序列与背包](#6-dp-%E5%8F%8C%E5%BA%8F%E5%88%97%E4%B8%8E%E8%83%8C%E5%8C%85)
- [7. Follow up](#7-follow-up)

<!-- /TOC -->

* 做题的常见误区: 做题获得Accepted就可以了? 看答案抄一遍然后就会了?
* 导致的结果: 做过的题面试中居然还不会; 觉得新题越来越多

* 一题三省: 有哪些类似的题, 他们之间的共通点是什么? 这个题主要考察的是算法思想还是实践能力? 我做题的过程顺利吗, 是否需要再联系一次?
* 如何准备 Follow Up: 定期整理做过的题目, 归类相似问题
    - 题目中哪些条件可以看出这是同类题?
    - 同类题目在思维方式上有什么相似之处?
    - 同类题目在代码实现上有什么相似之处?

# 1. Follow Up
Follow Up问题: 从原题出发, 加/减/改条件 (1D -> 2D)

选择题没整理... TODOs

## 1.1. 同向双指针
LintCode 406: [Minimum Size Subarray Sum](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Minimum%20Size%20Subarray%20Sum.py)
Given an array of n positive integers and a positive integer s, 
find the minimal length of a contiguous subarray of which the sum ≥ s. 最短的连续一段
If there isn't one, return 0 instead. 正整数 连续一段 数字和
* Soln 1: 双指针 i=start, j=end, 枚举sum>S, 长度j-i+1, TC=O(枚举开始×枚举结束×枚举sum)=O(n×n×n)=O(n^3)
* Soln 2: 前缀和数组, prefix sum array, S[j]=a0+...aj, i到j的和为S[j]-S[i-1], TC=O(n^2), 两个for loop
* Soln 3: 同向双指针, 每次删除左指针左边的数字; 只要当前和小于s, 右指针继续向右移动
	for loop + while loop; 右指针往右, 左指针不可能往左 TC=O(左指针移动的次数+右指针移动的次数)=O(n+n)=O(n)
	Note: 有for/while的loop, TC不一定为O(n)

LintCode 384: [Longest Substring Without Repeating Characters](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Longest%20Substring%20Without%20Repeating%20Characters.py)
Given a string, find the length of the longest substring without repeating characters. 最长无重复

固定左指针, i往右移; j可能不动或者往右(不可能往左) --> 同向双指针
i每次往右一步(for loop主指针); j每次往右一步/几步/不动(while loop辅指针)
需要记录两指针中间每个字符出现的次数(均<=1, 0或1); 若右指针下一个字符出现次数为0, 就可以向右移动

使用一个size为26的数组记录各字符出现次数(数组内的值为0或1); 也可以用hashset, 但推荐用array/list, 因为虽然数量级的TC一样, 但是常数项不一样。array为1次, 但是hashmap可能为3次..10次等等。

主指针将数组对应位置-1, 副指针检查数组对应位置是否为0

LintCode 32: [Minimum Window Substring](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Minimum%20Window%20Substring.py)
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). 最短子串

C: 集齐B中字母种类, 阈值处理
同向双指针, 记录每个字符ch在两个指针中间出现的次数freq[ch]
如果ch在T中出现w次, 一旦freq[ch]增加到w, 记录这个字符被完成了
如果ch要从区间中一走, freq[ch]减少到w-1, 记录这个字符没被完成

完成的字符数=T中不同字符数 -> 当前区间包含组成T的所有字符

LintCode 386: [Longest Substring with At Most Two Distinct Characters](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Longest%20Substring%20with%20At%20Most%20Two%20Distinct%20Characters.py)
Given a string s, find the length of the longest substring t that contains at most 2 distinct characters.

[Longest Substring with At Most K Distinct Characters](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Longest%20Substring%20with%20At%20Most%20K%20Distinct%20Characters.py)
Given a string, find the length of the longest substring T that contains at most k distinct characters.
同向双指针, 记录每个字符ch在两个指针中间出现的次数freq[ch]
一旦freq[ch]增加到1, 记录这个字符出现了
一旦freq[ch]减少到0, 记录这个字符不再出现
出现的字符<=K --> 用当前区间长度更新最优解

同向双指针:
* 主指针 -> for, 副指针 -> while
* 记录每个字符ch在两个指针中间出现的次数freq[ch]
* 当freq[ch]增加/减少到临界值, 修改满足条件的字符数

**快慢指针**
[Remove Nth Node From End of List](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Remove%20Nth%20Node%20From%20End%20of%20List.py) 快指针先走N步, 慢指针在开始

[Middle of the Linked List](https://github.com/bitterengsci/algorithm/blob/master/九章算法/强化班LintCode/Middle%20of%20the%20Linked%20List.py) 快指针走两步, 慢指针走一步

## 1.2. 求第K大/小元素 (单个数组, 多个数组, 矩阵)
LintCode 461: [Kth Largest Element in an Array]()
* Soln 1: 排序O(nlogn) --> 取k-th
* Soln 2: QuickSelect, 每次用当前区间中间的数字P作为pivot; 小于P的放左边, 大于P的放右边
    如果左边的数字个数 >= k, 递归左边; 如果左边数字个数+1 < k, 递归右边, k -= 左边数字个数+1; 否则输出P
    平均时间复杂度O(n), randomly-ordered array
    最差时间复杂度O(n^2)

**QuickSelect**
QuickSelect is similar to QuickSort as both of them are Divide & Conquer algorithms and use Partition to divide the array.
* Partition: take an array (a) and two integers for the beginning and the end of the array (l, r) and choose the last element of the array as a pivot, then it sorts the array putting the pivot in the right place, so that all the elements that are smaller than the pivot on left of it and all elements that are larger than the pivot on the right of it, then returns the index of the pivot.

```python
def partition(nums, left, right):
    x = nums[r]   # pick right as pivot
    i = left - 1
    for j in range(left, right):
        if nums[j] <= x:
            i = i + 1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i + 1], nums[r] = nums[r], nums[i + 1]
    return i + 1
```

**TODO!!!!!!!!!!!!!!!!!!!!!**

LintCode 543: [kth largest in n arrays]() 多个数组  no corresponding leetcode one, skipped this question.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
先将n个数组各自排序, 评价每个数组长度为m, TC=O(n×mlogm), 然后将每个数组最后一个元素放入优先队列(最大堆, 插入删除logN, 求最大O(1))
每次从堆中取出一个数字, 加入他所在数组的前一个数字 (堆的大小永远为n) -> 做k次
时间复杂度O(klogN+nmlogm)

LintCode 1272: [Kth Smallest Element in a Sorted Matrix]() 排序矩阵
Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.
[[1, 5, 9],     左上角的1必定为最小
[10, 11, 13],       
[12, 13, 15]]
k=8

类似n个数组求第k小, 从左上角开始, 每次从堆中取出一个数字, 加入他右方和下方的数字(如果还没有加入的话) -> 删1个, 加最多两个; 堆最大为k(插入为O(logk))
时间复杂度O(klogk)

LintCode 465: [kth smallest sum in two sorted arrays]() no corresponding leetcode one, skipped this question.
[1, 7, 11], [2, 4, 6]
1+2 1+4 1+6     行递增, 列也递增, --> 递增矩阵求第k小
7+2 7+4 7+6
11+2 11+4 11+6  
M[i, j] = A[i]+ B[j] --> 不需要开一个n*m的数组, 每次计算即可
时间复杂度O(klogk)


## 1.3. Follow Up问题的出题规律
如果我是面试官:
a) 两个包含正整数的数组, 求两两之积的第K小  (两数组排序 -> 递增矩阵)
b) BST上求从小到大第K个 (先求各node子树大小, 递归一遍)
c) 在一个最小堆里(no built-in delete operation)求从小到大第K个 

变化数据结构:
- 1个array -> 多个array
- sorted array -> unsorted array/k sorted array/k unsorted array
- two sorted arrays, sorted matrix
- binary search tree, linked list


# 2. Union Find 集合的合并查找操作，并查集  & Trie 字典树
假设有n个元素，每个元素分别属于某个集合，并且使用并查集来存储这些信息。不带路径压缩的并查集和带路径压缩的并查集，合并两个集合的平均时间复杂度? O(n), O(1)
使用路径压缩的并查集会在find()时将所有经过的元素全部指向根节点, 因此平均时间复杂度可以优化至O(1)

假设共有n只动物, 每次输入[x, y]代表x与y是同种生物。若n=10, 再输入[[1, 2], [3, 4], [6, 8], [4, 6]]后, 在这n只动物中最多有多少种不同生物? 1与2必然是一种生物, 3468必为同种生物, 而5，7，9，10号动物可能互不相同，因此最多有6种生物

有n个平均长度为k的字符串, 若要构造一个字典树trie并将这些字符串依次插入字典树, 总时间复杂度是多少? 每次将长度为k的字符插入trie中的复杂度是O(k), 将n个平均长度为k的字符插入字典树的复杂度为O(nk)

字典树的节点总数代表? 
从根节点到某一节点。路径上经过的字符串连接起来，就是该节点对应的子串，由于这样获得的每个子串都是不同的，且每个子串都是某个原字符串的前缀。因此，字典树的节点总数即所有字符串本质不同的前缀个数


Connecting Graph II
将多叉树的大小存在并查集的哪个节点比较方便? 只有根节点的信息容易查询, 因为当合集合并后，我们只能找到这个合集的根节点。因此最好将集合的信息存在根节点中。

Connecting Graph III
Follow Up
在求集合所有元素平均值时, 哪个信息是必须存入根节点的? 集合内元素个数。 若只存集合内平均值，两个元素合并时，并不能求出新集合的平均值。只存所有元素之和同样无法求出平均值。但是如果存了集合内平均值以及集合内元素个数，则可以通过计算出两个集合所有元素之和，再除以两个集合元素个数来求两个集合合并后的平均值。存集合所有元素之和以及集合内元素个数同理。因此，无论是存集合内元素之和还是平均值，都需要存集合内元素个数。


Number of Island
给定n*m的矩阵, 要将k个格子改成岛屿, 那么时间复杂度是多少? O(k) = k log*n。每次将格子变成岛屿时, 只需要做四次加边的操作, 每次加边的复杂度是O(1)。因为只需要将k个格子变成岛屿，因此总时间复杂度是O(k)



"ab" "abc" "adc" "cad" "bad" "bd"中有多少不同的前缀? 可以自己构建一棵Trie, 将所有字符串插入字典树, 数其中有多少节点即可。共有a, ab, abc, ad, adc, b, ba, bad, bd, c, ca, cad 共12个本质不同的前缀。



# 3. Heap 双端队列 & Stack 单调栈


# 4. Binary Search 二分答案 & Sweep Line 处理区间问题的扫描线



# 5. DP 滚动数组 划分，博弈 和区间型

# 6. DP 双序列与背包


# 7. Follow up
非递归的方式实现递归


