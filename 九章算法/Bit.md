
<!-- TOC -->

- [1. Bit Manipulation 位运算](#1-bit-manipulation-%E4%BD%8D%E8%BF%90%E7%AE%97)
    - [1.1. Conversion](#11-conversion)
    - [1.2. Operations](#12-operations)
    - [1.3. 位运算在面试中的基本应用](#13-%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8)
    - [1.4. 位运算在面试中的常见技巧](#14-%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7)
    - [1.5. Questions](#15-questions)

<!-- /TOC -->

# 1. Bit Manipulation 位运算

## 1.1. Conversion
* 十进制转换二进制 decimal numeral system, base-ten positional numeral system (denary/decanary)
    * built-in bin(18)
    *   ```Python
        def bin(x):
            if x == 0: 
                print(0)

            def gen(num):
                while num > 0:
                    yield num % 2
                    num = num >> 1
            
            l = [ i for i in gen(abs(x))]
            if x > 0:
                print ('%d' * len(l) % tuple(reversed(l)))
            if x < 0:
                print ('-' + '%d'* len(l) % tuple(reversed(l)))
        ```
* 二进制转换十进制 binary number converts to decimal form
    * int(str(num), b)	  # 将base-b的num转换为10进制


## 1.2. Operations
Note: (x)b 表示 x 是 b 进制 (base)
* **按位与操作 A & B**
    将A和B的二进制表示的每一位进行与操作, 只有两个对应的二进制位都为1时, 结果位才为1, 否则为0.
    1 & 1 = 1, 1 & 0 = 0, 0 & 1 = 0, 0 & 0 = 0
    e.g. A = (10)10 = (001010)2, B = (44)10 = (101100)2
    A & B = 10 & 44 = 001010 & 101100 = (001000)2 = (8)10
    你可能会问为什么这里10对应的二进制是001010, 而不是1010? 这是因为对于空缺的位置使用0去补足即可
    所以10和44进行&运算的结果是8

* **按位或操作 A | B**
    将A和B的二进制表示的每一位进行或操作, 只要两个对应的二进制位有一个为1, 结果位就为1, 否则为0.
    1 | 1 = 1, 1 | 0 = 1, 0 | 1 = 1, 0 | 0 = 0
    e.g. A = (10)10 = (001010)2, B = (44)10 = (101100)2
    A | B = 10 | 44 = 001010 | 101100 = (101110)2 = (46)10  所以10和44进行|运算的结果是46

* **按位异或操作 A ^ B**
    将A和B的二进制表示的每一位进行异或操作, 如果对应的二进制位不同, 结果位为1, 否则为0.
    1 ^ 1 = 0, 1 ^ 0 = 1, 0 ^ 1 = 1, 0 ^ 0 = 0
    从上面这些结果中可以总结出, 异或操作也就是*不进位加法*, 比如1 + 1 = 10,  我们只取个位, 不要进位的那个1, 其他同理。
    e.g. A = (10)10 = (001010)2, B = (44)10 = (101100)2
    A ^ B = (10)10 ^ (44)10 = (001010)2 ^ (101100)2 = (100110)2 = (38)10
    具体的竖式操作：
    ```
    A    001010
    B    101100
    -----------
    C    100110     结果 C = (100110)2 = (38)10
    ```

* **按位非操作 ~A**
    将A的二进制表示每一位进行取反操作, 如果对应的二进制位为0, 结果位为1, 否则为0.
    这里是指一个位(bit)取反, 对整数1取反结果不是0, 因为整数1由32位(bit)组成。
    比如十进制1, 表示成2进制是(00000000000000000000000000000001)2, 这里是32位有符号整数
    A =   (1)10 = (00000000000000000000000000000001)2
    ~A = ~ (1)10 = (11111111111111111111111111111110)2 = (-2)10   所以对整数1进行取非操作, 得到的结果是-2
    A =   (10)10 = (00000000000000000000000000001010)2
    ~A = ~ (10)10 = (11111111111111111111111111110101)2 = (-11)10
    取反对符号位也是同样的操作!

* **左移操作 A << B**
    将 A 的二进制表示的整体向左移 B 位, 左边超出 32 位的截掉（如果是 int 的话）, 右边不足的位补 0
    e.g. 对于10进制数12, 他的二进制表示下, 是1100, 那么将其左移 2 位, 得到的结果是 110000
    ```java
    int A = 12; int B = 2;
    // C 的值将是 (110000)2 也就是十进制中的 48
    int C = A << B;
    ```
    左移操作的结果"几乎"等于A * 2^B (如果不溢出的情况下)
    那为什么不直接写成 A * 2^B 呢? 因为位移运算比乘法和求幂的运算快很多
    e.g. (13)10 << 3 = (1101)2 << 3 = (1101000)2 = (104)10
         3 << 1 = 6
         2147483647 << 1 = -2
    Note: Python是弱类型的语法, 他的整数在超过传统的 32 位整数之后, 会自动转换为超大整数, 所以没有越界/溢出的问题

* **右移操作 算术右移 A >> B, 逻辑右移 A >>> B**
    - 算术右移是带符号的右移 A >> B
        将A的二进制表示的每一位向右移B位, 右边超出的位截掉, 左边不足的位补符号位的数（比如负数符号位是1则补充1, 正数符号位是0则补充0）, 所以对于算术右移, 原来是负数的, 结果还是负数, 原来是正数的结果还是正数
    - 逻辑右移是不带符号的右移 A >>> B
        将A的二进制表示的每一位向右移B位, 右边超出的位截掉, 左边不足的位补0。所以对于逻辑右移, 结果将会是一个正数

    e.g. 对于十进制数-127, 已知(-127)10 = (11111111111111111111111110000001)2 /* 因为是负数, 所以最高位上是1 */
    算术右移的运算过程是：
    A = (-127)10 >> 2 = (11111111111111111111111110000001)2 >> 2 = (11111111111111111111111111100000)2 = (-32)10
    逻辑右移的运算过程是：
    A = (-127)10 >> 2 = (11111111111111111111111110000001)2 >> 2 = (00111111111111111111111111100000)2 = (1073741792)10
    Note: 只有Java里面有特殊的>>>符号, 对于C++或者C的一些语言标准中指出, 无符号数执行的所有移位操作都是逻辑的, 而对于有符号数, 采用哪种方式取决于编译器。算术左移和逻辑左移是相同的, 而算术右移和逻辑右移, 取决于符号位。

---

## 1.3. 位运算在面试中的基本应用
涉及到位运算的题，最好不要用python
- python没有byte, short, int, long这种type的概念, Python的整数没有特定的字节上限
- Lintcode题目规定32bit int型(Java)，python中就需要人为模拟计算机的反码、补码的操作，第31bit为1时要当成负数
- 出这种要左右移位并求反题的人多半自己不是写Python的
    ```python
    INT_RANGE = 0xFFFFFFFF
    a = a & INT_RANGE
    ```
* 应用一：给出两个32位的整数N和M, 以及两个二进制位的位置i和j, 使得N中的第i到j位等于M（M会是N中从第i位开始到第j位的子串）
    Lintcode 179.[Update Bits]()
    n = (1024)10 = (00000000000000000000010000000000)2;     // 我们这里用32位表述
    m =   (21)10 = (00000000000000000000000000010101)2;     // 1 + 4 + 16 = 21, 这里同样用32位表述
    i = 2, j = 6, 根据题目, 我们希望最终得到的结果是 (00000000000000000000010001010100)2 = (1108)10
    将n中第i位到第j位先置为0, 然后按位或m << i即可

    - 将n中第i位到第j位先置为0
        可以考虑构造一个数, 这个数从第i位到第j位是0, 其他位都为1, 然后这个数和n按位与, 就可以把n的i~j位置成0了
        这样的数并不是很好构造, 反过来思考先构造一个数从第i位到第j位都是1, 其他位为0的数, 然后将这个数取反, 就可以得到从第i位到第j位是0, 其他位是1的数

        -1的二进制表示所有位为1 (i.e.32位全是1的二进制对应整数-1), 以-1为起点, 将高(31-j)位置0, 将低i位置0 
        e.g. 当i = 2, j = 6, 将-1看成全是1的二进制表示, 把高(31 - 6) = 25位全部置成0, 低2位也置成0
            (-1)10 = (11111111111111111111111111111111)2
            把-1的前面25位和后面2位置成0之后, 结果为(00000000000000000000000001111100)2

        *具体的操作*：
        - 将-1先左移(31-j)位, 因为高(31-j)位都是不需要的：
            (-1)10 << (31 - 6) = (-1) << 25 = (11111110000000000000000000000000)2 = (-33554432)10
        - 在这个基础上逻辑右移(31 - j + i)位, 将低i位置0：
            (-33554432)10 >>> (31 - 6 + 2) = (00000000000000000000000000011111)2 = (31)10 
        - 最后左移i位, 这里也就是左移2位, 将1恢复到正确的位置即可。即得到第i位到第j位是1, 其他位是0的数
            (31)10 << 2 = (00000000000000000000000000011111)2 << 2 = (00000000000000000000000001111100)2 = (124)10

    ```java
    public int updateBits(int n, int m, int i, int j) {
        return ((~((((-1) << (31 - j)) >>> (31 - j + i)) << i)) & n) | (m << i);
    }
    ```
    
* 应用二：求两个整数a和b的和, 不使用 + 等数学运算符
    Lintcode 1.[A + B Problem]()
    - 主要利用异或运算来完成, 异或运算有一个别名叫做：不进位加法, 我们在前面的基本运算第二章中有提到过。
        那么a ^ b就是a和b相加之后, 该进位的地方不进位的结果, 相信这一点大家没有疑问, 但是需要注意的是, 这个加法是在二进制下完成的加法。
    - a和b里都是1的地方需要进位
        a & b就是a和b里都是1的那些位置, 那么这些位置左边都应该有一个进位1, a & b << 1 就是进位的数值(a & b的结果所有左移一位)
    - 把不进位的结果和进位的结果加起来, 就是实际中a + b的和
        a + b = (a ^ b) + (a & b << 1)
        令a' = a ^ b, b' = (a & b) << 1 => a + b = (a ^ b) + (a & b << 1) = a' + b'
    - 反复迭代, 这个过程是在二进制下模拟加法的运算过程, 进位不可能一直持续, 所以b最终会变为0, 也就是没有需要进位的了, 因此重复做上述操作就可以最终求得a + b的值
    ```java
    public int aplusb(int a, int b) {
        while (b != 0) {
            int _a = a ^ b;
            int _b = (a & b) << 1;
            a = _a;
            b = _b;
        }
        return a;
    }
    ```


## 1.4. 位运算在面试中的常见技巧
在面试中, 位运算有很多巧妙的用法, 会让面试官眼前一亮


## 1.5. Questions
https://www.lintcode.com/ladder/25