<!-- TOC -->

- [1. Bit Manipulation 位运算](#1-bit-manipulation-%E4%BD%8D%E8%BF%90%E7%AE%97)
    - [1.1. Conversion](#11-conversion)
    - [1.2. Operations](#12-operations)
    - [1.3. 位运算在面试中的基本应用](#13-%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8)
    - [1.4. 位运算在面试中的常见技巧](#14-%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7)
        - [1.4.1. 技巧一: 获取二进制中最右侧的那个1](#141-%E6%8A%80%E5%B7%A7%E4%B8%80-%E8%8E%B7%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E6%9C%80%E5%8F%B3%E4%BE%A7%E7%9A%84%E9%82%A3%E4%B8%AA1)
        - [1.4.2. 技巧二: 使用二进制进行子集枚举](#142-%E6%8A%80%E5%B7%A7%E4%BA%8C-%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%9B%E8%A1%8C%E5%AD%90%E9%9B%86%E6%9E%9A%E4%B8%BE)
        - [1.4.3. 技巧三: 巧用异或运算](#143-%E6%8A%80%E5%B7%A7%E4%B8%89-%E5%B7%A7%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97)
- [2. More on bits](#2-more-on-bits)
- [3.](#3)

<!-- /TOC -->

# 1. Bit Manipulation 位运算

## 1.1. Conversion
* 十进制转换二进制 decimal numeral system, base-ten positional numeral system (denary/decanary)
    * built-in bin(18)
    *   ```Python
        def bin(x):
            if x == 0: 
                print(0)

            def gen(num):
                while num > 0:
                    yield num % 2
                    num = num >> 1
            
            l = [ i for i in gen(abs(x))]
            if x > 0:
                print ('%d' * len(l) % tuple(reversed(l)))
            if x < 0:
                print ('-' + '%d'* len(l) % tuple(reversed(l)))
        ```
* 二进制转换十进制 binary number converts to decimal form
    * int(str(num), b)	  # 将base-b的num转换为10进制


## 1.2. Operations
Note: (x)b 表示 x 是 b 进制 (base)
* **按位与操作 A & B**
    将A和B的二进制表示的每一位进行与操作, 只有两个对应的二进制位都为1时, 结果位才为1, 否则为0.
    1 & 1 = 1, 1 & 0 = 0, 0 & 1 = 0, 0 & 0 = 0
    e.g. A = (10)10 = (001010)2, B = (44)10 = (101100)2
    A & B = 10 & 44 = 001010 & 101100 = (001000)2 = (8)10
    你可能会问为什么这里10对应的二进制是001010, 而不是1010? 这是因为对于空缺的位置使用0去补足即可
    所以10和44进行&运算的结果是8

* **按位或操作 A | B**
    将A和B的二进制表示的每一位进行或操作, 只要两个对应的二进制位有一个为1, 结果位就为1, 否则为0.
    1 | 1 = 1, 1 | 0 = 1, 0 | 1 = 1, 0 | 0 = 0
    e.g. A = (10)10 = (001010)2, B = (44)10 = (101100)2
    A | B = 10 | 44 = 001010 | 101100 = (101110)2 = (46)10  所以10和44进行|运算的结果是46

* **按位异或操作 A ^ B**
    将A和B的二进制表示的每一位进行异或操作, 如果对应的二进制位不同, 结果位为1, 否则为0.
    1 ^ 1 = 0, 1 ^ 0 = 1, 0 ^ 1 = 1, 0 ^ 0 = 0
    从上面这些结果中可以总结出, 异或操作也就是*不进位加法*, 比如1 + 1 = 10,  我们只取个位, 不要进位的那个1, 其他同理。
    e.g. A = (10)10 = (001010)2, B = (44)10 = (101100)2
    A ^ B = (10)10 ^ (44)10 = (001010)2 ^ (101100)2 = (100110)2 = (38)10
    具体的竖式操作: 
    ```
    A    001010
    B    101100
    -----------
    C    100110     结果 C = (100110)2 = (38)10
    ```

* **按位非操作 ~A**
    将A的二进制表示每一位进行取反操作, 如果对应的二进制位为0, 结果位为1, 否则为0.
    这里是指一个位(bit)取反, 对整数1取反结果不是0, 因为整数1由32位(bit)组成。
    比如十进制1, 表示成2进制是(00000000000000000000000000000001)2, 这里是32位有符号整数
    A =   (1)10 = (00000000000000000000000000000001)2
    ~A = ~ (1)10 = (11111111111111111111111111111110)2 = (-2)10   所以对整数1进行取非操作, 得到的结果是-2
    A =   (10)10 = (00000000000000000000000000001010)2
    ~A = ~ (10)10 = (11111111111111111111111111110101)2 = (-11)10
    取反对符号位也是同样的操作!

* **左移操作 A << B**
    将 A 的二进制表示的整体向左移 B 位, 左边超出 32 位的截掉（如果是 int 的话）, 右边不足的位补 0
    e.g. 对于10进制数12, 他的二进制表示下, 是1100, 那么将其左移 2 位, 得到的结果是 110000
    ```java
    int A = 12; int B = 2;
    // C 的值将是 (110000)2 也就是十进制中的 48
    int C = A << B;
    ```
    左移操作的结果"几乎"等于A * 2^B (如果不溢出的情况下)
    那为什么不直接写成 A * 2^B 呢? 因为位移运算比乘法和求幂的运算快很多
    e.g. (13)10 << 3 = (1101)2 << 3 = (1101000)2 = (104)10
         3 << 1 = 6
         2147483647 << 1 = -2
    Note: Python是弱类型的语法, 他的整数在超过传统的 32 位整数之后, 会自动转换为超大整数, 所以没有越界/溢出的问题

* **右移操作 算术右移 A >> B, 逻辑右移 A >>> B**
    - 算术右移是带符号的右移 A >> B
        将A的二进制表示的每一位向右移B位, 右边超出的位截掉, 左边不足的位补符号位的数（比如负数符号位是1则补充1, 正数符号位是0则补充0）, 所以对于算术右移, 原来是负数的, 结果还是负数, 原来是正数的结果还是正数
    - 逻辑右移是不带符号的右移 A >>> B
        将A的二进制表示的每一位向右移B位, 右边超出的位截掉, 左边不足的位补0。所以对于逻辑右移, 结果将会是一个正数

    e.g. 对于十进制数-127, 已知(-127)10 = (11111111111111111111111110000001)2 /* 因为是负数, 所以最高位上是1 */
    算术右移的运算过程是: 
    A = (-127)10 >> 2 = (11111111111111111111111110000001)2 >> 2 = (11111111111111111111111111100000)2 = (-32)10
    逻辑右移的运算过程是: 
    A = (-127)10 >> 2 = (11111111111111111111111110000001)2 >> 2 = (00111111111111111111111111100000)2 = (1073741792)10
    Note: 只有Java里面有特殊的>>>符号, 对于C++或者C的一些语言标准中指出, 无符号数执行的所有移位操作都是逻辑的, 而对于有符号数, 采用哪种方式取决于编译器。算术左移和逻辑左移是相同的, 而算术右移和逻辑右移, 取决于符号位

236.[Swap Bits]()
- Get all even bits: even_bits = x & 0xAAAAAAAA (1010 1010 1010 1010 1010 1010 1010 1010)
- Get all odd bits: odd_bits = x & 0x55555555 (0101 0101 0101 0101 0101 0101 0101 0101)
- Right shift even bits: even_bits >>= 1
- Left shift odd bits: odd_bits <<= 1
- Combine even and odd bits (或运算): even_bits | odd_bits

---

## 1.3. 位运算在面试中的基本应用
涉及到位运算的题, 最好不要用python 
- python3数值超过int后自动转long, 要自己bound一下 (bound = 2**32 - 1)
- python没有byte, short, int, long这种type的概念, Python的整数没有特定的字节上限
- Lintcode题目规定32bit int型(Java), python中就需要人为模拟计算机的反码、补码的操作, 第31bit为1时要当成负数
- 出这种要左右移位并求反题的人多半自己不是写Python的
    ```python
    INT_RANGE = 0xFFFFFFFF
    a = a & INT_RANGE
    ```
* 应用一: 给出两个32位的整数N和M, 以及两个二进制位的位置i和j, 使得N中的第i到j位等于M（M会是N中从第i位开始到第j位的子串）
    Lintcode 179.[Update Bits]()
    n = (1024)10 = (00000000000000000000010000000000)2;     // 我们这里用32位表述
    m =   (21)10 = (00000000000000000000000000010101)2;     // 1 + 4 + 16 = 21, 这里同样用32位表述
    i = 2, j = 6, 根据题目, 我们希望最终得到的结果是 (00000000000000000000010001010100)2 = (1108)10
    将n中第i位到第j位先置为0, 然后按位或m << i即可

    - 将n中第i位到第j位先置为0
        可以考虑构造一个数, 这个数从第i位到第j位是0, 其他位都为1, 然后这个数和n按位与, 就可以把n的i~j位置成0了
        这样的数并不是很好构造, 反过来思考先构造一个数从第i位到第j位都是1, 其他位为0的数, 然后将这个数取反, 就可以得到从第i位到第j位是0, 其他位是1的数

        -1的二进制表示所有位为1 (i.e.32位全是1的二进制对应整数-1), 以-1为起点, 将高(31-j)位置0, 将低i位置0 
        e.g. 当i = 2, j = 6, 将-1看成全是1的二进制表示, 把高(31 - 6) = 25位全部置成0, 低2位也置成0
            (-1)10 = (11111111111111111111111111111111)2
            把-1的前面25位和后面2位置成0之后, 结果为(00000000000000000000000001111100)2

        *具体的操作*: 
        - 将-1先左移(31-j)位, 因为高(31-j)位都是不需要的: 
            (-1)10 << (31 - 6) = (-1) << 25 = (11111110000000000000000000000000)2 = (-33554432)10
        - 在这个基础上逻辑右移(31 - j + i)位, 将低i位置0: 
            (-33554432)10 >>> (31 - 6 + 2) = (00000000000000000000000000011111)2 = (31)10 
        - 最后左移i位, 这里也就是左移2位, 将1恢复到正确的位置即可。即得到第i位到第j位是1, 其他位是0的数
            (31)10 << 2 = (00000000000000000000000000011111)2 << 2 = (00000000000000000000000001111100)2 = (124)10

    ```java
    public int updateBits(int n, int m, int i, int j) {
        return ((~((((-1) << (31 - j)) >>> (31 - j + i)) << i)) & n) | (m << i);
    }
    ```
    
* 应用二: 求两个整数a和b的和, 不使用 + 等数学运算符
    Lintcode 1.[A + B Problem]()
    - 主要利用异或运算来完成, 异或运算有一个别名叫做: 不进位加法, 我们在前面的基本运算第二章中有提到过。
        那么a ^ b就是a和b相加之后, 该进位的地方不进位的结果, 相信这一点大家没有疑问, 但是需要注意的是, 这个加法是在二进制下完成的加法。
    - a和b里都是1的地方需要进位
        a & b就是a和b里都是1的那些位置, 那么这些位置左边都应该有一个进位1, a & b << 1 就是进位的数值(a & b的结果所有左移一位)
    - 把不进位的结果和进位的结果加起来, 就是实际中a + b的和
        a + b = (a ^ b) + (a & b << 1)
        令a' = a ^ b, b' = (a & b) << 1 => a + b = (a ^ b) + (a & b << 1) = a' + b'
    - 反复迭代, 这个过程是在二进制下模拟加法的运算过程, 进位不可能一直持续, 所以b最终会变为0, 也就是没有需要进位的了, 因此重复做上述操作就可以最终求得a + b的值
    ```java
    public int aplusb(int a, int b) {
        while (b != 0) {
            int _a = a ^ b;
            int _b = (a & b) << 1;
            a = _a;
            b = _b;
        }
        return a;
    }
    ```


## 1.4. 位运算在面试中的常见技巧
在面试中, 位运算有很多巧妙的用法, 会让面试官眼前一亮

### 1.4.1. 技巧一: 获取二进制中最右侧的那个1
x & (x - 1) 用于消去x最后一位的1
e.g. x = 12, 那么在二进制下就是(1100)2
x           = 1100
x - 1       = 1011
x & (x - 1) = 1000
* 应用一: 用 O(1) 时间检测整数 n 是否是 2 的幂次
    Lintcode 142.[O(1) Check Power of 2]()
    N如果是2的幂次, 则N满足两个条件
    1.N > 0     2.N的二进制表示中只有一个1, 注意只能有1个。
    因为N的二进制表示中只有一个1, 所以使用N & (N - 1)将N唯一的一个1消去, 应该返回0
    ```java
    bool checkPowerOf2(int n) {
        // write your code here
        return n > 0 && (n & (n - 1)) == 0;
    }
    ```
* 应用二: 计算在一个 32 位的整数的二进制表式中有多少个 1
    Lintcode 365.[Count 1 in Binary]()  
    由x & (x - 1)消去x最后一位的1可知, 不断使用 x & (x - 1) 消去x最后一位的1, 计算总共消去了多少次即可
    ```java
    public int countOnes(int num) {
        int count = 0;
        while (num != 0) {
            num = num & (num - 1);
            count++;
        }
        return count;
    }
    ```
* 应用三: 如果要将整数A转换为B, 需要改变多少个bit位 (这个应用是上面一个应用的拓展)
    Lintcode 181.[Flip Bits]()
    将整数A转换为B, 如果A和B在第i（0 <= i < 32）个位上相等, 则不需要改变这个BIT位, 如果在第i位上不相等, 则需要改变这个BIT位。
    问题转化为了A和B有多少个BIT位不相同
    --> 位运算有一个异或操作, 相同为0, 相异为1, 所以问题转变成了计算A异或B之后这个数中1的个数
    ```java
    public int countOnes(int num) {
        int count = 0;
        while (num != 0) {
            num = num & (num - 1);
            count++;
        }
        return count;
    }

    public int bitSwapRequired(int a, int b) {
        return countOnes(a ^ b);
    }
    ```

### 1.4.2. 技巧二: 使用二进制进行子集枚举
应用: 给定一个含不同整数的集合, 返回其所有的子集
Lintcode 17.[Subsets]()
使用一个正整数二进制表示的第i位是1还是0来代表集合的第i个数取或者不取, 所以从0到2^n-1总共2^n个整数, 正好对应集合的2^n个子集
    ```
    整数 <=> 二进制 <=> 对应集合   之间的转换关系: S = {1,2,3}
    N       bit     Combination
    0       000     {}
    1       001     {1}
    2       010     {2}
    3       011     {1,2}
    4       100     {3}
    5       101     {1,3}
    6       110     {2,3}
    7       111     {1,2,3}
    ```

### 1.4.3. 技巧三: 巧用异或运算
a ^ b ^ b = a   对一个数异或两次等价于没有任何操作

* 应用一: 数组中, 只有一个数出现一次, 剩下都出现两次, 找出出现一次的数
    Lintcode 82.[Single Number]()
    因为只有一个数恰好出现一个, 剩下的都出现过两次, 所以只要将所有的数异或起来, 就可以得到唯一的那个数, 因为相同的数出现的两次, 异或两次等价于没有任何操作

* 应用二: 数组中, 只有一个数出现一次, 剩下都出现三次, 找出出现一次的数
    Lintcode 83.[Single Number II]()
    因为其他数是出现三次的, 也就是说, 对于每一个二进制位, 如果只出现一次的数在该二进制位为1, 那么这个二进制位在全部数字中出现次数无法被3整除
    对于每一位, 我们让Two, One表示当前位的状态
    Two和One里面的每一位的定义, 对于ith(表示第i位): 
        如果Two里面ith是1, 则ith当前为止出现1的次数模3的结果是2
        如果One里面ith是1, 则ith目前为止出现1的次数模3的结果是1
    注意Two和One里面不可能ith同时为1, 因为这样就是3次, 每出现3次我们就可以抹去（消去）。那么最后One里面存储的就是每一位模3是1的那些位, 综合起来One也就是最后我们要的结果

    新来一个数B(输入数字的对应位), 跟原来出现1次的位做一个异或运算, &上~Two的结果(也就是不是出现2次的), 那么剩余的就是当前状态是1的结果
    同理Two ^ B (2次加1次是3次, 也就是Two里面ith是1, B里面ith也是1, 那么ith应该是出现了3次, 此时就可以消去, 设置为0), 我们相当于会消去出现3次的位
    但是Two ^ B也可能是ith上Two是0, B的ith是1, 这样Two里面就混入了模3是1的那些位, 我们得消去这些！我们只需要保留不是出现模3余1的那些位ith, 而One是恰好保留了那些模3余1次数的位, 取反不就是不是模3余1的那些位ith么? 最终对(~One)取一个&即可
    综合起来就是: 
    One = (One ^ B) & (~Two)
    Two = (Two ^ B) & (~One)

* 应用三: 数组中, 只有两个数出现一次, 剩下都出现两次, 找出出现一次的这两个数
    Lintcode 84.[Single Number III]()
    - 有了第一题的基本的思路, 我们可以将数组分成两个部分, 每个部分里只有一个元素出现一次, 其余元素都出现两次。那么使用这种方法就可以找出这两个元素了。
    - 假设出现一次的两个元素是x, y, 最终所有的元素异或的结果res = x ^ y 并且res != 0 （如果res等于0, 则说明x和y相等）
    - 因为res不等于0, 那么我们可以一定可以找出res二进制表示中的某一位是1。
        对于x和y, 一定是其中一个这一位是1, 另一个这一位不是1！！！ 因为如果都是0或者都是1, 怎么可能异或出1
        对于原来的数组, 根据这个位置是不是1就将数组分成两个部分, x, y一定在不同的两个子集中
    - 对于其他成对出现的元素, 要么都在x所在的那个集合, 要么在y所在的那个集合。对于这两个集合我们分别求出单个出现的x 和 单个出现的y即可

    Original code 原码, 就是其二进制表示（注意, 有一位符号位）
    Inverse code 反码, 正数的反码就是原码, 负数的反码是符号位不变, 其余位取反   (0的反码, 补码都为0)
    Complementary code 补码, 正数的补码就是原码, 负数的补码是反码+1
    在机器中都是采用补码形式存负数 (补码的定义是符号位变成1, 其他位数, 在最后一个1之前的位置翻转, 之后的位置保持不变)
    ```
    负数的补码为什么和正数的不一样？ 我们不妨假设一下如果负数的和正数一样
    举例: 5+（-5）=0 
    0的二进制原码为:  0000 0000 
    5的二进制原码为:  0000 0101 
    -5的二进制原码为: 1000 0101 
    -5的二进制反码为: 1111 1010 
    -5的二进制补码为: 1111 1011 
    那么按照这个规律, 得到的结果是1000 1010等于-10, 与事实结果的0相反

    反过来推证, 要使结果为0, 那么-5的二进制应该为多少? -5在内存中应该为: 1111 1011。 
    只有这样, 计算机在执行加上一个负数才不会发生数据乱码的问题。 
    所以负数在硬盘或内存中以二进制补码的形式存在
    ```
        
    取最后一位1, diff & (-diff)就是取diff的最后一位1的位置

# 2. More on bits
去掉最后一位  x >> 1   (101101——10110)
最后加一个0   x << 1
最后加一个1   x << 1 + 1 (101101——1011011)
最后一位变成1   x | 1
最后一位变成0   x | 1 - 1
最后一位取反   x ~ 1
把右边第k位变成1   x | (1 << (k-1))   (101001——101101 k=3)
把右边第k位变成0   x & ~(1 << (k-1))   (101101——101001 k =3)
右数第k位取反   x ~ (1 << (k-1))   (101001——101101 k=3)
取末三位   x & 7   (101101——101)
取末k位   x & (~(~0 << k))   (关键是要找到末尾k个1)
取右边第k位   x & (1 << (k-1))
把末k位变成1   x  | ((1 << k) - 1 )   (找到末尾的1, 然后或一下)


* 判断奇偶数
    如果把 n 以二进制的形式展示的话, 只需要判断最后一个二进制位是 1 还是 0, 1代表是奇数, 0代表是偶数
    ```Python
    if n & 1 == 1: # n 是个奇数
    ```
    Note: 写成 n % 2 的形式, 编译器也会自动帮我们优化成位运算

* 交换两个数, 不使用一个额外变量来辅助交换
    x = x ^ y
    y = x ^ y
    x = x ^ y
    - 两个相同的数异或之后结果会等于0, 即 n ^ n = 0
    - 任何数与 0 异或等于它本身, 即 n ^ 0 = n
    - 异或运算支持运算的交换律和结合律

* 3的n次方, 不使用系统自带的 pow 函数
    n = (13)10 = (1101)2, 3 的 13 次方可以拆解为 3^1101 = 3^0001 * 3^0100 * 3^1000
    可以通过 & 1 和 >>1 来逐位读取 1101, 为1时将该位代表的乘数累乘到最终结果, 时间复杂度近为 O(logn)
    ```Python
    def pow(n):
    res = 1
    base = 3
    while n != 0: 
        if n & 1 == 1:
            res *= base
        base *= base
        n = n >> 1
    return res
    ```
位运算很多情况下都和二进制有关系, 所以我们要判断是否是否位运算, 很多情况下都会把他们拆分成二进制, 观察特性, 或者利用与, 或, 异或的特性来观察

* 找出不大于N的最大的2的幂指数
    - 传统的做法就是让 1 不断着乘以 2, 时间复杂度是 O(logn)
    如果要弄成位运算的方式, 很多时候我们把某个数拆成二进制, 然后看看有哪些发现
    - N = 19 = (00010011)2, 那么我们要找的数就是, 把二进制中最左边的 1 保留, 后面的 1 全部变为 0, 目标数是 00010000
        - 找到最左边的 1, 然后把它右边的所有 0 变成 1 (通过把 n 右移并且做或运算即可得到)
        ```Python
        n |= n >> 1
        n |= n >> 2
        n |= n >> 4
        ```
        - 把得到的数值加 1, 可以得到 00100000即 00011111 + 1 = 00100000。
        - 把得到的 00100000 向右移动一位, 即可得到 00010000, 即 00100000 >> 1 = 00010000。
        - 时间复杂度近似 O(1)
假设最左边的 1 处于二进制位中的第 k 位(从左往右数),那么把 n 右移一位之后, 那么得到的结果中第 k+1 位也必定为 1,然后把 n 与右移后的结果做或运算, 那么得到的结果中第 k 和 第 k + 1 位必定是 1;同样的道理, 再次把 n 右移两位, 那么得到的结果中第 k+2和第 k+3 位必定是 1,然后再次做或运算, 那么就能得到第 k, k+1, k+2, k+3 都是 1, 如此往复下去....



# 3.  
* binary pos/neg
* addition
* shifting
* masks