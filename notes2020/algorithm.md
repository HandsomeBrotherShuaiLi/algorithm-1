<!-- TOC -->

- [1. 算法之美](#1-%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E)
- [2. 九章算法班](#2-%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E7%8F%AD)
    - [2.1.](#21)

<!-- /TOC -->

# 1. 算法之美
```list
## 1.1. (3, 4) Complexity (Time & Space)
## 1.2. (5) Array
## 1.3. (6, 7) Linked List
## 1.4. (8) Stack
## 1.5. (9) Queue
## 1.6. (10) Recursion
## 1.7. (11, 12) Sorting
## 1.8. (13) Linear Sort??
## 1.9. (14) Sorting Optimization
## 1.10. (15, 16) Binary Search
## 1.11. (17) Jump
## 1.12. (18, 19, 20) Hash Table
## 1.13. (21, 22) Hash Algorithm
## 1.14. (23, 24) Binary Tree
## 1.15. (25, 26) Red Black Tree
## 1.16. (27) Recursion Tree
## 1.17. (28, 29) Heap & heap Sort & Heap application
## 1.18. (30) Graph
## 1.19. (31) BFS & DFS
## 1.20. (32, 33, 34) String Matching: Brute Force & Rabin-Karp Algorithm
http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html

https://www.cnblogs.com/gaochundong/p/string_matching.html

## 1.21. (35) Trie
## 1.22. (36) AC
## 1.23. (37) Greedy Algorithm
## 1.24. (38) Divide-Conquer
## 1.25. (39) Back-Tracking
## 1.26. (40, 41, 42) Dynamic Programming
## 1.27. (43) Topology Sorting
## 1.28. (44) Minimum Distance
## 1.29. (45) Bitmap
## 1.30. (46) Probablistic Statistics
## 1.31. (47) Vector Space
## 1.32. (48) B+ tree
## 1.33. (49) Searching
## 1.34. (50) Indexing
## 1.35. (51) Parallel Algorithm
## 1.36. (52) ...
```